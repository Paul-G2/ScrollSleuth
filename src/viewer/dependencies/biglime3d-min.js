var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.arrayIteratorImpl=function(b){var h=0;return function(){return h<b.length?{done:!1,value:b[h++]}:{done:!0}}};$jscomp.arrayIterator=function(b){return{next:$jscomp.arrayIteratorImpl(b)}};$jscomp.makeIterator=function(b){var h="undefined"!=typeof Symbol&&Symbol.iterator&&b[Symbol.iterator];return h?h.call(b):$jscomp.arrayIterator(b)};$jscomp.arrayFromIterator=function(b){for(var h,d=[];!(h=b.next()).done;)d.push(h.value);return d};
$jscomp.arrayFromIterable=function(b){return b instanceof Array?b:$jscomp.arrayFromIterator($jscomp.makeIterator(b))};$jscomp.getGlobal=function(b){return"undefined"!=typeof window&&window===b?b:"undefined"!=typeof global&&null!=global?global:b};$jscomp.global=$jscomp.getGlobal(this);$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;
$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(b,h,d){b!=Array.prototype&&b!=Object.prototype&&(b[h]=d.value)};$jscomp.polyfill=function(b,h,d,a){if(h){d=$jscomp.global;b=b.split(".");for(a=0;a<b.length-1;a++){var f=b[a];f in d||(d[f]={});d=d[f]}b=b[b.length-1];a=d[b];h=h(a);h!=a&&null!=h&&$jscomp.defineProperty(d,b,{configurable:!0,writable:!0,value:h})}};$jscomp.FORCE_POLYFILL_PROMISE=!1;
$jscomp.polyfill("Promise",function(b){function h(){this.batch_=null}function d(a){return a instanceof f?a:new f(function(e,b){e(a)})}if(b&&!$jscomp.FORCE_POLYFILL_PROMISE)return b;h.prototype.asyncExecute=function(a){null==this.batch_&&(this.batch_=[],this.asyncExecuteBatch_());this.batch_.push(a);return this};h.prototype.asyncExecuteBatch_=function(){var a=this;this.asyncExecuteFunction(function(){a.executeBatch_()})};var a=$jscomp.global.setTimeout;h.prototype.asyncExecuteFunction=function(e){a(e,
0)};h.prototype.executeBatch_=function(){for(;this.batch_&&this.batch_.length;){var a=this.batch_;this.batch_=[];for(var b=0;b<a.length;++b){var c=a[b];a[b]=null;try{c()}catch(l){this.asyncThrow_(l)}}}this.batch_=null};h.prototype.asyncThrow_=function(a){this.asyncExecuteFunction(function(){throw a;})};var f=function(a){this.state_=0;this.result_=void 0;this.onSettledCallbacks_=[];var b=this.createResolveAndReject_();try{a(b.resolve,b.reject)}catch(g){b.reject(g)}};f.prototype.createResolveAndReject_=
function(){function a(a){return function(e){c||(c=!0,a.call(b,e))}}var b=this,c=!1;return{resolve:a(this.resolveTo_),reject:a(this.reject_)}};f.prototype.resolveTo_=function(a){if(a===this)this.reject_(new TypeError("A Promise cannot resolve to itself"));else if(a instanceof f)this.settleSameAsPromise_(a);else{a:switch(typeof a){case "object":var b=null!=a;break a;case "function":b=!0;break a;default:b=!1}b?this.resolveToNonPromiseObj_(a):this.fulfill_(a)}};f.prototype.resolveToNonPromiseObj_=function(a){var b=
void 0;try{b=a.then}catch(g){this.reject_(g);return}"function"==typeof b?this.settleSameAsThenable_(b,a):this.fulfill_(a)};f.prototype.reject_=function(a){this.settle_(2,a)};f.prototype.fulfill_=function(a){this.settle_(1,a)};f.prototype.settle_=function(a,b){if(0!=this.state_)throw Error("Cannot settle("+a+", "+b+"): Promise already settled in state"+this.state_);this.state_=a;this.result_=b;this.executeOnSettledCallbacks_()};f.prototype.executeOnSettledCallbacks_=function(){if(null!=this.onSettledCallbacks_){for(var a=
0;a<this.onSettledCallbacks_.length;++a)c.asyncExecute(this.onSettledCallbacks_[a]);this.onSettledCallbacks_=null}};var c=new h;f.prototype.settleSameAsPromise_=function(a){var b=this.createResolveAndReject_();a.callWhenSettled_(b.resolve,b.reject)};f.prototype.settleSameAsThenable_=function(a,b){var c=this.createResolveAndReject_();try{a.call(b,c.resolve,c.reject)}catch(l){c.reject(l)}};f.prototype.then=function(a,b){function c(a,b){return"function"==typeof a?function(b){try{e(a(b))}catch(u){d(u)}}:
b}var e,d,k=new f(function(a,b){e=a;d=b});this.callWhenSettled_(c(a,e),c(b,d));return k};f.prototype.catch=function(a){return this.then(void 0,a)};f.prototype.callWhenSettled_=function(a,b){function f(){switch(e.state_){case 1:a(e.result_);break;case 2:b(e.result_);break;default:throw Error("Unexpected state: "+e.state_);}}var e=this;null==this.onSettledCallbacks_?c.asyncExecute(f):this.onSettledCallbacks_.push(f)};f.resolve=d;f.reject=function(a){return new f(function(b,c){c(a)})};f.race=function(a){return new f(function(b,
c){for(var f=$jscomp.makeIterator(a),e=f.next();!e.done;e=f.next())d(e.value).callWhenSettled_(b,c)})};f.all=function(a){var b=$jscomp.makeIterator(a),c=b.next();return c.done?d([]):new f(function(a,f){function e(b){return function(c){k[b]=c;g--;0==g&&a(k)}}var k=[],g=0;do k.push(void 0),g++,d(c.value).callWhenSettled_(e(k.length-1),f),c=b.next();while(!c.done)})};return f},"es6","es3");$jscomp.SYMBOL_PREFIX="jscomp_symbol_";
$jscomp.initSymbol=function(){$jscomp.initSymbol=function(){};$jscomp.global.Symbol||($jscomp.global.Symbol=$jscomp.Symbol)};$jscomp.Symbol=function(){var b=0;return function(h){return $jscomp.SYMBOL_PREFIX+(h||"")+b++}}();
$jscomp.initSymbolIterator=function(){$jscomp.initSymbol();var b=$jscomp.global.Symbol.iterator;b||(b=$jscomp.global.Symbol.iterator=$jscomp.global.Symbol("iterator"));"function"!=typeof Array.prototype[b]&&$jscomp.defineProperty(Array.prototype,b,{configurable:!0,writable:!0,value:function(){return $jscomp.iteratorPrototype($jscomp.arrayIteratorImpl(this))}});$jscomp.initSymbolIterator=function(){}};
$jscomp.initSymbolAsyncIterator=function(){$jscomp.initSymbol();var b=$jscomp.global.Symbol.asyncIterator;b||(b=$jscomp.global.Symbol.asyncIterator=$jscomp.global.Symbol("asyncIterator"));$jscomp.initSymbolAsyncIterator=function(){}};$jscomp.iteratorPrototype=function(b){$jscomp.initSymbolIterator();b={next:b};b[$jscomp.global.Symbol.iterator]=function(){return this};return b};$jscomp.underscoreProtoCanBeSet=function(){var b={a:!0},h={};try{return h.__proto__=b,h.a}catch(d){}return!1};
$jscomp.setPrototypeOf="function"==typeof Object.setPrototypeOf?Object.setPrototypeOf:$jscomp.underscoreProtoCanBeSet()?function(b,h){b.__proto__=h;if(b.__proto__!==h)throw new TypeError(b+" is not extensible");return b}:null;$jscomp.generator={};$jscomp.generator.ensureIteratorResultIsObject_=function(b){if(!(b instanceof Object))throw new TypeError("Iterator result "+b+" is not an object");};
$jscomp.generator.Context=function(){this.isRunning_=!1;this.yieldAllIterator_=null;this.yieldResult=void 0;this.nextAddress=1;this.finallyAddress_=this.catchAddress_=0;this.finallyContexts_=this.abruptCompletion_=null};$jscomp.generator.Context.prototype.start_=function(){if(this.isRunning_)throw new TypeError("Generator is already running");this.isRunning_=!0};$jscomp.generator.Context.prototype.stop_=function(){this.isRunning_=!1};
$jscomp.generator.Context.prototype.jumpToErrorHandler_=function(){this.nextAddress=this.catchAddress_||this.finallyAddress_};$jscomp.generator.Context.prototype.next_=function(b){this.yieldResult=b};$jscomp.generator.Context.prototype.throw_=function(b){this.abruptCompletion_={exception:b,isException:!0};this.jumpToErrorHandler_()};$jscomp.generator.Context.prototype.return=function(b){this.abruptCompletion_={return:b};this.nextAddress=this.finallyAddress_};
$jscomp.generator.Context.prototype.jumpThroughFinallyBlocks=function(b){this.abruptCompletion_={jumpTo:b};this.nextAddress=this.finallyAddress_};$jscomp.generator.Context.prototype.yield=function(b,h){this.nextAddress=h;return{value:b}};$jscomp.generator.Context.prototype.yieldAll=function(b,h){b=$jscomp.makeIterator(b);var d=b.next();$jscomp.generator.ensureIteratorResultIsObject_(d);if(d.done)this.yieldResult=d.value,this.nextAddress=h;else return this.yieldAllIterator_=b,this.yield(d.value,h)};
$jscomp.generator.Context.prototype.jumpTo=function(b){this.nextAddress=b};$jscomp.generator.Context.prototype.jumpToEnd=function(){this.nextAddress=0};$jscomp.generator.Context.prototype.setCatchFinallyBlocks=function(b,h){this.catchAddress_=b;void 0!=h&&(this.finallyAddress_=h)};$jscomp.generator.Context.prototype.setFinallyBlock=function(b){this.catchAddress_=0;this.finallyAddress_=b||0};$jscomp.generator.Context.prototype.leaveTryBlock=function(b,h){this.nextAddress=b;this.catchAddress_=h||0};
$jscomp.generator.Context.prototype.enterCatchBlock=function(b){this.catchAddress_=b||0;b=this.abruptCompletion_.exception;this.abruptCompletion_=null;return b};$jscomp.generator.Context.prototype.enterFinallyBlock=function(b,h,d){d?this.finallyContexts_[d]=this.abruptCompletion_:this.finallyContexts_=[this.abruptCompletion_];this.catchAddress_=b||0;this.finallyAddress_=h||0};
$jscomp.generator.Context.prototype.leaveFinallyBlock=function(b,h){h=this.finallyContexts_.splice(h||0)[0];if(h=this.abruptCompletion_=this.abruptCompletion_||h){if(h.isException)return this.jumpToErrorHandler_();void 0!=h.jumpTo&&this.finallyAddress_<h.jumpTo?(this.nextAddress=h.jumpTo,this.abruptCompletion_=null):this.nextAddress=this.finallyAddress_}else this.nextAddress=b};$jscomp.generator.Context.prototype.forIn=function(b){return new $jscomp.generator.Context.PropertyIterator(b)};
$jscomp.generator.Context.PropertyIterator=function(b){this.object_=b;this.properties_=[];for(var h in b)this.properties_.push(h);this.properties_.reverse()};$jscomp.generator.Context.PropertyIterator.prototype.getNext=function(){for(;0<this.properties_.length;){var b=this.properties_.pop();if(b in this.object_)return b}return null};$jscomp.generator.Engine_=function(b){this.context_=new $jscomp.generator.Context;this.program_=b};
$jscomp.generator.Engine_.prototype.next_=function(b){this.context_.start_();if(this.context_.yieldAllIterator_)return this.yieldAllStep_(this.context_.yieldAllIterator_.next,b,this.context_.next_);this.context_.next_(b);return this.nextStep_()};
$jscomp.generator.Engine_.prototype.return_=function(b){this.context_.start_();var h=this.context_.yieldAllIterator_;if(h)return this.yieldAllStep_("return"in h?h["return"]:function(b){return{value:b,done:!0}},b,this.context_.return);this.context_.return(b);return this.nextStep_()};
$jscomp.generator.Engine_.prototype.throw_=function(b){this.context_.start_();if(this.context_.yieldAllIterator_)return this.yieldAllStep_(this.context_.yieldAllIterator_["throw"],b,this.context_.next_);this.context_.throw_(b);return this.nextStep_()};
$jscomp.generator.Engine_.prototype.yieldAllStep_=function(b,h,d){try{var a=b.call(this.context_.yieldAllIterator_,h);$jscomp.generator.ensureIteratorResultIsObject_(a);if(!a.done)return this.context_.stop_(),a;var f=a.value}catch(c){return this.context_.yieldAllIterator_=null,this.context_.throw_(c),this.nextStep_()}this.context_.yieldAllIterator_=null;d.call(this.context_,f);return this.nextStep_()};
$jscomp.generator.Engine_.prototype.nextStep_=function(){for(;this.context_.nextAddress;)try{var b=this.program_(this.context_);if(b)return this.context_.stop_(),{value:b.value,done:!1}}catch(h){this.context_.yieldResult=void 0,this.context_.throw_(h)}this.context_.stop_();if(this.context_.abruptCompletion_){b=this.context_.abruptCompletion_;this.context_.abruptCompletion_=null;if(b.isException)throw b.exception;return{value:b.return,done:!0}}return{value:void 0,done:!0}};
$jscomp.generator.Generator_=function(b){this.next=function(h){return b.next_(h)};this.throw=function(h){return b.throw_(h)};this.return=function(h){return b.return_(h)};$jscomp.initSymbolIterator();this[Symbol.iterator]=function(){return this}};$jscomp.generator.createGenerator=function(b,h){h=new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(h));$jscomp.setPrototypeOf&&$jscomp.setPrototypeOf(h,b.prototype);return h};
$jscomp.asyncExecutePromiseGenerator=function(b){function h(a){return b.next(a)}function d(a){return b.throw(a)}return new Promise(function(a,f){function c(b){b.done?a(b.value):Promise.resolve(b.value).then(h,d).then(c,f)}c(b.next())})};$jscomp.asyncExecutePromiseGeneratorFunction=function(b){return $jscomp.asyncExecutePromiseGenerator(b())};$jscomp.asyncExecutePromiseGeneratorProgram=function(b){return $jscomp.asyncExecutePromiseGenerator(new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(b)))};
$jscomp.iteratorFromArray=function(b,h){$jscomp.initSymbolIterator();b instanceof String&&(b+="");var d=0,a={next:function(){if(d<b.length){var f=d++;return{value:h(f,b[f]),done:!1}}a.next=function(){return{done:!0,value:void 0}};return a.next()}};a[Symbol.iterator]=function(){return a};return a};$jscomp.polyfill("Array.prototype.keys",function(b){return b?b:function(){return $jscomp.iteratorFromArray(this,function(b){return b})}},"es6","es3");
$jscomp.polyfill("Array.prototype.fill",function(b){return b?b:function(b,d,a){var f=this.length||0;0>d&&(d=Math.max(0,f+d));if(null==a||a>f)a=f;a=Number(a);0>a&&(a=Math.max(0,f+a));for(d=Number(d||0);d<a;d++)this[d]=b;return this}},"es6","es3");$jscomp.polyfill("Object.is",function(b){return b?b:function(b,d){return b===d?0!==b||1/b===1/d:b!==b&&d!==d}},"es6","es3");
$jscomp.polyfill("Array.prototype.includes",function(b){return b?b:function(b,d){var a=this;a instanceof String&&(a=String(a));var f=a.length;d=d||0;for(0>d&&(d=Math.max(d+f,0));d<f;d++){var c=a[d];if(c===b||Object.is(c,b))return!0}return!1}},"es7","es3");
$jscomp.checkStringArgs=function(b,h,d){if(null==b)throw new TypeError("The 'this' value for String.prototype."+d+" must not be null or undefined");if(h instanceof RegExp)throw new TypeError("First argument to String.prototype."+d+" must not be a regular expression");return b+""};$jscomp.polyfill("String.prototype.includes",function(b){return b?b:function(b,d){return-1!==$jscomp.checkStringArgs(this,b,"includes").indexOf(b,d||0)}},"es6","es3");
$jscomp.owns=function(b,h){return Object.prototype.hasOwnProperty.call(b,h)};$jscomp.assign="function"==typeof Object.assign?Object.assign:function(b,h){for(var d=1;d<arguments.length;d++){var a=arguments[d];if(a)for(var f in a)$jscomp.owns(a,f)&&(b[f]=a[f])}return b};$jscomp.polyfill("Object.assign",function(b){return b||$jscomp.assign},"es6","es3");$jscomp.polyfill("Number.MAX_SAFE_INTEGER",function(){return 9007199254740991},"es6","es3");
$jscomp.polyfill("Object.values",function(b){return b?b:function(b){var d=[],a;for(a in b)$jscomp.owns(b,a)&&d.push(b[a]);return d}},"es8","es3");$jscomp.polyfill("Math.log2",function(b){return b?b:function(b){return Math.log(b)/Math.LN2}},"es6","es3");
$jscomp.polyfill("Array.from",function(b){return b?b:function(b,d,a){d=null!=d?d:function(a){return a};var f=[],c="undefined"!=typeof Symbol&&Symbol.iterator&&b[Symbol.iterator];if("function"==typeof c){b=c.call(b);for(var e=0;!(c=b.next()).done;)f.push(d.call(a,c.value,e++))}else for(c=b.length,e=0;e<c;e++)f.push(d.call(a,b[e],e));return f}},"es6","es3");
$jscomp.findInternal=function(b,h,d){b instanceof String&&(b=String(b));for(var a=b.length,f=0;f<a;f++){var c=b[f];if(h.call(d,c,f,b))return{i:f,v:c}}return{i:-1,v:void 0}};$jscomp.polyfill("Array.prototype.find",function(b){return b?b:function(b,d){return $jscomp.findInternal(this,b,d).v}},"es6","es3");
$jscomp.polyfill("String.prototype.startsWith",function(b){return b?b:function(b,d){var a=$jscomp.checkStringArgs(this,b,"startsWith");b+="";var f=a.length,c=b.length;d=Math.max(0,Math.min(d|0,a.length));for(var e=0;e<c&&d<f;)if(a[d++]!=b[e++])return!1;return e>=c}},"es6","es3");$jscomp.polyfill("Math.sign",function(b){return b?b:function(b){b=Number(b);return 0===b||isNaN(b)?b:0<b?1:-1}},"es6","es3");
(function(b,h){b.Logger=function(){};b.Logger.Severity={Debug:0,Info:1,Client:2,Warning:3,Warn:3,Error:4};Object.freeze(b.Logger.Severity);b.Logger.ConsoleThresh=b.Logger.Severity.Info;b.Logger._MaxIncidents=1E3;b.Logger._IncidentList=[];b.Logger._NumErrors=0;b.Logger._NumWarnings=0;b.Logger.Report=function(d,a,f,c){var e=b.Logger.Severity;d=d||"";a>=e.Debug&&a<=e.Error||(a=e.Error);for(;b.Logger._IncidentList.length>=b.Logger._MaxIncidents;)b.Logger._IncidentList.shift();b.Logger._IncidentList.push({msg:d,
severity:a});a===e.Error&&b.Logger._NumErrors++;a===e.Warn&&b.Logger._NumWarnings++;a>=b.Logger.ConsoleThresh&&window.console&&(a=(a=a<=e.Debug?window.console.debug:a==e.Info||a==e.Client?window.console.info:a==e.Warn?window.console.warn:window.console.error)||window.console.log)&&a(d);if(c)throw Error(d);!0===f&&alert(d)};b.Logger.Clear=function(){b.Logger._IncidentList=[];b.Logger._NumErrors=0;b.Logger._NumWarnings=0};b.Logger.NumIncidents=function(){return b.Logger._IncidentList.length};b.Logger.NumErrors=
function(){return b.Logger._NumErrors};b.Logger.NumWarnings=function(){return b.Logger._NumWarnings};b.Logger.LastIncident=function(){var d=b.Logger._IncidentList.length;return 0<d?b.Logger._IncidentList[d-1]:null};b.Logger.LastErrorMsg=function(){for(var d=b.Logger._IncidentList.length-1;0<=d;d--){var a=b.Logger._IncidentList[d];if(a.severity===b.Logger.Severity.Error)return a.msg}return""};b.Logger.LastWarningMsg=function(){for(var d=b.Logger._IncidentList.length-1;0<=d;d--){var a=b.Logger._IncidentList[d];
if(a.severity===b.Logger.Severity.Warn)return a.msg}return""};b.Logger.LastDebugMsg=function(){for(var d=b.Logger._IncidentList.length-1;0<=d;d--){var a=b.Logger._IncidentList[d];if(a.severity===b.Logger.Severity.Debug)return a.msg}return""};b.Logger.LastInfoMsg=function(){for(var d=b.Logger._IncidentList.length-1;0<=d;d--){var a=b.Logger._IncidentList[d];if(a.severity===b.Logger.Severity.Info)return a.msg}return""}})(window.BigLime=window.BigLime||{});
(function(b,h){b.Loader3D=function(){this.vol=null;this.done=this.cancelled=!1;this.loadProgressCb=this.loadCompleteCb=this.rgbaBuf=null;this.warnings=this.errors=""};b.Loader3D.prototype.cancelLoading=function(){this.cancelled=!0};b.Loader3D.prototype._copyImagesToTexture=function(d){var a="";this.vol instanceof b.VolumeT3?this._copyImagesToTexture3D(d):this.vol instanceof b.VolumeT2?this._copyImagesToTexture2D(d):a="Loader3D: Invalid volume type.";return a};b.Loader3D.prototype._copyImagesToTexture3D=
function(d){var a=this.vol,f=a.context.gl,c=a.dims[0],e=a.dims[1],k=8==a.bpp?f.RED:f.RG,g=f.createBuffer();f.bindBuffer(f.PIXEL_UNPACK_BUFFER,g);for(var l=d.startIndex;l<d.endIndex;l++){var m=d.imgBuffers[l-d.startIndex];m.buffer&&(m=m.buffer);16==a.bpp&&a.bigEndian&&b.Loader3D._SwapByteOrder(m);f.bufferData(f.PIXEL_UNPACK_BUFFER,m,f.DYNAMIC_COPY);a.texture.bind();f.texSubImage3D(f.TEXTURE_3D,0,0,0,l,c,e,1,k,f.UNSIGNED_BYTE,0);a.histogram.addImage(m,a.bpp/8,!1)}f.bindBuffer(f.PIXEL_UNPACK_BUFFER,
null);f.deleteBuffer(g)};b.Loader3D.prototype._copyImagesToTexture2D=function(b){var a=this.vol,f=a.dims[0],c=a.dims[1],e=a.txInfo;this.rgbaBuf&&this.rgbaBuf.length==4*f*c||(this.rgbaBuf=new Uint8Array(4*f*c));16==a.bpp?this._populateRgbaBuffer_From16bitImages(b):this._populateRgbaBuffer_From8bitImages(b);var d=b.startIndex/e.imgsPerTile;b=Math.floor(d/(e.NTx*e.NTy));var g=d-b*e.tilesPerTexture;d=Math.floor(g/e.NTx);e=g-d*e.NTx;g=a.context.gl;a.textures[b].bind();g.texSubImage2D(g.TEXTURE_2D,0,e*
f,d*c,f,c,g.RGBA,g.UNSIGNED_BYTE,this.rgbaBuf)};b.Loader3D.prototype._populateRgbaBuffer_From16bitImages=function(b){var a=this.vol,f=a.dims[0],c=a.dims[1],e=f*c,d=b.endIndex-b.startIndex,g,l=[];for(g=0;g<d;g++)l.push(b.imgBuffers[g].buffer||b.imgBuffers[g]);b=(c-1)*f;for(g=0;g<d;g++){for(var m=new Uint16Array(l[g]),n=0;n<c;n++){var p=n*f;m[p]=m[p+f-1]=0}for(n=0;n<f;n++)m[n]=m[b+n]=0}f=[];f.push(0<d?new Uint8Array(l[0]):null);f.push(1<d?new Uint8Array(l[1]):null);c=0;b=2*e;for(g=0;g<b;g+=2)for(e=
0;2>e;e++)f[e]?(this.rgbaBuf[c++]=a.bigEndian?f[e][g+1]:f[e][g],this.rgbaBuf[c++]=a.bigEndian?f[e][g]:f[e][g+1]):(this.rgbaBuf[c++]=0,this.rgbaBuf[c++]=0);for(g=0;2>g;g++)g<d&&a.histogram.addImage(l[g],a.bpp/8,a.bigEndian)};b.Loader3D.prototype._populateRgbaBuffer_From8bitImages=function(b){var a=this.vol,f=a.dims[0],c=a.dims[1],e=f*c,d=b.imgBuffers.length,g,l=[];for(g=0;g<d;g++)l.push(b.imgBuffers[g].buffer||b.imgBuffers[g]);b=(c-1)*f;for(g=0;g<d;g++){for(var m=new Uint8Array(l[g]),n=0;n<c;n++){var p=
n*f;m[p]=m[p+f-1]=0}for(n=0;n<f;n++)m[n]=m[b+n]=0}f=[];f.push(0<d?new Uint8Array(l[0]):null);f.push(1<d?new Uint8Array(l[1]):null);f.push(2<d?new Uint8Array(l[2]):null);f.push(3<d?new Uint8Array(l[3]):null);for(g=c=0;g<e;g++)for(b=0;4>b;b++)this.rgbaBuf[c++]=f[b]?f[b][g]:0;for(g=0;4>g;g++)g<d&&a.histogram.addImage(l[g],a.bpp/8,a.bigEndian)};b.Loader3D._SwapByteOrder=function(b){b=new Uint8Array(b.buffer||b);for(var a=b.length,f=0;f<a;f+=2){var c=b[f];b[f]=b[f+1];b[f+1]=c}}})(window.BigLime=window.BigLime||
{});
(function(b,h){var d=glMatrix.vec2;b.Interactor=function(a,f,c){var e=this;this.eventSources=Array.isArray(a)?a:[a];this.name=f||"";this.eventTypes=c||{btns:0,shift:!1,ctrl:!1,alt:!1};this.isTouchDevice=b.Utils.isTouchDevice();this.enabled=!0;this.pinching=this.active=!1;this.currNumTouches=0;this.currentEventSource=null;this.prevPoint=d.create();this.currPoint=d.create();this.startPoint=d.create();this.deltaPrev=d.create();this.deltaStart=d.create();this.prevPinch={sep:1,ctr:d.create(),ang:0};this.currPinch=
{sep:1,ctr:d.create(),ang:0};this.startPinch={sep:1,ctr:d.create(),ang:0};this.deltaPrevPinch={sep:0,ctr:d.create(),ang:0};this.deltaStartPinch={sep:0,ctr:d.create(),ang:0};this.isTouchDevice?(this.touchStartListener=this._onStartBase.bind(this),this.touchMoveListener=this._onMoveBase.bind(this),this.touchEndListener=this._onEndBase.bind(this),this.eventSources.forEach(function(a){return a.addEventListener("touchstart",e.touchStartListener)}),this.eventSources.forEach(function(a){return a.addEventListener("touchmove",
e.touchMoveListener)}),this.eventSources.forEach(function(a){return a.addEventListener("touchend",e.touchEndListener)})):(this.mouseDownListener=this._onStartBase.bind(this),this.mouseMoveListener=this._onMoveBase.bind(this),this.mouseUpListener=this._onEndBase.bind(this),this.eventSources.forEach(function(a){return a.addEventListener("mousedown",e.mouseDownListener)}),document.addEventListener("mousemove",this.mouseMoveListener),document.addEventListener("mouseup",this.mouseUpListener))};b.Interactor.prototype.stopListening=
function(){var a=this;this.touchStartListener&&this.eventSources.forEach(function(b){return b.removeEventListener("touchstart",a.touchStartListener)});this.touchMoveListener&&this.eventSources.forEach(function(b){return b.removeEventListener("touchmove",a.touchMoveListener)});this.touchEndListener&&this.eventSources.forEach(function(b){return b.removeEventListener("touchend",a.touchEndListener)});this.mouseDownListener&&this.eventSources.forEach(function(b){return b.removeEventListener("mousedown",
a.mouseDownListener)});this.mouseMoveListener&&document.removeEventListener("mousemove",this.mouseMoveListener);this.mouseUpListener&&document.removeEventListener("mouseup",this.mouseUpListener)};b.Interactor.prototype._onStartBase=function(a){this.enabled&&!this.active&&b.Interactor.MouseEventMatches(a,this.eventTypes)&&(this.currentEventSource=a.currentTarget,this._updateStateFromEvent(a),1<=this.currNumTouches?(this.active=!0,d.copy(this.startPoint,this.currPoint),d.copy(this.prevPoint,this.currPoint),
d.set(this.deltaPrev,0,0),d.set(this.deltaStart,0,0),2<=this.currNumTouches&&(this.pinching=!0,b.Interactor._copyPinchInfo(this.startPinch,this.currPinch),b.Interactor._copyPinchInfo(this.prevPinch,this.currPinch),b.Interactor._zeroPinchInfo(this.deltaPrevPinch),b.Interactor._zeroPinchInfo(this.deltaStartPinch)),this._onStart?this._onStart(a):this.trigger("start",{origEvent:a})):this.currentEventSource=null,a.preventDefault())};b.Interactor.prototype._onMoveBase=function(a){this.enabled&&this.active&&
this.currentEventSource&&(this._updateStateFromEvent(a),this._onMove?this._onMove(a):this.trigger("move",{origEvent:a}),d.copy(this.prevPoint,this.currPoint),2<=this.currNumTouches&&b.Interactor._copyPinchInfo(this.prevPinch,this.currPinch),a.preventDefault())};b.Interactor.prototype._onEndBase=function(a){this.enabled&&this.active&&this.currentEventSource&&(this._updateStateFromEvent(a),this._onEnd?this._onEnd(a):this.trigger("end",{origEvent:a}),this.pinching=this.active=!1,this.currentEventSource=
null,a.preventDefault())};b.Interactor.MouseEventMatches=function(a,b){if(!b)return!1;Array.isArray(b)||(b=[b]);b=$jscomp.makeIterator(b);for(var c=b.next();!c.done;c=b.next())if(c=c.value,(!a.button&&0!==a.button||(Array.isArray(c.btns)?c.btns:[c.btns]).some(function(b){return b===a.button}))&&!(c.shift!==h&&c.shift!==a.shiftKey||c.ctrl!==h&&c.ctrl!==(a.ctrlKey||a.metaKey)||c.alt!==h&&c.alt!==a.altKey))return!0;return!1};b.Interactor.prototype._updateStateFromEvent=function(a){a=b.Interactor._getEventCoordinates(a);
if(null===a[0]||null===a[1])this.currNumTouches=0;else{this.currNumTouches=1;var f=this.currentEventSource.getBoundingClientRect();d.set(this.currPoint,a[0]-f.left,a[1]-f.top);d.subtract(this.deltaPrev,this.currPoint,this.prevPoint);d.subtract(this.deltaStart,this.currPoint,this.startPoint);if(null!==a[2]&&null!==a[3]){this.currNumTouches=2;f=a[0];var c=a[1],e=a[2];a=a[3];d.set(this.currPinch.ctr,(f+e)/2,(c+a)/2);this.currPinch.sep=Math.sqrt((e-f)*(e-f)+(a-c)*(a-c));this.currPinch.ang=Math.atan2(c-
a,e-f);d.subtract(this.deltaPrevPinch.ctr,this.currPinch.ctr,this.prevPinch.ctr);d.subtract(this.deltaStartPinch.ctr,this.currPinch.ctr,this.startPinch.ctr);this.deltaPrevPinch.sep=this.currPinch.sep-this.prevPinch.sep;this.deltaStartPinch.sep=this.currPinch.sep-this.startPinch.sep;this.deltaPrevPinch.ang=this.currPinch.ang-this.prevPinch.ang;this.deltaStartPinch.ang=this.currPinch.ang-this.startPinch.ang}}};b.Interactor._getEventCoordinates=function(a){var b=a.clientX,c=a.clientY,e=null,d=null;("undefined"==
typeof b||"undefined"==typeof c||null===b||null===c)&&(a=a.targetTouches&&a.targetTouches.length?a:a.originalEvent)&&a.targetTouches&&a.targetTouches.length&&(b=a.targetTouches[0].clientX,c=a.targetTouches[0].clientY,1<a.targetTouches.length&&(e=a.targetTouches[1].clientX,d=a.targetTouches[1].clientY));if("undefined"==typeof b||"undefined"==typeof c)b=c=e=d=null;return[b,c,e,d]};b.Interactor._copyPinchInfo=function(a,b){a.sep=b.sep;a.ang=b.ang;d.copy(a.ctr,b.ctr)};b.Interactor._zeroPinchInfo=function(a){a.sep=
0;a.ang=0;d.set(a.ctr,0,0)};b.Interactor.prototype.addEventListener=function(a,f){b.Notifier.prototype.addEventListener.call(this,a,f)};b.Interactor.prototype.removeEventListener=function(a,f){b.Notifier.prototype.removeEventListener.call(this,a,f)};b.Interactor.prototype.trigger=function(a,f){b.Notifier.prototype.trigger.call(this,a,f)}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=glMatrix.vec3;b.Mesh=function(a,f,c,e,d){this.vertices=a||[];this.material=c||new b.Material;this.normals=f||b.Mesh.calcNormals(a,this.material.flatShade);this.name=e||"";this.layer=d||0;this.visible=!0;this.updateVertexBuffers()};b.Mesh.prototype.updateVertexBuffers=function(){var a,b=this.vertices.length;this.vBuffer=new Float32Array(3*b);for(a=0;a<b;a++){var c=3*a;var e=this.vertices[a];this.vBuffer[c]=e[0];this.vBuffer[c+1]=e[1];this.vBuffer[c+2]=e[2]}this.nBuffer=new Float32Array(3*
b);for(a=0;a<b;a++)c=3*a,e=this.normals[a],this.nBuffer[c]=e[0],this.nBuffer[c+1]=e[1],this.nBuffer[c+2]=e[2];this.updateAttributeBuffers()};b.Mesh.prototype.updateAttributeBuffers=function(){var a,b=this.vertices.length;this.cBuffer=new Float32Array(4*b);var c=this.material.color.slice();for(a=0;4>a;a++)c[a]/=255;for(a=0;a<b;a++){var e=4*a;this.cBuffer[e]=c[0];this.cBuffer[e+1]=c[1];this.cBuffer[e+2]=c[2];this.cBuffer[e+3]=c[3]}this.mBuffer=new Float32Array(4*b);c=Math.max(0,Math.min(1,this.material.ambient));
var d=Math.max(0,Math.min(1,this.material.diffuse)),g=Math.max(0,Math.min(1,this.material.specStrength)),l=Math.max(0,Math.min(1,this.material.specPower/255));for(a=0;a<b;a++)e=4*a,this.mBuffer[e]=c,this.mBuffer[e+1]=d,this.mBuffer[e+2]=g,this.mBuffer[e+3]=l};b.Mesh.calcNormals=function(a,f,c){var e=a?a.length:0,k=e/3,g=[],l=d.create(),m=d.create(),n;for(n=0;n<k;n++){var p=3*n;d.subtract(l,a[p+1],a[p]);d.subtract(m,a[p+2],a[p]);p=d.create();d.cross(p,l,m);d.normalize(p,p);.99>d.squaredLength(p)&&
b.Logger.Report("Invalid triangle supplied to Mesh.calcNormals.",b.Logger.Severity.Warning);g.push(p,p,p)}if(!f){f={};for(n=0;n<e;n++){var r=a[n];r=[r[0].toFixed(5),r[1].toFixed(5),r[2].toFixed(5)];f[r]===h?f[r]=[n]:f[r].push(n)}a=c||0===c?c:.5;for(r in f)for(c=f[r].slice();1<c.length;){e=[c[0]];c.splice(0,1);k=g[e[0]];for(n=0;n<c.length;n++)d.dot(k,g[c[n]])>=a&&(e.push(c[n]),c.splice(n,1),n--);if(1<e.length){k=[];for(n=0;n<e.length;n++){m=g[e[n]];p=!1;for(l=0;l<k.length;l++)if(.9999<d.dot(m,k[l])){p=
!0;break}p||k.push(m)}l=d.create();for(n=0;n<k.length;n++)d.add(l,l,k[n]);d.normalize(l,l);if(.5<d.squaredLength(l))for(n=0;n<e.length;n++)g[e[n]]=l}}}return g};b.Mesh.prototype.setMaterial=function(a){a||(a=[255,0,0]);a instanceof b.Color&&(a=a.toArray());$.isArray(a)&&(a=new b.Material(a,!1,.4,.25,0,0));this.material=a.clone();this.updateAttributeBuffers()};b.Mesh.prototype.numVertices=function(){return this.vertices.length};b.Mesh.Box=function(a,f,c,e,k,g){c||(c=[[1,0,0],[0,1,0],[0,0,1]]);for(var l=
[d.create(),d.create(),d.create()],m=0;3>m;m++)d.scale(l[m],c[m],.5*f[m]/d.length(c[m]));f=d.create();c=d.create();m=d.create();var n=d.create(),p=d.create(),h=d.create(),q=d.create(),u=d.create();d.scaleAndAdd(f,a,l[0],-1);d.scaleAndAdd(f,f,l[1],1);d.scaleAndAdd(f,f,l[2],-1);d.scaleAndAdd(c,a,l[0],1);d.scaleAndAdd(c,c,l[1],1);d.scaleAndAdd(c,c,l[2],-1);d.scaleAndAdd(m,a,l[0],1);d.scaleAndAdd(m,m,l[1],-1);d.scaleAndAdd(m,m,l[2],-1);d.scaleAndAdd(n,a,l[0],-1);d.scaleAndAdd(n,n,l[1],-1);d.scaleAndAdd(n,
n,l[2],-1);d.scaleAndAdd(p,a,l[0],-1);d.scaleAndAdd(p,p,l[1],1);d.scaleAndAdd(p,p,l[2],1);d.scaleAndAdd(h,a,l[0],1);d.scaleAndAdd(h,h,l[1],1);d.scaleAndAdd(h,h,l[2],1);d.scaleAndAdd(q,a,l[0],1);d.scaleAndAdd(q,q,l[1],-1);d.scaleAndAdd(q,q,l[2],1);d.scaleAndAdd(u,a,l[0],-1);d.scaleAndAdd(u,u,l[1],-1);d.scaleAndAdd(u,u,l[2],1);return new b.Mesh([f,c,m,f,m,n,h,p,u,h,u,q,p,f,u,f,n,u,c,q,m,c,h,q,q,u,n,q,n,m,p,h,f,h,c,f],null,e,k,g)};b.Mesh.Cylinder=function(a,f,c,e,k,g,l,m){g=g||new b.Material;e=d.clone(e);
d.normalize(e,e);var n=.5<Math.abs(e[0])?d.fromValues(-e[2],0,e[0]):.5<Math.abs(e[1])?d.fromValues(-e[1],e[0],0):d.fromValues(0,-e[2],e[1]);d.normalize(n,n);var p=d.create();d.cross(p,e,n);var h=[],q=[],u=[];k=Math.max(3,k||24);var x=2*Math.PI/k,z=d.create(),t=d.create();d.scaleAndAdd(z,a,e,c/2);d.scaleAndAdd(t,a,e,-c/2);c=[];e=[];for(a=0;a<k;a++){var y=a*x,I=Math.cos(y);y=Math.sin(y);var H=d.clone(z);d.scaleAndAdd(H,H,n,f*I);d.scaleAndAdd(H,H,p,f*y);c.push(H);H=d.clone(t);d.scaleAndAdd(H,H,n,f*I);
d.scaleAndAdd(H,H,p,f*y);e.push(H)}for(a=0;a<k;a++)f=(a+1)%k,h.push(c[a],e[f],c[f]),h.push(c[a],e[a],e[f]),u.push(z,c[a],c[f]),u.push(t,e[f],e[a]);k=b.Mesh.calcNormals(h,g.flatShade);z=b.Mesh.calcNormals(q,!0);t=b.Mesh.calcNormals(u,!0);h=h.concat(q).concat(u);q=k.concat(z).concat(t);return new b.Mesh(h,q,g,l,m)};b.Mesh.Cone=function(a,f,c,e,k,g,l,m,n){a=d.clone(a);e=d.clone(e);d.normalize(e,e);l=l||new b.Material;var p=.5<Math.abs(e[0])?d.fromValues(-e[2],0,e[0]):.5<Math.abs(e[1])?d.fromValues(-e[1],
e[0],0):d.fromValues(0,-e[2],e[1]);d.normalize(p,p);var h=d.create();d.cross(h,e,p);var q=[],u=[];k=Math.max(3,k);g=Math.max(1,g);var x=2*Math.PI/k;c/=g;for(var z,t=0;t<g;t++){var y=d.create(),I=d.create();d.scaleAndAdd(y,a,e,-t*c);d.scaleAndAdd(I,a,e,-(t+1)*c);var H=0===t?.01:t*f/g,Q=(t+1)*f/g,K=[],B=[];for(z=0;z<k;z++){var J=z*x,U=Math.cos(J);J=Math.sin(J);var M=d.clone(y);d.scaleAndAdd(M,M,p,H*U);d.scaleAndAdd(M,M,h,H*J);K.push(M);M=d.clone(I);d.scaleAndAdd(M,M,p,Q*U);d.scaleAndAdd(M,M,h,Q*J);
B.push(M)}for(z=0;z<k;z++)y=(z+1)%k,q.push(K[z],B[y],K[y]),q.push(K[z],B[z],B[y]),t==g-1&&u.push(I,B[y],B[z])}a=b.Mesh.calcNormals(q,l.flatShade);f=b.Mesh.calcNormals(u,!0);q=q.concat(u);u=a.concat(f);return new b.Mesh(q,u,l,m,n)};b.Mesh.Sphere=function(a,f,c,e,d,g,l){var k=[],n;c=Math.max(3,c);e=Math.max(3,e);var p=2*Math.PI/c,h=Math.PI/(e-1);for(n=0;n<e;n++){var q=n*h;var u=a[2]+f*Math.cos(q),x=f*Math.sin(q);for(q=0;q<c;q++){var z=q*p;k.push([x*Math.cos(z)+a[0],x*Math.sin(z)+a[1],u])}}f=[];for(n=
0;n<e-1;n++)if(p=n*c,h=(n+1)*c,0===n)for(q=0;q<c;q++)a=(q+1)%c,f.push(k[q+p],k[q+h],k[a+h]);else if(n===e-2)for(q=0;q<c;q++)a=(q+1)%c,f.push(k[q+p],k[q+h],k[a+p]);else for(q=0;q<c;q++)a=(q+1)%c,f.push(k[q+p],k[q+h],k[a+p]),f.push(k[a+p],k[q+h],k[a+h]);return new b.Mesh(f,null,d,g,l)}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=b.Logger.Severity;b.AttributeBuffer=function(a,f,c,e){e=e||{};c=c||3;var k=a.gl;this.context=a;this.attrDim=c;this.drawMode=e.drawMode||k.STATIC_DRAW;this.dataType=e.dataType||k.FLOAT;this.normalizeValues=!!e.normalizeValues;this.bytesPerVertex=c*this.context.sizeOf(this.dataType);this.numBytes=0;this.glBuffer=null;1!==c&&2!==c&&3!==c&&4!==c?b.Logger.Report("AttributeBuffer.ctor: Invalid attribute dimension.",d.Error):(a=this._coerceData(f))?(this.numBytes=a.buffer?a.buffer.byteLength:
a.byteLength,this.glBuffer=k.createBuffer(),k.bindBuffer(k.ARRAY_BUFFER,this.glBuffer),k.bufferData(k.ARRAY_BUFFER,a,this.drawMode),k.bindBuffer(k.ARRAY_BUFFER,null)):b.Logger.Report("AttributeBuffer.ctor: Invalid data array.",d.Error)};b.AttributeBuffer.prototype.destroy=function(){if(this.context){if(this.glBuffer){var a=this.context.gl;a.bindBuffer(a.ARRAY_BUFFER,this.glBuffer);a.bufferData(a.ARRAY_BUFFER,1,a.STATIC_DRAW);a.bindBuffer(a.ARRAY_BUFFER,null);a.deleteBuffer(this.glBuffer);this.glBuffer=
null}this.context=null}};b.AttributeBuffer.prototype._coerceData=function(a){var b=this.context.gl;try{if(this.dataType===b.FLOAT)return a instanceof Float32Array?a:new Float32Array(a);if(this.dataType===b.UNSIGNED_SHORT)return a instanceof Uint16Array?a:new Uint16Array(a);if(this.dataType===b.UNSIGNED_BYTE)return a instanceof Uint8Array?a:new Uint8Array(a);if(this.dataType===b.SHORT)return a instanceof Int16Array?a:new Int16Array(a);if(this.dataType===b.BYTE)return a instanceof Int8Array?a:new Int8Array(a);
if(1<this.context.glVersion&&this.dataType===b.HALF_FLOAT)return a}catch(c){}return null};b.AttributeBuffer.prototype.setData=function(a){if(a=this._coerceData(a)){this.numBytes=a.buffer?a.buffer.byteLength:a.byteLength;var f=this.context.gl;f.bindBuffer(f.ARRAY_BUFFER,this.glBuffer);f.bufferData(f.ARRAY_BUFFER,a,this.drawMode);f.bindBuffer(f.ARRAY_BUFFER,null)}else b.Logger.Report("AttributeBuffer.setData: Invalid data array.",d.Error)};b.AttributeBuffer.prototype.subData=function(a,f){if(a=this._coerceData(a)){var c=
this.context.gl;c.bindBuffer(c.ARRAY_BUFFER,this.glBuffer);c.bufferSubData(c.ARRAY_BUFFER,f||0,a);c.bindBuffer(c.ARRAY_BUFFER,null)}else b.Logger.Report("AttributeBuffer.subData: Invalid data array.",d.Error)}})(window.BigLime=window.BigLime||{});(function(b,h){b.Interp3D={NN:1,BiLinear:2,TriLinear:3};Object.freeze(b.Interp3D);b.RenderType={MIP:1,VR:2,XRAY:3};Object.freeze(b.RenderType)})(window.BigLime=window.BigLime||{});
(function(b,h){b.DebugUtils=function(){function b(a){if(null===m){m={};n={};for(var b in a)"number"==typeof a[b]&&(m[a[b]]=b,n[b]=a[b])}}function a(){if(null===m)throw"WebGLDebugUtils.init(ctx) not called";}function f(b){a();var c=m[b];return c!==h?"gl."+c:"/*UNKNOWN WebGL ENUM*/ 0x"+b.toString(16)}function c(a,b,c,e){a=l[a];if(a!==h&&(a=a[b],a!==h&&a[c])){if("object"===typeof a[c]&&a[c].enumBitwiseOr!==h){b=a[c].enumBitwiseOr;c=0;a=[];for(var d=0;d<b.length;++d){var k=n[b[d]];0!==(e&k)&&(c|=k,a.push(f(k)))}return c===
e?a.join(" | "):f(e)}return f(e)}return null===e?"null":e===h?"undefined":e.toString()}function e(a,b,c){a.__defineGetter__(c,function(){return b[c]});a.__defineSetter__(c,function(a){b[c]=a})}function k(a,d,g,l){function p(a,b){return function(){g&&g(b,arguments);var c=a[b].apply(a,arguments),e=l.getError();0!==e&&(m[e]=!0,d(e,b,arguments));return c}}l=l||a;b(a);d=d||function(a,b,e){for(var d="",k=e.length,g=0;g<k;++g)d+=(0===g?"":", ")+c(b,k,g,e[g]);a="WebGL error "+f(a)+" in "+b+"("+d+")";window.console&&
window.console.error?window.console.error(a):window.console&&window.console.log&&window.console.log(a)};var m={},n={},h;for(h in a)if("function"==typeof a[h])if("getExtension"!=h)n[h]=p(a,h);else{var q=p(a,h);n[h]=function(){var b=q.apply(a,arguments);return b?k(b,d,g,l):null}}else e(n,a,h);n.getError=function(){for(var b in m)if(m.hasOwnProperty(b)&&m[b])return m[b]=!1,b;return a.NO_ERROR};return n}function g(a){var b=!!a.createTransformFeedback;b&&a.bindVertexArray(null);var c=a.getParameter(a.MAX_VERTEX_ATTRIBS),
e=a.createBuffer(),d;a.bindBuffer(a.ARRAY_BUFFER,e);for(d=0;d<c;++d)a.disableVertexAttribArray(d),a.vertexAttribPointer(d,4,a.FLOAT,!1,0,0),a.vertexAttrib1f(d,0),b&&a.vertexAttribDivisor(d,0);a.deleteBuffer(e);c=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);for(d=0;d<c;++d)a.activeTexture(a.TEXTURE0+d),a.bindTexture(a.TEXTURE_CUBE_MAP,null),a.bindTexture(a.TEXTURE_2D,null),b&&(a.bindTexture(a.TEXTURE_2D_ARRAY,null),a.bindTexture(a.TEXTURE_3D,null),a.bindSampler(d,null));a.activeTexture(a.TEXTURE0);a.useProgram(null);
a.bindBuffer(a.ARRAY_BUFFER,null);a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,null);a.bindFramebuffer(a.FRAMEBUFFER,null);a.bindRenderbuffer(a.RENDERBUFFER,null);a.disable(a.BLEND);a.disable(a.CULL_FACE);a.disable(a.DEPTH_TEST);a.disable(a.DITHER);a.disable(a.SCISSOR_TEST);a.blendColor(0,0,0,0);a.blendEquation(a.FUNC_ADD);a.blendFunc(a.ONE,a.ZERO);a.clearColor(0,0,0,0);a.clearDepth(1);a.clearStencil(-1);a.colorMask(!0,!0,!0,!0);a.cullFace(a.BACK);a.depthFunc(a.LESS);a.depthMask(!0);a.depthRange(0,1);a.frontFace(a.CCW);
a.hint(a.GENERATE_MIPMAP_HINT,a.DONT_CARE);a.lineWidth(1);a.pixelStorei(a.PACK_ALIGNMENT,4);a.pixelStorei(a.UNPACK_ALIGNMENT,4);a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,!1);a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1);a.UNPACK_COLORSPACE_CONVERSION_WEBGL&&a.pixelStorei(a.UNPACK_COLORSPACE_CONVERSION_WEBGL,a.BROWSER_DEFAULT_WEBGL);a.polygonOffset(0,0);a.sampleCoverage(1,!1);a.scissor(0,0,a.canvas.width,a.canvas.height);a.stencilFunc(a.ALWAYS,0,4294967295);a.stencilMask(4294967295);a.stencilOp(a.KEEP,
a.KEEP,a.KEEP);a.viewport(0,0,a.canvas.width,a.canvas.height);a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT|a.STENCIL_BUFFER_BIT);if(b){a.drawBuffers([a.BACK]);a.readBuffer(a.BACK);a.bindBuffer(a.COPY_READ_BUFFER,null);a.bindBuffer(a.COPY_WRITE_BUFFER,null);a.bindBuffer(a.PIXEL_PACK_BUFFER,null);a.bindBuffer(a.PIXEL_UNPACK_BUFFER,null);b=a.getParameter(a.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS);for(d=0;d<b;++d)a.bindBufferBase(a.TRANSFORM_FEEDBACK_BUFFER,d,null);b=a.getParameter(a.MAX_UNIFORM_BUFFER_BINDINGS);
for(d=0;d<b;++d)a.bindBufferBase(a.UNIFORM_BUFFER,d,null);a.disable(a.RASTERIZER_DISCARD);a.pixelStorei(a.UNPACK_IMAGE_HEIGHT,0);a.pixelStorei(a.UNPACK_SKIP_IMAGES,0);a.pixelStorei(a.UNPACK_ROW_LENGTH,0);a.pixelStorei(a.UNPACK_SKIP_ROWS,0);a.pixelStorei(a.UNPACK_SKIP_PIXELS,0);a.pixelStorei(a.PACK_ROW_LENGTH,0);a.pixelStorei(a.PACK_SKIP_ROWS,0);a.pixelStorei(a.PACK_SKIP_PIXELS,0);a.hint(a.FRAGMENT_SHADER_DERIVATIVE_HINT,a.DONT_CARE)}for(;a.getError(););}var l={enable:{1:{0:!0}},disable:{1:{0:!0}},
getParameter:{1:{0:!0}},drawArrays:{3:{0:!0}},drawElements:{4:{0:!0,2:!0}},createShader:{1:{0:!0}},getShaderParameter:{2:{1:!0}},getProgramParameter:{2:{1:!0}},getShaderPrecisionFormat:{2:{0:!0,1:!0}},getVertexAttrib:{2:{1:!0}},vertexAttribPointer:{6:{2:!0}},bindTexture:{2:{0:!0}},activeTexture:{1:{0:!0}},getTexParameter:{2:{0:!0,1:!0}},texParameterf:{3:{0:!0,1:!0}},texParameteri:{3:{0:!0,1:!0,2:!0}},copyTexImage2D:{8:{0:!0,2:!0}},copyTexSubImage2D:{8:{0:!0}},generateMipmap:{1:{0:!0}},bindBuffer:{2:{0:!0}},
getBufferParameter:{2:{0:!0,1:!0}},pixelStorei:{2:{0:!0,1:!0}},bindRenderbuffer:{2:{0:!0}},bindFramebuffer:{2:{0:!0}},checkFramebufferStatus:{1:{0:!0}},framebufferRenderbuffer:{4:{0:!0,1:!0,2:!0}},framebufferTexture2D:{5:{0:!0,1:!0,2:!0}},getFramebufferAttachmentParameter:{3:{0:!0,1:!0,2:!0}},getRenderbufferParameter:{2:{0:!0,1:!0}},renderbufferStorage:{4:{0:!0,1:!0}},clear:{1:{0:{enumBitwiseOr:["COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT"]}}},depthFunc:{1:{0:!0}},blendFunc:{2:{0:!0,
1:!0}},blendFuncSeparate:{4:{0:!0,1:!0,2:!0,3:!0}},blendEquation:{1:{0:!0}},blendEquationSeparate:{2:{0:!0,1:!0}},stencilFunc:{3:{0:!0}},stencilFuncSeparate:{4:{0:!0,1:!0}},stencilMaskSeparate:{2:{0:!0}},stencilOp:{3:{0:!0,1:!0,2:!0}},stencilOpSeparate:{4:{0:!0,1:!0,2:!0,3:!0}},cullFace:{1:{0:!0}},frontFace:{1:{0:!0}},drawArraysInstancedANGLE:{4:{0:!0}},drawElementsInstancedANGLE:{5:{0:!0,2:!0}},blendEquationEXT:{1:{0:!0}},bufferData:{3:{0:!0,2:!0},4:{0:!0,2:!0},5:{0:!0,2:!0}},bufferSubData:{3:{0:!0},
4:{0:!0},5:{0:!0}},copyBufferSubData:{5:{0:!0,1:!0}},getBufferSubData:{3:{0:!0},4:{0:!0},5:{0:!0}},blitFramebuffer:{10:{8:{enumBitwiseOr:["COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT"]},9:!0}},framebufferTextureLayer:{5:{0:!0,1:!0}},invalidateFramebuffer:{2:{0:!0}},invalidateSubFramebuffer:{6:{0:!0}},readBuffer:{1:{0:!0}},getInternalformatParameter:{3:{0:!0,1:!0,2:!0}},renderbufferStorageMultisample:{5:{0:!0,2:!0}},texStorage2D:{5:{0:!0,2:!0}},texStorage3D:{6:{0:!0,2:!0}},texImage2D:{9:{0:!0,
2:!0,6:!0,7:!0},6:{0:!0,2:!0,3:!0,4:!0},10:{0:!0,2:!0,6:!0,7:!0}},texImage3D:{10:{0:!0,2:!0,7:!0,8:!0},11:{0:!0,2:!0,7:!0,8:!0}},texSubImage2D:{9:{0:!0,6:!0,7:!0},7:{0:!0,4:!0,5:!0},10:{0:!0,6:!0,7:!0}},texSubImage3D:{11:{0:!0,8:!0,9:!0},12:{0:!0,8:!0,9:!0}},copyTexSubImage3D:{9:{0:!0}},compressedTexImage2D:{7:{0:!0,2:!0},8:{0:!0,2:!0},9:{0:!0,2:!0}},compressedTexImage3D:{8:{0:!0,2:!0},9:{0:!0,2:!0},10:{0:!0,2:!0}},compressedTexSubImage2D:{8:{0:!0,6:!0},9:{0:!0,6:!0},10:{0:!0,6:!0}},compressedTexSubImage3D:{10:{0:!0,
8:!0},11:{0:!0,8:!0},12:{0:!0,8:!0}},vertexAttribIPointer:{5:{2:!0}},drawArraysInstanced:{4:{0:!0}},drawElementsInstanced:{5:{0:!0,2:!0}},drawRangeElements:{6:{0:!0,4:!0}},readPixels:{7:{4:!0,5:!0},8:{4:!0,5:!0}},clearBufferfv:{3:{0:!0},4:{0:!0}},clearBufferiv:{3:{0:!0},4:{0:!0}},clearBufferuiv:{3:{0:!0},4:{0:!0}},clearBufferfi:{4:{0:!0}},beginQuery:{2:{0:!0}},endQuery:{1:{0:!0}},getQuery:{2:{0:!0,1:!0}},getQueryParameter:{2:{1:!0}},samplerParameteri:{3:{1:!0,2:!0}},samplerParameterf:{3:{1:!0}},getSamplerParameter:{2:{1:!0}},
fenceSync:{2:{0:!0,1:{enumBitwiseOr:[]}}},clientWaitSync:{3:{1:{enumBitwiseOr:["SYNC_FLUSH_COMMANDS_BIT"]}}},waitSync:{3:{1:{enumBitwiseOr:[]}}},getSyncParameter:{2:{1:!0}},bindTransformFeedback:{2:{0:!0}},beginTransformFeedback:{1:{0:!0}},transformFeedbackVaryings:{3:{2:!0}},bindBufferBase:{3:{0:!0}},bindBufferRange:{5:{0:!0}},getIndexedParameter:{2:{0:!0}},getActiveUniforms:{3:{2:!0}},getActiveUniformBlockParameter:{3:{2:!0}}},m=null,n=null;return{copyright:'/*\n** Copyright (c) 2012 The Khronos Group Inc.\n**\n** Permission is hereby granted, free of charge, to any person obtaining a\n** copy of this software and/or associated documentation files (the\n** "Materials"), to deal in the Materials without restriction, including\n** without limitation the rights to use, copy, modify, merge, publish,\n** distribute, sublicense, and/or sell copies of the Materials, and to\n** permit persons to whom the Materials are furnished to do so, subject to\n** the following conditions:\n**\n** The above copyright notice and this permission notice shall be included\n** in all copies or substantial portions of the Materials.\n**\n** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.\n*/',
init:b,mightBeEnum:function(b){a();return m[b]!==h},glEnumToString:f,glFunctionArgToString:c,glFunctionArgsToString:function(a,b){for(var e="",d=b.length,f=0;f<d;++f)e+=(0===f?"":", ")+c(a,d,f,b[f]);return e},makeDebugContext:k,makeLostContextSimulatingCanvas:function(a){function b(a){return"function"==typeof a?a:function(b){a.handleEvent(b)}}function c(){for(var a=Object.keys(O),b=0;b<a.length;++b)delete O[a[b]]}function d(){++M;B||U==M&&a.loseContext()}function f(a,b){var c=a[b];return function(){d();
if(!B)return c.apply(a,arguments)}}function k(a){return{statusMessage:a,preventDefault:function(){ha=!0}}}function l(a){for(var b in a)"function"==typeof a[b]?p[b]=f(a,b):e(p,a,b);var c;p.getError=function(){d();if(!B)for(;c=m.getError();)O[c]=!0;for(c in O)if(O[c])return delete O[c],c;return p.NO_ERROR};var k="createBuffer createFramebuffer createProgram createRenderbuffer createShader createTexture".split(" ");X&&k.push("createQuery","createSampler","fenceSync","createTransformFeedback","createVertexArray");
for(var g=0;g<k.length;++g)b=k[g],p[b]=function(b){return function(){d();if(B)return null;var c=b.apply(a,arguments);c.__webglDebugContextLostId__=K;J.push(c);return c}}(a[b]);k="getActiveAttrib getActiveUniform getBufferParameter getContextAttributes getAttachedShaders getFramebufferAttachmentParameter getParameter getProgramParameter getProgramInfoLog getRenderbufferParameter getShaderParameter getShaderInfoLog getShaderSource getTexParameter getUniform getUniformLocation getVertexAttrib".split(" ");
X&&k.push("getInternalformatParameter","getQuery","getQueryParameter","getSamplerParameter","getSyncParameter","getTransformFeedbackVarying","getIndexedParameter","getUniformIndices","getActiveUniforms","getActiveUniformBlockParameter","getActiveUniformBlockName");for(g=0;g<k.length;++g)b=k[g],p[b]=function(b){return function(){d();return B?null:b.apply(a,arguments)}}(p[b]);k="isBuffer isEnabled isFramebuffer isProgram isRenderbuffer isShader isTexture".split(" ");X&&k.push("isQuery","isSampler",
"isSync","isTransformFeedback","isVertexArray");for(g=0;g<k.length;++g)b=k[g],p[b]=function(b){return function(){d();return B?!1:b.apply(a,arguments)}}(p[b]);p.checkFramebufferStatus=function(b){return function(){d();return B?p.FRAMEBUFFER_UNSUPPORTED:b.apply(a,arguments)}}(p.checkFramebufferStatus);p.getAttribLocation=function(b){return function(){d();return B?-1:b.apply(a,arguments)}}(p.getAttribLocation);p.getVertexAttribOffset=function(b){return function(){d();return B?0:b.apply(a,arguments)}}(p.getVertexAttribOffset);
p.isContextLost=function(){return B};X&&(p.getFragDataLocation=function(b){return function(){d();return B?-1:b.apply(a,arguments)}}(p.getFragDataLocation),p.clientWaitSync=function(b){return function(){d();return B?p.WAIT_FAILED:b.apply(a,arguments)}}(p.clientWaitSync),p.getUniformBlockIndex=function(b){return function(){d();return B?p.INVALID_INDEX:b.apply(a,arguments)}}(p.getUniformBlockIndex));return p}var m,n=[],h=[],p={},K=1,B=!1,J=[],U=0,M=0,ha=!1,ea=0,X,O={};a.getContext=function(b){return function(){var c=
b.apply(a,arguments);if(c instanceof WebGLRenderingContext||window.WebGL2RenderingContext&&c instanceof WebGL2RenderingContext){if(c!=m){if(m)throw"got different context";X=window.WebGL2RenderingContext&&c instanceof WebGL2RenderingContext;m=c;p=l(m)}return p}return c}}(a.getContext);(function(a){var c=a.addEventListener;a.addEventListener=function(e,d,f){switch(e){case "webglcontextlost":n.push(b(d));break;case "webglcontextrestored":h.push(b(d));break;default:c.apply(a,arguments)}}})(a);a.loseContext=
function(){if(!B){B=!0;U=0;for(++K;m.getError(););c();O[m.CONTEXT_LOST_WEBGL]=!0;var b=k("context lost"),d=n.slice();setTimeout(function(){for(var c=0;c<d.length;++c)d[c](b);0<=ea&&setTimeout(function(){a.restoreContext()},ea)},0)}};a.restoreContext=function(){B&&h.length&&setTimeout(function(){if(!ha)throw"can not restore. webglcontestlost listener did not call event.preventDefault";for(var a=0;a<J.length;++a){var b=J[a];b instanceof WebGLBuffer?m.deleteBuffer(b):b instanceof WebGLFramebuffer?m.deleteFramebuffer(b):
b instanceof WebGLProgram?m.deleteProgram(b):b instanceof WebGLRenderbuffer?m.deleteRenderbuffer(b):b instanceof WebGLShader?m.deleteShader(b):b instanceof WebGLTexture?m.deleteTexture(b):X&&(b instanceof WebGLQuery?m.deleteQuery(b):b instanceof WebGLSampler?m.deleteSampler(b):b instanceof WebGLSync?m.deleteSync(b):b instanceof WebGLTransformFeedback?m.deleteTransformFeedback(b):b instanceof WebGLVertexArrayObject&&m.deleteVertexArray(b))}g(m);B=!1;M=0;ha=!1;a=h.slice();b=k("context restored");for(var c=
0;c<a.length;++c)a[c](b)},0)};a.loseContextInNCalls=function(a){if(B)throw"You can not ask a lost contet to be lost";U=M+a};a.getNumCalls=function(){return M};a.setRestoreTimeout=function(a){ea=a};return a},resetToInitialState:g}}()})(window.BigLime=window.BigLime||{});
(function(b,h){b.DicomLoader3D=function(){b.Loader3D.call(this);this.daikonImgs=[];this.fileList=[]};b.DicomLoader3D.prototype=Object.create(b.Loader3D.prototype);b.DicomLoader3D.prototype.constructor=b.DicomLoader3D;b.DicomLoader3D.prototype.loadImagesIntoVolume=function(b,a,f,c){this.fileList=[];Array.prototype.push.apply(this.fileList,b);this.vol=a;this.warnings=this.errors=null;this.done=!1;this.loadCompleteCb=f;this.loadProgressCb=c;this.fileList&&this.fileList.length?this.fileList.some(function(a){return!(a instanceof
FileSystemFileHandle)&&!(a instanceof File)})?(this.done=!0,this.errors="DicomLoader3D: Invalid item in file list.",this.loadCompleteCb&&this.loadCompleteCb(this)):(this.loadProgressCb&&this.loadProgressCb(0,this.fileList.length),this._readImageFile(0)):(this.done=!0,this.warnings="DicomLoader3D: No files were loaded, because the supplied file list was empty.",this.loadCompleteCb&&this.loadCompleteCb(this))};b.DicomLoader3D.prototype._readImageFile=function(b){var a=new FileReader;a.onload=function(){this._onImageFileRead(a,
null)}.bind(this);a.onerror=function(){this._onReadError(a,null)}.bind(this);a.imgIndex=b;b=this.fileList[b];b instanceof FileSystemFileHandle?b.getFile().then(function(b){a.readAsArrayBuffer(b)}).catch(function(b){this._onReadError(a)}.bind(this)):a.readAsArrayBuffer(b)};b.DicomLoader3D.prototype._onReadError=function(b){this.cancelled||this.done||(this.done=!0,this.errors="DicomLoader3D: Error reading file "+this.fileList[b.imgIndex].name,this.loadCompleteCb&&this.loadCompleteCb(this))};b.DicomLoader3D.prototype._onImageFileRead=
function(b){if(!this.done&&!this.cancelled){var a=b.result;b=b.imgIndex;try{var d=new DataView(a);if(!daikon.Parser.isMagicCookieFound(d)){this.done=!0;this.errors="DicomLoader3D: Invalid dicom file.";this.loadCompleteCb&&this.loadCompleteCb(this);return}var c=daikon.Series.parseImage(d);if(!c){this.done=!0;this.errors=daikon.Series.parserError;this.loadCompleteCb&&this.loadCompleteCb(this);return}this.daikonImgs.push(c)}catch(e){this.done=!0;this.errors="DicomLoader3D: Error parsing dicom file "+
this.fileList[b].name+"\n"+e.message;this.loadCompleteCb&&this.loadCompleteCb(this);return}this.loadProgressCb&&this.loadProgressCb(b+1,this.fileList.length);b+1<this.fileList.length?this._readImageFile(b+1):this._onAllImagesRead()}};b.DicomLoader3D.prototype._onAllImagesRead=function(){var d,a=this.daikonImgs[0],f=a.getSeriesInstanceUID(),c=[];for(d=0;d<this.daikonImgs.length;d++){var e=this.daikonImgs[d];e.getSeriesInstanceUID()==f&&b.DicomLoader3D._sameGeometry(e,a)&&c.push(e)}c.length!==this.daikonImgs.length&&
(this.warnings+="Multiple series found. (Loaded the first one.)\n");this.daikonImgs=c;f=this.daikonImgs.length;d=a.getBitsAllocated();c=a.getCols();e=a.getRows();if(d=this.vol.loadBegin([c,e,f],d,"little"))this.done=!0,this.errors=d;else{this.vol.setAttr("modality",a.getModality());this.vol.setAttr("rescaleSlope",a.getDataScaleSlope()||1);this.vol.setAttr("rescaleIntercept",a.getDataScaleIntercept()||0);this.vol.setAttr("dataOffset",0);(d=a.getImageDirections())&&Array.isArray(d)&&6==d.length&&(this.vol.setAttr("rowDir",
[d[0],d[1],d[2]]),this.vol.setAttr("colDir",[d[3],d[4],d[5]]));this.vol.calcNearLphAxes();d=this._sortImagesByZ(this.daikonImgs);this.vol.setAttr("sliceGap",d.gap);d.uniform||(this.warnings+="Non-uniform slice spacing detected.\n");d.warnings&&(this.warnings+=d.warnings);a=8==this.vol.bpp?4:2;c=Array(a);for(e=0;e<f;){var k={startIndex:e,endIndex:Math.min(e+a,f),imgBuffers:c};for(d=0;d<k.endIndex-k.startIndex;d++){var g=b.DicomLoader3D._getPixelValueArray(this.daikonImgs[e++]);if(!g.array){this.done=
!0;this.errors="DicomLoader3D: Unsupported pixel type.";this.loadCompleteCb&&this.loadCompleteCb(this);return}k.imgBuffers[d]=g.array.buffer;1===e&&this.vol.setAttr("dataOffset",g.offset)}if(d=this._copyImagesToTexture(k)){this.done=!0;this.errors=d;this.loadCompleteCb&&this.loadCompleteCb(this);return}}this.vol.loadEnd();this.done=!0}this.loadCompleteCb&&this.loadCompleteCb(this)};b.DicomLoader3D._getPixelValueArray=function(b){var a=b.getDataType(),d=b.getBitsAllocated()/8,c=b.getRawData(),e=new DataView(c);
c=c.byteLength/d;var k=b.littleEndian;b=daikon.Utils.createBitMask(b.getBitsAllocated()/8,b.getBitsStored(),b.getDataType()===daikon.Image.BYTE_TYPE_INTEGER_UNSIGNED);var g,l=0;if(a===daikon.Image.BYTE_TYPE_INTEGER_UNSIGNED&&2===d)for(a=new Uint16Array(c),g=0;g<c;g++)d=e.getUint16(2*g,k),a[g]=d&b;else if(a===daikon.Image.BYTE_TYPE_INTEGER_UNSIGNED&&1===d)for(a=new Uint8Array(c),g=0;g<c;g++)d=e.getUint8(g),a[g]=d&b;else if(a===daikon.Image.BYTE_TYPE_RGB&&1===d)for(a=new Uint8Array(c/3),g=0;g<c;g+=
3)d=(e.getUint8(g)+e.getUint8(g+1)+e.getUint8(g+2))/3,a[g/3]=d&b;else if(a===daikon.Image.BYTE_TYPE_INTEGER&&2===d)for(l=32768,a=new Uint16Array(c),g=0;g<c;g++)d=e.getInt16(2*g,k),a[g]=(d&b)+l;else if(a===daikon.Image.BYTE_TYPE_INTEGER&&1===d)for(l=128,a=new Uint8Array(c),g=0;g<c;g++)d=e.getInt8(g),a[g]=(d&b)+l;else a=null;return{array:a,offset:-l}};b.DicomLoader3D.prototype._sortImagesByZ=function(b){var a=glMatrix.vec3,d,c=b[0],e=c.getImageDirections();if(!e||!Array.isArray(e)||6!==e.length)return{gap:1,
uniform:!0};var k=[e[0],e[1],e[2]];var g=[e[3],e[4],e[5]];e=a.create();a.cross(e,k,g);for(k=0;k<b.length;k++){g=b[k];var l=g.getImagePosition();l=[l[0],l[1],l[2]];g.zPos=a.dot(l,e)}b.sort(function(a,b){return a.zPos>b.zPos?-1:a.zPos<b.zPos?1:0});if(2>b.length)return{gap:1,uniform:!0};a=c.getPixelSpacing()[0];c=0;for(k=1;k<b.length&&!(c=Math.abs(b[k].zPos-b[k-1].zPos)/a,0<c);k++);1!==k&&(d+="Duplicate image positions found.\n");e=!0;for(k=2;k<b.length;k++)if(.01<Math.abs(Math.abs((b[k].zPos-b[k-1].zPos)/
a)-c)){e=!1;break}return{gap:c,uniform:e,warnings:d}};b.DicomLoader3D._sameGeometry=function(b,a){var d=b.getImageDirections(),c=a.getImageDirections();if(!(d&&c&&Array.isArray(d)&&Array.isArray(c))||6!==d.length||6!==c.length)return!1;for(var e=0;6>e;e++)if(.01<Math.abs(d[e]-c[e]))return!1;b=b.getPixelSpacing()[0];a=a.getPixelSpacing()[0];return.01<Math.abs(b-a)?!1:!0}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=b.Logger.Severity;b.FrameBuffer=function(a,f,c,e,k,g,l){this.context=a;this.txIndex=f;this.width=Math.round(c);this.height=Math.round(e);if(0===this.width||0===this.height)b.Logger.Report("FrameBuffer.ctor: FrameBuffer size cannot be zero; setting it to 1.",d.Warn),this.width=this.height=1;this.depthBuffer=this.glFrameBuffer=this.texture=null;c=this.context.gl;this.texture=new b.Texture2D(a,f,this.width,this.height,k,g);this.glFrameBuffer=c.createFramebuffer();c.bindFramebuffer(c.FRAMEBUFFER,
this.glFrameBuffer);c.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_2D,this.texture.glTexture,0);l&&(this.depthBuffer=c.createRenderbuffer(),c.bindRenderbuffer(c.RENDERBUFFER,this.depthBuffer),c.renderbufferStorage(c.RENDERBUFFER,c.DEPTH_COMPONENT16,this.width,this.height),c.framebufferRenderbuffer(c.FRAMEBUFFER,c.DEPTH_ATTACHMENT,c.RENDERBUFFER,this.depthBuffer),c.bindRenderbuffer(c.RENDERBUFFER,null));c.bindFramebuffer(c.FRAMEBUFFER,null)};b.FrameBuffer.prototype.destroy=function(){if(this.context){this.texture.destroy();
this.texture=null;var a=this.context.gl;this.depthBuffer&&(a.deleteRenderbuffer(this.depthBuffer),this.depthBuffer=null);a.deleteFramebuffer(this.glFrameBuffer);this.context=this.glFrameBuffer=null}};b.FrameBuffer.prototype.resize=function(a,f){a=Math.round(a);f=Math.round(f);if(0===a||0===f)b.Logger.Report("FrameBuffer.resize: FrameBuffer size cannot be zero; setting it to 1.",d.Warn),a=f=1;if(a!=this.width||f!=this.height){var c=this.context.gl;this.width=a;this.height=f;this.texture.resize(a,f);
this.depthBuffer&&(c.bindRenderbuffer(c.RENDERBUFFER,this.depthBuffer),c.renderbufferStorage(c.RENDERBUFFER,c.DEPTH_COMPONENT16,a,f),c.bindRenderbuffer(c.RENDERBUFFER,null))}};b.FrameBuffer.prototype.getSize=function(){return[this.width,this.height]}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=b.Logger.Severity;b.GLContext=function(a,f){this.gl=null;this.glVersion=-1;this.canvas=null;this.uniformSetters={};this.state={currentProgram:null,boundIndexBuffer:null,boundTextures:null,activeTexture:-1};if(window.WebGLRenderingContext){var c=f&&f.glVersion?Number(f.glVersion):null;if(0===c||c&&1!==c&&2!==c)b.Logger.Report("GLContext.ctor: Unsupported WebGL version: "+f.glVersion+".",d.Error);else{if(!c||2===c)try{if(this.gl=a.getContext("webgl2"))this.glVersion=2}catch(k){}if(!(this.gl||
c&&1!=c)){c=["webgl","experimental-webgl","webkit-3d","moz-webgl"];for(var e=0;e<c.length&&!this.gl;e++)try{if(this.gl=a.getContext(c[e]))this.glVersion=1}catch(k){}}if(this.gl)for(;this.gl.getError()!=this.gl.NO_ERROR;);if(this.gl){this.canvas=this.gl.canvas;if(a=f&&(f.logErrors||f.logCalls))this.gl=b.DebugUtils.makeDebugContext(this.gl,f.logErrors?b.GLContext._logWebGLError:function(){},f.logCalls?b.GLContext._logWebGLCall:function(){}),b.Logger.ConsoleThresh=d.Debug;this._initializeConstants();
this.uniformSetters=this._tabulateUniformSetters();this.state.boundTextures=Array(this.GlMaxTextures);f=this.gl;f.enable(f.CULL_FACE);f.cullFace(f.BACK);f.pixelStorei(f.UNPACK_ALIGNMENT,1);f.pixelStorei(f.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1);this.contextLostListener=function(a){alert("WebGL context lost. \nPlease reload the page or restart the browser and try again with a smaller data set.")};this.canvas.addEventListener("webglcontextlost",this.contextLostListener);b.Logger.Report("Created WebGL"+this.glVersion.toString()+
(a?" debug":"")+" context.",d.Debug)}else b.Logger.Report("GLContext.ctor: Unable to get WebGL context from canvas.",d.Error)}}else b.Logger.Report("GLContext.ctor: The browser doesn't support WebGL.",d.Error)};b.GLContext.prototype.destroy=function(){this.gl&&(this.canvas.removeEventListener("webglcontextlost",this.contextLostListener),this.gl=null,this.glVersion=-1,this.uniformSetters=null)};b.GLContext._isWebGL2Supported=h;b.GLContext.isWebGL2Supported=function(){if(b.GLContext._isWebGL2Supported===
h){var a=null;try{a=document.createElement("canvas").getContext("webgl2")}catch(f){}b.GLContext._isWebGL2Supported=!!a}return b.GLContext._isWebGL2Supported};b.GLContext.prototype.createProgram=function(a,d,c){return new b.ShaderProgram(this,c?c.name:"",a,d,c?c.vSubs:null,c?c.fSubs:null,c&&"undefined"!==typeof c.compile?!!c.compile:!0)};b.GLContext.prototype.createAttrBuffer=function(a,d,c){return new b.AttributeBuffer(this,a,d,c)};b.GLContext.prototype.createIndexBuffer=function(a,d,c){return new b.IndexBuffer(this,
a,d,c)};b.GLContext.prototype.bindIndexBuffer=function(a){a||null===this.state.boundIndexBuffer?a&&this.state.boundIndexBuffer!=a.glBuffer&&(this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,a.glBuffer),this.state.boundIndexBuffer=a.glBuffer):(this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,null),this.state.boundIndexBuffer=null)};b.GLContext.prototype.unbindIndexBuffer=function(a){this.state.boundIndexBuffer==a.glBuffer&&(this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,null),this.state.boundIndexBuffer=
null)};b.GLContext.prototype.bindTexture=function(a){var b=this.gl;this.state.activeTexture!=a.txIndex&&(b.activeTexture(b.TEXTURE0+a.txIndex),this.state.activeTexture=a.txIndex);this.state.boundTextures[a.txIndex]!=a.glTexture&&(b.bindTexture(a.is3D?b.TEXTURE_3D:b.TEXTURE_2D,a.glTexture),this.state.boundTextures[a.txIndex]=a.glTexture)};b.GLContext.prototype.unbindTexture=function(a){var b=this.gl;this.state.boundTextures[a.txIndex]==a.glTexture&&(b.activeTexture(b.TEXTURE0+a.txIndex),b.bindTexture(a.is3D?
b.TEXTURE_3D:b.TEXTURE_2D,null),this.state.boundTextures[a.txIndex]=null,this.state.activeTexture=a.txIndex)};b.GLContext.prototype.setCurrentProgram=function(a){a?a.context!==this?b.Logger.Report("GLContext.setCurrentProgram: Invalid program.",d.Error):this.state.currentProgram!=a&&(this.gl.useProgram(a.glProgram),this.state.currentProgram=a):(this.gl.useProgram(null),this.state.currentProgram=null)};b.GLContext.prototype.isCurrentProgram=function(a){return this.state.currentProgram==a};b.GLContext.prototype.clearCanvas=
function(a){a=b.Color.ScaleTo1(a||b.Color.Black());this.gl.clearColor(a[0],a[1],a[2],a[3]);this.gl.clear(this.gl.COLOR_BUFFER_BIT)};b.GLContext._logWebGLError=function(a,f,c){for(var e="",k=c.length,g=0;g<k;++g)e+=(0===g?"":", ")+b.DebugUtils.glFunctionArgToString(f,k,g,c[g]);a="WebGL error: "+b.DebugUtils.glEnumToString(a)+" in "+f+"("+e+")";b.Logger.Report(a,d.Error)};b.GLContext._logWebGLCall=function(a,f){for(var c="",e=f.length,k=0;k<e;++k)c+=(0===k?"":", ")+b.DebugUtils.glFunctionArgToString(a,
e,k,f[k]);b.Logger.Report("3DLib WebGL trace: "+a+"("+c+")",d.Debug)};b.GLContext.prototype._tabulateUniformSetters=function(){var a=this.gl,b={},c=function(a){return Array.isArray(a)||ArrayBuffer.isView(a)&&!(a instanceof DataView)};b[a.FLOAT_VEC2]=function(b,c){return a.uniform2fv(b,c)};b[a.FLOAT_VEC3]=function(b,c){return a.uniform3fv(b,c)};b[a.FLOAT_VEC4]=function(b,c){return a.uniform4fv(b,c)};b[a.FLOAT_MAT2]=function(b,c){return a.uniformMatrix2fv(b,!1,c)};b[a.FLOAT_MAT3]=function(b,c){return a.uniformMatrix3fv(b,
!1,c)};b[a.FLOAT_MAT4]=function(b,c){return a.uniformMatrix4fv(b,!1,c)};b[a.FLOAT]=function(b,e){return c(e)?a.uniform1fv(b,e):a.uniform1f(b,e)};b[a.INT_VEC2]=function(b,c){return a.uniform2iv(b,c)};b[a.INT_VEC3]=function(b,c){return a.uniform3iv(b,c)};b[a.INT_VEC4]=function(b,c){return a.uniform4iv(b,c)};b[a.INT]=function(b,e){return c(e)?a.uniform1iv(b,e):a.uniform1i(b,e)};b[a.SAMPLER_2D]=b[a.INT];b[a.SAMPLER_CUBE]=b[a.INT];var e=function(a){return a?1:0};b[a.BOOL_VEC2]=function(b,c){return a.uniform2iv(b,
c.map(e))};b[a.BOOL_VEC3]=function(b,c){return a.uniform3iv(b,c.map(e))};b[a.BOOL_VEC4]=function(b,c){return a.uniform4iv(b,c.map(e))};b[a.BOOL]=function(b,d){return c(d)?a.uniform1iv(b,d.map(e)):a.uniform1i(b,d?1:0)};1<this.glVersion&&(b[a.SAMPLER_3D]=b[a.INT],b[a.SAMPLER_2D_SHADOW]=b[a.INT],b[a.SAMPLER_2D_ARRAY]=b[a.INT],b[a.SAMPLER_2D_ARRAY_SHADOW]=b[a.INT],b[a.SAMPLER_CUBE_SHADOW]=b[a.INT],b[a.INT_SAMPLER_2D]=b[a.INT],b[a.INT_SAMPLER_3D]=b[a.INT],b[a.INT_SAMPLER_CUBE]=b[a.INT],b[a.INT_SAMPLER_2D_ARRAY]=
b[a.INT],b[a.UNSIGNED_INT_SAMPLER_2D]=b[a.INT],b[a.UNSIGNED_INT_SAMPLER_3D]=b[a.INT],b[a.UNSIGNED_INT_SAMPLER_CUBE]=b[a.INT],b[a.UNSIGNED_INT_SAMPLER_2D_ARRAY]=b[a.INT],b[a.UNSIGNED_INT_VEC2]=function(b,c){return a.uniform2uiv(b,c)},b[a.UNSIGNED_INT_VEC3]=function(b,c){return a.uniform3uiv(b,c)},b[a.UNSIGNED_INT_VEC4]=function(b,c){return a.uniform4uiv(b,c)},b[a.UNSIGNED_INT]=function(b,e){return c(e)?a.uniform1uiv(b,e):a.uniform1ui(b,e)},b[a.FLOAT_MAT2x3]=function(b,c){return a.uniformMatrix2x3fv(b,
!1,c)},b[a.FLOAT_MAT2x4]=function(b,c){return a.uniformMatrix2x4fv(b,!1,c)},b[a.FLOAT_MAT3x2]=function(b,c){return a.uniformMatrix3x2fv(b,!1,c)},b[a.FLOAT_MAT3x4]=function(b,c){return a.uniformMatrix3x4fv(b,!1,c)},b[a.FLOAT_MAT4x2]=function(b,c){return a.uniformMatrix4x2fv(b,!1,c)},b[a.FLOAT_MAT4x3]=function(b,c){return a.uniformMatrix4x3fv(b,!1,c)});return b};b.GLContext.prototype._initializeConstants=function(){var a=this.gl;this.GlMaxTextures=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);this.GlMaxTextureSize=
a.getParameter(a.MAX_TEXTURE_SIZE);this.GlMax3DTextureSize=1<this.glVersion?a.getParameter(a.MAX_3D_TEXTURE_SIZE):0;this.GlMaxFragUniformVecs=a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS);this.GlMaxVertUniformVecs=a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS);this.GlMaxRenderBufSize=a.getParameter(a.MAX_RENDERBUFFER_SIZE);this.GlVersionInfo=a.getParameter(a.VERSION);var b=a.getExtension("WEBGL_debug_renderer_info");null!==b?(this.RendererInfo=a.getParameter(b.UNMASKED_RENDERER_WEBGL),this.VendorInfo=
a.getParameter(b.UNMASKED_VENDOR_WEBGL)):(this.RendererInfo=a.getParameter(a.RENDERER)||"Unknown",this.VendorInfo=a.getParameter(a.VENDOR)||"Unknown")};b.GLContext.prototype.sizeOf=function(a){var b=-1,c=this.gl;a===c.FLOAT||a===c.UNSIGNED_INT||a===c.INT?b=4:a===c.UNSIGNED_SHORT||a===c.SHORT?b=2:a===c.UNSIGNED_BYTE||a===c.BYTE?b=1:1<this.glVersion&&a===c.HALF_FLOAT&&(b=2);return b}})(window.BigLime=window.BigLime||{});
(function(b,h){b.Histogram3D=function(b){this.data=new Uint32Array(b);this.numBins=b;this.binWidth=65536/b;this.minVal=65535;this.threshedMaxVal=this.threshedMinVal=this.maxVal=0;this.threshPercent=null};b.Histogram3D.prototype.clear=function(){for(var b=0;b<this.numBins;b++)this.data[b]=0;this.minVal=65535;this.threshedMaxVal=this.threshedMinVal=this.maxVal=0;this.threshPercent=null};b.Histogram3D.prototype.addImage=function(b,a,f){if(b){b=new Uint8Array(b);var c=b.length;if(1==a)for(a=0;a<c;a+=
8)f=b[a],this.data[f/this.binWidth|0]++,f<this.minVal&&(this.minVal=f),f>this.maxVal&&(this.maxVal=f);else if(2==a)if(f)for(a=0;a<c;a+=16)f=256*b[a]+b[a+1],this.data[f/this.binWidth|0]++,f<this.minVal&&(this.minVal=f),f>this.maxVal&&(this.maxVal=f);else for(a=0;a<c;a+=16)f=b[a]+256*b[a+1],this.data[f/this.binWidth|0]++,f<this.minVal&&(this.minVal=f),f>this.maxVal&&(this.maxVal=f)}};b.Histogram3D.prototype.getThreshedMinMax=function(b){if(this.threshPercent===b)return[this.threshedMinVal,this.threshedMaxVal];
for(var a=0,d=1;d<this.numBins;d++)a+=this.data[d];d=Math.round(.01*b*a);for(var c=0,e=1;c<=d&&e<this.numBins;)for(c+=this.data[e],e++;e<this.numBins&&0===this.data[e];)e++;a=(e+.5)*this.binWidth;c=0;for(e=this.numBins-1;0<=e&&c<=d;)for(c+=this.data[e],e--;0<=e&&0===this.data[e];)e--;d=65535-(this.numBins-1-e+.5)*this.binWidth;d<a&&(d=a);this.threshPercent=b;this.threshedMinVal=a;this.threshedMaxVal=d;return[this.threshedMinVal,this.threshedMaxVal]}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=b.Logger.Severity;b.IndexBuffer=function(a,f,c,e){var k=a.gl;this.context=a;this.elemSize=c||2;this.dataType=1==c?k.UNSIGNED_BYTE:2==c?k.UNSIGNED_SHORT:k.UNSIGNED_INT;this.drawMode=e||k.STATIC_DRAW;this.numIndices=0;this.glBuffer=null;1!=c&&2!=c&&4!=c?b.Logger.Report("IndexBuffer ctor: Invalid elemSize",d.Error):2<c&&2>a.glVersion&&!k.getExtension("OES_element_index_uint")?b.Logger.Report("IndexBuffer ctor: Unsupported elemSize",d.Error):(a=this._coerceData(f))?(this.numIndices=
a.length,this.glBuffer=k.createBuffer(),this.bind(),k.bufferData(k.ELEMENT_ARRAY_BUFFER,a,this.drawMode)):b.Logger.Report("IndexBuffer.ctor: Invalid data array.",d.Error)};b.IndexBuffer.prototype.destroy=function(){if(this.context){var a=this.context.gl;this.bind();a.bufferData(a.ELEMENT_ARRAY_BUFFER,1,this.drawMode);this.unbind();this.glBuffer&&(a.deleteBuffer(this.glBuffer),this.glBuffer=null);this.context=null}};b.IndexBuffer.prototype.bind=function(){this.context.bindIndexBuffer(this)};b.IndexBuffer.prototype.unbind=
function(){this.context.unbindIndexBuffer(this)};b.IndexBuffer.prototype._coerceData=function(a){var b=this.context.gl;try{if(this.dataType===b.UNSIGNED_INT)return a instanceof Uint32Array?a:new Uint32Array(a);if(this.dataType===b.UNSIGNED_SHORT)return a instanceof Uint16Array?a:new Uint16Array(a);if(this.dataType===b.UNSIGNED_BYTE)return a instanceof Uint8Array?a:new Uint8Array(a)}catch(c){}return null};b.IndexBuffer.prototype.setData=function(a,f){if(a=this._coerceData(a)){var c=this.context.gl;
this.bind();c.bufferSubData(c.ELEMENT_ARRAY_BUFFER,f||0,a)}else b.Logger.Report("IndexBuffer.setData: Invalid data array.",d.Error)}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=glMatrix.vec3;b.Light=function(a){this.diffuse=a?a.diffuse:.1;this.specStrength=a?a.specStrength:0;this.specExp=a?a.specExp:32;this.shadowDarkness=a?a.shadowDarkness:0;this.shadowSoftness=a?a.shadowSoftness:.75;this.dir=a?d.clone(a.dir):d.fromValues(0,0,1)};b.Light.prototype.updateFrom=function(a){this.diffuse=a.diffuse;this.specStrength=a.specStrength;this.specExp=a.specExp;this.shadowDarkness=a.shadowDarkness;this.shadowSoftness=a.shadowSoftness;d.copy(this.dir,a.dir)};b.Light.prototype.valueEquals=
function(a){return b.Utils.floatEquals(this.diffuse,a.diffuse,1E-4)&&b.Utils.floatEquals(this.specStrength,a.specStrength,1E-4)&&b.Utils.floatEquals(this.specExp,a.specExp,1E-4)&&b.Utils.floatEquals(this.shadowDarkness,a.shadowDarkness,1E-4)&&b.Utils.floatEquals(this.shadowSoftness,a.shadowSoftness,1E-4)&&b.Utils.floatEquals(this.dir[0],a.dir[0],1E-4)&&b.Utils.floatEquals(this.dir[1],a.dir[1],1E-4)&&b.Utils.floatEquals(this.dir[2],a.dir[2],1E-4)?!0:!1}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=glMatrix.vec2,a=glMatrix.vec3;b.LightPositioner=function(a){this.mainDiv=a;this.canvas=null;this.ptRadius=10;this.lightPosW=d.create();this.active=!1;this.defaultLightDir=[.32,-.16,.93];this._buildUi();this.setLightDirection(this.defaultLightDir);this._redraw();this.interactor=new b.Interactor(this.canvas,"lightPos");this.interactor.addEventListener("start move end",this._onInteract.bind(this))};b.LightPositioner.prototype._buildUi=function(){var a=b.Ui;a.StyleElement(this.mainDiv,
{margin:"auto"});this.canvSize=Math.min(parseInt(this.mainDiv.style.width),parseInt(this.mainDiv.style.height));this.padRadius=(this.canvSize-2*this.ptRadius)/2;this.canvas=a.CreateElement("canvas","canvas",this.mainDiv,{width:this.canvSize,height:this.canvSize},{width:this.canvSize,height:this.canvSize});this.canvas.addEventListener(b.Utils.isTouchDevice()?"doubleTap":"dblclick",this._onDoubleClick.bind(this))};b.LightPositioner.prototype._redraw=function(){var a=this.canvas.getContext("2d"),b=this.canvas.width,
e=this.canvas.height;a.clearRect(0,0,b,e);a.beginPath();a.fillStyle="rgba(255, 255, 255, 0.0)";a.fillRect(0,0,b,e);b/=2;e/=2;a.beginPath();a.arc(b,e,this.padRadius,0,2*Math.PI);a.fillStyle="#D2B48C";a.fill();a.beginPath();a.arc(this.lightPosW[0],this.lightPosW[1],this.ptRadius,0,2*Math.PI);a.fillStyle="#8B4513";a.fill();a.beginPath();a.moveTo(b,e-this.ptRadius-5);a.lineTo(b,e+this.ptRadius+5);a.moveTo(b-this.ptRadius-5,e);a.lineTo(b+this.ptRadius+5,e);a.strokeStyle="black";a.stroke()};b.LightPositioner.prototype.getLightDirection=
function(){var b=-(this.lightPosW[0]-this.canvas.width/2),c=this.lightPosW[1]-this.canvas.height/2;b=a.fromValues(b,c,Math.sqrt(this.padRadius*this.padRadius-b*b-c*c));a.normalize(b,b);return b};b.LightPositioner.prototype.setLightDirection=function(b){b=a.clone(b);a.normalize(b,b);a.scale(b,b,this.padRadius);this.lightPosW[0]=-b[0]+this.canvas.width/2;this.lightPosW[1]=b[1]+this.canvas.height/2;this._redraw();this.trigger("change")};b.LightPositioner.prototype._onInteract=function(a){if("start"==
a.type)d.distance(this.interactor.currPoint,this.lightPosW)>this.ptRadius||(this.active=!0,this.trigger("changeStart"));else if("move"==a.type){if(this.active){d.add(this.lightPosW,this.lightPosW,this.interactor.deltaPrev);a=d.fromValues(this.canvas.width/2,this.canvas.height/2);var b=d.create();d.subtract(b,this.lightPosW,a);var e=d.length(b);e>.98*this.padRadius&&(d.scale(b,b,.98*this.padRadius/e),d.add(this.lightPosW,b,a));this._redraw();this.trigger("change")}}else"end"==a.type&&this.active&&
(this.active=!1,this.trigger("changeEnd"))};b.LightPositioner.prototype._onDoubleClick=function(){this.setLightDirection(this.defaultLightDir)};b.LightPositioner.prototype.addEventListener=function(a,c){b.Notifier.prototype.addEventListener.call(this,a,c)};b.LightPositioner.prototype.removeEventListener=function(a,c){b.Notifier.prototype.removeEventListener.call(this,a,c)};b.LightPositioner.prototype.trigger=function(a,c){b.Notifier.prototype.trigger.call(this,a,c)}})(window.BigLime=window.BigLime||
{});
(function(b,h){b.LightSet=function(d){d?(this.ambientLight=d.ambientLight,this.dirLights=[new b.Light(d.dirLights[0]),new b.Light(d.dirLights[1])]):(this.ambientLight=.5,this.dirLights=[new b.Light,new b.Light])};b.LightSet.prototype.updateFrom=function(b){this.ambientLight=b.ambientLight;this.dirLights[0].updateFrom(b.dirLights[0]);this.dirLights[1].updateFrom(b.dirLights[1])};b.LightSet.prototype.valueEquals=function(d){return b.Utils.floatEquals(this.ambientLight,d.ambientLight,1E-4)&&this.dirLights[0].valueEquals(d.dirLights[0])&&this.dirLights[1].valueEquals(d.dirLights[1])?
!0:!1};b.LightSet.prototype.shadowsEnabled=function(){return this.dirLights.some(function(b){return 0<b.shadowDarkness})}})(window.BigLime=window.BigLime||{});
(function(b,h){b.Material=function(d,a,f,c,e,k){this.flatShade=!!a;this.ambient=f||(0===f?0:.5);this.diffuse=c||(0===c?0:.5);this.specStrength=e||(0===e?0:.5);this.specPower=k||(0===k?0:32);this.color=d?d instanceof b.Color?d.toArray():d.slice():[255,0,0,255];3===this.color.length&&this.color.push(255)};b.Material.prototype.clone=function(){return new b.Material(this.color,this.flatShade,this.ambient,this.diffuse,this.specStrength,this.specPower)}})(window.BigLime=window.BigLime||{});
(function(b,h){b.MeshManager=function(b){this.volume=b;this.meshes=[];this.materialBuffer=this.colorBuffer=this.normalBuffer=this.vertexBuffer=null;this.bufferOffsets={vertices:0,normals:0,colors:0,materials:0};this.needToSync=!0};b.MeshManager.prototype.destroy=function(){this.volume&&(this.vertexBuffer&&(this.vertexBuffer.destroy(),this.vertexBuffer=null),this.normalBuffer&&(this.normalBuffer.destroy(),this.normalBuffer=null),this.colorBuffer&&(this.colorBuffer.destroy(),this.colorBuffer=null),
this.materialBuffer&&(this.materialBuffer.destroy(),this.materialBuffer=null),this.volume=null)};b.MeshManager.prototype.addMesh=function(d){for(var a=0;a<this.meshes.length;a++)if(this.meshes[a].name==d.name){b.Logger.Report("Warning: Duplicate mesh name ("+d.name+"), in MeshManager.addMesh.",b.Logger.Severity.Warning);break}this.meshes.push(d);this.needToSync=!0};b.MeshManager.prototype.removeMesh=function(b){var a,d=null;for(a=0;a<this.meshes.length;a++)if(this.meshes[a].name==b){d=this.meshes[a];
this.meshes.splice(a,1);this.needToSync=!0;break}return d};b.MeshManager.prototype.removeAllMeshes=function(){var b=this.meshes;this.needToSync=0<b.length;this.meshes=[];return b};b.MeshManager.prototype.contains=function(b){return this.meshes.includes(b)};b.MeshManager.prototype.numMeshes=function(b){for(var a=0,d=0;d<this.meshes.length;d++)this.meshes[d].layer!==b&&"undefined"!=typeof b||a++;return a};b.MeshManager.prototype.numVisibleMeshes=function(b){for(var a=0,d=0;d<this.meshes.length;d++){var c=
this.meshes[d];!c.visible||c.layer!==b&&"undefined"!=typeof b||a++}return a};b.MeshManager.prototype.numVisibleVertices=function(b){for(var a=0,d=0;d<this.meshes.length;d++){var c=this.meshes[d];!c.visible||c.layer!==b&&"undefined"!=typeof b||(a+=c.numVertices())}return a};b.MeshManager.prototype.activateMeshes=function(d,a){d=d||0;if(!this.vertexBuffer){var f=this.volume.context;this.vertexBuffer=new b.AttributeBuffer(f,null,3);this.normalBuffer=new b.AttributeBuffer(f,null,3);this.colorBuffer=new b.AttributeBuffer(f,
null,4);this.materialBuffer=new b.AttributeBuffer(f,null,4)}this.needToSync&&(f=this._concatDataArrays("vBuffer"),this.vertexBuffer.setData(f.data),this.bufferOffsets.vertices=f.offset,f=this._concatDataArrays("nBuffer"),this.normalBuffer.setData(f.data),this.bufferOffsets.normals=f.offset,f=this._concatDataArrays("cBuffer"),this.colorBuffer.setData(f.data),this.bufferOffsets.colors=f.offset,f=this._concatDataArrays("mBuffer"),this.materialBuffer.setData(f.data),this.bufferOffsets.materials=f.offset,
this.needToSync=!1);f=0===d?0:4*this.bufferOffsets.vertices;a.setAttribute("aPosition",this.vertexBuffer,!0,f);f=0===d?0:4*this.bufferOffsets.normals;a.setAttribute("aNormal",this.normalBuffer,!0,f);f=0===d?0:4*this.bufferOffsets.colors;a.setAttribute("aColor",this.colorBuffer,!0,f);f=0===d?0:4*this.bufferOffsets.materials;a.setAttribute("aMaterial",this.materialBuffer,!0,f)};b.MeshManager.prototype._concatDataArrays=function(b){for(var a,d=0,c=0,e=0;e<this.meshes.length;e++)a=this.meshes[e],a.visible&&
(0===a.layer?d+=a[b].length:c+=a[b].length);c=d+c;e=new Float32Array(c);for(var k=0,g=0;g<this.meshes.length;g++)a=this.meshes[g],a.visible&&0===a.layer&&(e.set(a[b],k),k+=a[b].length);for(g=0;g<this.meshes.length;g++)a=this.meshes[g],a.visible&&0!==a.layer&&(e.set(a[b],k),k+=a[b].length);if("vBuffer"==b){a=1/this.volume.dims[0];k=1/this.volume.dims[1];g=1/(this.volume.dims[2]*this.volume.sliceGap);for(var l=0;l<c;l+=3)e[l]=e[l]*a-.5,e[l+1]=e[l+1]*k-.5,e[l+2]=.5-e[l+2]*g}if("nBuffer"==b)for(b=2;b<
c;b+=3)e[b]=-e[b];return{data:e,offset:d}}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=glMatrix.vec2,a=glMatrix.vec3,f=glMatrix.mat4;b.MprViewer=function(c){c=c===h?{}:c;this.site=c.site;this.id=c.id;this.owner=c.owner;this.drawOrientLabels=!1===c.drawOrientLabels?!1:!0;if(!c.initialPlane||"string"===typeof c.initialPlane||c.initialPlane instanceof String){var e=(c.initialPlane||"axi").toLowerCase();this.rowDir="axi"==e?a.fromValues(1,0,0):"cor"==e?a.fromValues(1,0,0):a.fromValues(0,1,0);this.colDir="axi"==e?a.fromValues(0,1,0):a.fromValues(0,0,-1)}else this.rowDir=
a.clone(c.initialPlane[0]),this.colDir=a.clone(c.initialPlane[1]),a.normalize(this.rowDir,this.rowDir),a.normalize(this.colDir,this.colDir);this.initialPlane={rowDir:a.clone(this.rowDir),colDir:a.clone(this.colDir)};this.canvas=b.Ui.CreateElement("canvas","mprviewer_canvas",this.site,{width:"100%",height:"100%",backgroundColor:"#000000"});this.canvas.addEventListener("contextmenu",function(a){a.preventDefault()});this.renderEngine=c.renderEngine?c.renderEngine:new b.RenderEngine({options:c.engineOptions});
this.ownsEngine=!c.renderEngine;e=this.renderParams=new b.RenderParams;e.renderType=b.RenderType.MIP;e.slab=new b.Slab(this.renderEngine.volume);e.clipToSlab=!0;e.showSlab=!1;e.rayOversamp=2;e.showGraphics=!1;e.showMarker=!1;e.rotMatrix=b.Utils.GetRotMatrix(this.rowDir,this.colDir);this.mprThickness=1;this.mprPoint=a.fromValues(.5,.5,.5);this.fastDrawDownsamp=1;this.resizeTimerId=null;this.renderCallbacks=[];c.omitInteractor||(this.interactor=new b.MultiInteractor(this.canvas),this.interactor.addEventListener("start move end",
this._onInteractorEvent.bind(this)));!1!==c.autoResize&&(this.resizeListener=this.onResize.bind(this),window.addEventListener("resize",this.resizeListener));this.onResize()};b.MprViewer.prototype.destroy=function(){this.renderEngine&&(clearTimeout(this.resizeTimerId),this.resizeListener&&window.removeEventListener("resize",this.resizeListener),b.Utils.cancelAnimFrame(this.rafId),this.interactor&&this.interactor.stopListening(),this.ownsEngine&&this.renderEngine.destroy(),this.renderEngine=null,this.canvas.remove())};
b.MprViewer.prototype.onResize=function(a){a=a===h?!1:a;var c=this.canvas.getBoundingClientRect();this.canvas.width=Math.round(c.width);this.canvas.height=Math.round(c.height);this.rafId=b.Utils.requestAnimFrame(this.render.bind(this));a?this.resizeTimerId=null:(this.resizeTimerId&&clearTimeout(this.resizeTimerId),this.resizeTimerId=setTimeout(function(){this.onResize(!0)}.bind(this),300))};b.MprViewer.prototype.clear=function(){this.canvas.getContext("2d").clearRect(0,0,this.canvas.width,this.canvas.height)};
b.MprViewer.prototype.loadVolume=function(a,b,d,f){var c=function(a,b){if(!a)this.onNewVolumeLoaded();d&&d(a,b,this)}.bind(this);this.renderEngine.loadVolume({imgFiles:a,loader:b,completionCb:c,progressCb:f,omitRender:!0,omitResetView:!0})};b.MprViewer.prototype.cancelLoading=function(){this.renderEngine.cancelLoading()};b.MprViewer.prototype.onNewVolumeLoaded=function(){};b.MprViewer.prototype.render=function(){var a=this,b=this.renderEngine;if(b.hasImageData()){b.setRenderParams(this.renderParams);
var d=b.isAnimating()?this.fastDrawDownsamp:1;b.sizeRasterFor(this.canvas,d);this._updateSlab();b.render();d=this.canvas.getContext("2d");var f=$jscomp.makeIterator([this.canvas.width,this.canvas.height]),l=f.next().value;f=f.next().value;var m=$jscomp.makeIterator([b.canvas.width,b.canvas.height]);m.next();m=m.next().value;var n=$jscomp.makeIterator([b.viewport[2],b.viewport[3]]),h=n.next().value;n=n.next().value;d.clearRect(0,0,l,f);d.drawImage(b.canvas,0,m-n,h,n,0,0,l,f);this.drawOrientLabels&&
this._drawOrientLabels();this.renderCallbacks.forEach(function(b){b(a)})}};b.MprViewer.prototype._drawOrientLabels=function(c){c=this.canvas.getContext("2d");var e=this.canvas.width,d=this.canvas.height,f=["",""],l=this.renderEngine.volume,m=l.getAttr("rowDir");l=l.getAttr("colDir");if(m&&l){var n=a.cross(a.create(),m,l),h=a.create();a.scaleAndAdd(h,h,m,this.rowDir[0]);a.scaleAndAdd(h,h,l,this.rowDir[1]);a.scaleAndAdd(h,h,n,this.rowDir[2]);f[0]=b.ImageLook.getOrientationLabel(h);h=a.create();a.scaleAndAdd(h,
h,m,this.colDir[0]);a.scaleAndAdd(h,h,l,this.colDir[1]);a.scaleAndAdd(h,h,n,this.colDir[2]);a.negate(h,h);f[1]=b.ImageLook.getOrientationLabel(h)}Object.assign(c,{font:"18px Arial Narrow",textAlign:"center",textBaseline:"middle",fillStyle:"#cfcfcf",shadowColor:"black",shadowOffsetX:2,shadowOffsetY:2});c.fillText(f[0],e-24,d/2);c.fillText(f[1],e/2,15);e=$jscomp.makeIterator([0,0]);c.shadowOffsetX=e.next().value;c.shadowOffsetY=e.next().value};b.MprViewer.prototype._updateSlab=function(){var b=this.renderParams,
e=this.renderEngine.volume,d=b.slab,g=Math.max.apply(Math,$jscomp.arrayFromIterable(e.shape));a.copy(d.shape,[4*g,4*g,this.mprThickness]);f.copy(d.orient,b.rotMatrix);a.multiply(d.center,this.mprPoint,e.shape)};b.MprViewer.prototype._onInteractorEvent=function(a){var b=this.renderEngine,c=this.renderParams,f=this.interactor;if("start"==a.type)f.setInitialValues({zoom:c.zoom,pan:c.pan,wwl:{width:c.winWidth,level:c.winLevel,levelRange:b.volume.getAutoWinLevel()[0]}}),b.animate(15,this.render.bind(this));
else if("move"==a.type)switch(f.interactMode){case "zoom":case "wheelzoom":c.zoom=f.currentZoom;break;case "pan":d.copy(c.pan,f.currentPan);break;case "panzoom":c.zoom=f.currentZoom;d.copy(c.pan,f.currentPan);break;case "light":c.winWidth=f.winWidth,c.winLevel=f.winLevel}else"end"==a.type&&(b.stopAnimation(),this.render())};b.MprViewer.prototype.setMprPoint=function(b){a.copy(this.mprPoint,b)};b.MprViewer.prototype.resetMprPoint=function(){this.setMprPoint([.5,.5,.5])};b.MprViewer.prototype.setMprThickness=
function(a){this.mprThickness=Math.max(1,a)};b.MprViewer.prototype.setOrientation=function(c,e){a.normalize(this.rowDir,c);a.normalize(this.colDir,e);Math.abs(1E-4<a.dot(this.rowDir,this.colDir))&&b.Logger.Report("MprViewer.setOrient: Received non-orthogonal orientation vectors.",b.Logger.Severity.Warn,!1,!1);b.Utils.GetRotMatrix(this.rowDir,this.colDir,this.renderParams.rotMatrix)};b.MprViewer.prototype.resetOrientation=function(){var b=this.initialPlane,e=this.renderEngine.volume.nearLphAxes,d=
a.scale(a.create(),e.L,b.rowDir[0]);a.scaleAndAdd(d,a.scaleAndAdd(d,d,e.P,b.rowDir[1]),e.H,b.rowDir[2]);var f=a.scale(a.create(),e.L,b.colDir[0]);a.scaleAndAdd(f,a.scaleAndAdd(f,f,e.P,b.colDir[1]),e.H,b.colDir[2]);this.setOrientation(d,f)};b.MprViewer.prototype.resetZoom=function(){this.renderParams.zoom=this.calcDefaultZoom()};b.MprViewer.prototype.resetPan=function(){d.copy(this.renderParams.pan,[0,0])};b.MprViewer.prototype.resetWindowWidthAndLevel=function(){var a=$jscomp.makeIterator(this.renderEngine.volume.getAutoWinLevel());
this.renderParams.winWidth=a.next().value;this.renderParams.winLevel=a.next().value};b.MprViewer.prototype.calcDefaultZoom=function(){var a=1;if(this.renderEngine.hasImageData()){a=this.renderEngine.volume;var b=this.rowDir.reduce(function(a,b,c,e){return Math.abs(b)>Math.abs(e[a])?c:a},0),d=this.colDir.reduce(function(a,b,c,e){return Math.abs(b)>Math.abs(e[a])?c:a},0),f=this.canvas.width/this.canvas.height;a=a.shape[b]/a.shape[d]>f?a.diagSize/a.shape[b]*Math.max(1,f):a.diagSize/a.shape[d]*Math.max(1,
1/f)}return a};b.MprViewer.prototype.txToViewport=function(b,e){e=e===h?null:e;var c=$jscomp.makeIterator([this.canvas.width,this.canvas.height]),d=c.next().value;c=c.next().value;e=e||this.renderEngine.calcTransforms(this.renderParams,c/d,{omitLights:!0});b=a.subtract(a.create(),b,[.5,.5,.5]);e=a.transformMat4(a.create(),b,e.mvp);return[(1+e[0])*d/2,(1-e[1])*c/2]};b.MprViewer.prototype.viewportToTx=function(b,e){e=e===h?null:e;var c=$jscomp.makeIterator([this.canvas.width,this.canvas.height]),d=
c.next().value;c=c.next().value;e=e||this.renderEngine.calcTransforms(this.renderParams,c/d,{omitLights:!0});b=[2*b[0]/d-1,1-2*b[1]/c,0];e=a.transformMat4(a.create(),b,e.mvpInv);a.add(e,e,[.5,.5,.5]);b=a.cross(a.create(),this.rowDir,this.colDir);d=a.dot(b,a.subtract(a.create(),e,this.mprPoint));a.subtract(e,e,a.scale(b,b,d));return e}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=glMatrix.vec2,a=glMatrix.vec3,f=glMatrix.mat4;b.MultiInteractor=function(a,d){var c=this;d=d||{};var e=d.pan||{btns:2,shift:!1,ctrl:!1,alt:!1},l=d.zoom||{btns:0,shift:!0,ctrl:!1,alt:!1},m=d.rot||{btns:0,shift:!1,ctrl:!1,alt:!1};d=d.wl||{btns:0,shift:!1,ctrl:!1,alt:!0};this.panEventTypes=Array.isArray(e)?e:[e];this.zoomEventTypes=Array.isArray(l)?l:[l];this.rotEventTypes=Array.isArray(m)?m:[m];this.wlEventTypes=Array.isArray(d)?d:[d];b.Interactor.call(this,a,"multi",[].concat.apply([],
[this.panEventTypes,this.zoomEventTypes,this.rotEventTypes,this.wlEventTypes]));this.wlEnabled=this.rotEnabled=this.zoomEnabled=this.panEnabled=!0;this.winLevel=this.winWidth=1;this.shadow=this.ambient=0;this.wlRateOfChange=1;this.asRateOfChange=1/1024;this.initialZoom=1;this.initialPan=[0,0];this.initialRot=f.create();this.currentZoom=1;this.currentPan=[0,0];this.currentRot=f.create();this.deltaRot=f.create();this.mouseWheelZoomEnabled=!0;this.mouseWheelListener=this._onMouseWheelChange.bind(this);
this.eventSources.forEach(function(a){return a.addEventListener("wheel",c.mouseWheelListener)});this.mouseWheelTimerId=null};b.MultiInteractor.prototype=Object.create(b.Interactor.prototype);b.MultiInteractor.prototype.constructor=b.MultiInteractor;b.MultiInteractor.prototype.stopListening=function(){var a=this;b.Interactor.prototype.stopListening.call(this);this.eventSources.forEach(function(b){return b.removeEventListener("wheel",a.mouseWheelListener)});clearTimeout(this.mouseWheelTimerId)};b.MultiInteractor.prototype.setInitialValues=
function(a){a=a===h?{}:a;a.zoom&&(this.initialZoom=this.currentZoom=a.zoom);a.pan&&(d.copy(this.initialPan,a.pan),d.copy(this.currentPan,a.pan));a.rot&&(f.copy(this.initialRot,a.rot),f.copy(this.currentRot,a.rot));a.wwl&&(this.winWidth=a.wwl.width,this.winLevel=a.wwl.level,this.wlRateOfChange=Math.max(1,a.wwl.levelRange)/1024);a.lighting&&(this.ambient=a.lighting.ambient,this.shadow=a.lighting.shadow,this.asRateOfChange=1/1024)};b.MultiInteractor.prototype._onStart=function(a){this.mouseWheelTimerId&&
(clearTimeout(this.mouseWheelTimerId),this.mouseWheelTimerId=null);if(this.pinching)this.interactMode=this.panEnabled||this.zoomEnabled?"panzoom":"none";else{var c=b.Interactor.MouseEventMatches;this.interactMode=c(a,this.rotEventTypes)&&this.rotEnabled?"rotate":c(a,this.panEventTypes)&&this.panEnabled?"pan":c(a,this.zoomEventTypes)&&this.zoomEnabled?"zoom":c(a,this.wlEventTypes)&&this.wlEnabled?"light":"none"}"none"!=this.interactMode&&(this.onStart?this.onStart(a):this.trigger("start",{origEvent:a}))};
b.MultiInteractor.prototype._onMove=function(a){if("none"!=this.interactMode&&"wheelzoom"!=this.interactMode){var c=this.currentEventSource.getBoundingClientRect();if(this.pinching)2<=this.currNumTouches&&(c=2/Math.min(c.width,c.height),this.currentPan[0]-=c*this.deltaPrevPinch.ctr[0]/this.currentZoom,this.currentPan[1]+=c*this.deltaPrevPinch.ctr[1]/this.currentZoom,this.currentZoom=this.currPinch.sep/(this.startPinch.sep+1E-4)*this.initialZoom);else switch(this.interactMode){case "pan":c=2/Math.min(c.width,
c.height);this.currentPan[0]-=c*this.deltaPrev[0]/this.currentZoom;this.currentPan[1]+=c*this.deltaPrev[1]/this.currentZoom;break;case "zoom":this.currentZoom*=Math.pow(1.01,-this.deltaPrev[1]);break;case "panzoom":c=2/Math.min(c.width,c.height);this.currentPan[0]-=c*this.deltaPrev[0]/this.currentZoom;this.currentPan[1]+=c*this.deltaPrev[1]/this.currentZoom;this.currentZoom*=Math.pow(1.01,-this.deltaPrev[1]);break;case "rotate":c=d.fromValues(c.width,c.height);b.MultiInteractor._CalcRotationMatrix(this.deltaRot,
this.prevPoint,this.currPoint,c);f.multiply(this.currentRot,this.deltaRot,this.currentRot);break;case "light":this.winLevel+=this.wlRateOfChange*this.deltaPrev[1],this.winWidth-=this.wlRateOfChange*this.deltaPrev[0],this.winWidth=Math.max(this.winWidth,1E-4),this.ambient-=this.asRateOfChange*this.deltaPrev[1],this.ambient=Math.min(2,Math.max(0,this.ambient)),this.shadow+=this.asRateOfChange*this.deltaPrev[0],this.shadow=Math.min(1.5,Math.max(0,this.shadow))}this.onMove?this.onMove(a):this.trigger("move",
{origEvent:a})}};b.MultiInteractor.prototype._onEnd=function(a){"none"!=this.interactMode&&(this.onEnd?this.onEnd(a):this.trigger("end",{origEvent:a}),this.interactMode="none")};b.MultiInteractor.prototype._onMouseWheelChange=function(a){if(this.mouseWheelZoomEnabled){var b=a.originalEvent;if(!a.deltaMode&&0!==a.deltaMode||!a.deltaY&&0!==a.deltaY){if(!b||!b.deltaMode&&0!==b.deltaMode||!b.deltaY&&0!==b.deltaY)return;b=a.originalEvent.deltaMode;var c=a.originalEvent.deltaY}else b=a.deltaMode,c=a.deltaY;
b=Math.pow(1.01,-c/(0===b?50:1.5));this.mouseWheelTimerId?(this.currentZoom*=b,this.onMove?this.onMove(a):this.trigger("move",{origEvent:a}),clearTimeout(this.mouseWheelTimerId)):(this.active=!0,this.interactMode="wheelzoom",this.onStart?this.onStart(a):this.trigger("start",{origEvent:a}),this.currentZoom=this.initialZoom*b,this.onMove?this.onMove(a):this.trigger("move",{origEvent:a}));this.mouseWheelTimerId=setTimeout(function(){this.onEnd?this.onEnd(a):this.trigger("end",{origEvent:a});this.active=
!1;this.interactMode="none";this.mouseWheelTimerId=null}.bind(this),500);a.preventDefault()}};b.MultiInteractor._CalcRotationMatrix=function(b,e,k,g){var c=d.clone(g);d.scale(c,c,.5);var m=Math.min(c[0],c[1]);g=m*m;k=d.clone(k);d.subtract(k,k,c);e=d.clone(e);d.subtract(e,e,c);k[0]=-k[0];e[0]=-e[0];c=d.length(k);c>m&&(d.scale(k,k,m/c),c=m);k=a.fromValues(k[0],k[1],Math.sqrt(Math.max(0,g-c*c)));c=d.length(e);c>m&&(d.scale(e,e,m/c),c=m);e=a.fromValues(e[0],e[1],Math.sqrt(Math.max(0,g-c*c)));1E-4>Math.abs(k[0]-
e[0])&&1E-4>Math.abs(k[1]-e[1])?f.identity(b):(m=a.create(),a.cross(m,k,e),k=a.length(m),1E-4>Math.abs(k)?f.identity(b):(g=k/g,e=Math.sqrt(Math.max(0,1-g*g)),g=Math.sqrt(Math.max(0,(1-e)/2)),e=Math.sqrt(Math.max(0,(1+e)/2)),a.scale(m,m,-1/k),k=m[0]*g,c=m[1]*g,g*=m[2],b[0]=e*e+k*k-c*c-g*g,b[1]=2*(k*c+e*g),b[2]=2*(k*g-e*c),b[3]=0,b[4]=2*(k*c-e*g),b[5]=e*e-k*k+c*c-g*g,b[6]=2*(c*g+e*k),b[7]=0,b[8]=2*(k*g+e*c),b[9]=2*(c*g-e*k),b[10]=e*e-k*k-c*c+g*g,b[11]=0))}})(window.BigLime=window.BigLime||{});
(function(){function b(h,d,a){function f(e,g){if(!d[e]){if(!h[e]){var k="function"==typeof require&&require;if(!g&&k)return k(e,!0);if(c)return c(e,!0);g=Error("Cannot find module '"+e+"'");throw g.code="MODULE_NOT_FOUND",g;}g=d[e]={exports:{}};h[e][0].call(g.exports,function(a){return f(h[e][1][a]||a)},g,g.exports,b,h,d,a)}return d[e].exports}for(var c="function"==typeof require&&require,e=0;e<a.length;e++)f(a[e]);return f}return b})()({1:[function(b,h,d){(function(a,d){var c=b("fflate");a.NrrdLoader3D=
function(){a.Loader3D.call(this);this.imgBufferArray=null};a.NrrdLoader3D.prototype=Object.create(a.Loader3D.prototype);a.NrrdLoader3D.prototype.constructor=a.NrrdLoader3D;a.NrrdLoader3D.prototype.getImageDims=function(a){return $jscomp.asyncExecutePromiseGeneratorProgram(function(b){return b.return(new Promise(function(b,c){try{var d=new FileReader;d.onerror=function(a){c(a)};d.onload=function(){try{var a=null,e=0,f=null,g=new Uint8Array(d.result.slice(0,Math.pow(2,24)));for(e=1;e<g.length;e++)if(10==
g[e-1]&&10==g[e]){a=(new TextDecoder).decode(g.subarray(0,e-2));break}a||c("Could not find header.");var k=a.split(/\r?\n/);for(e=0;e<k.length;e++){var l=k[e];if(!l.match(/^#/)&&(f=l.match(/(.*):(.*)/))&&"sizes"==f[1].trim()){var m=f[2].trim().split(/\s+/).map(function(a){return parseInt(a,10)});b(m);return}}c("Could not find image dimensions in header.")}catch(t){c(t)}};a instanceof FileSystemFileHandle?a.getFile().then(function(a){d.readAsArrayBuffer(a)}).catch(function(a){c(a)}):d.readAsArrayBuffer(a)}catch(n){c(n)}}))})};
a.NrrdLoader3D.prototype.loadImagesIntoVolume=function(a,b,c,d){var e=[];Array.prototype.push.apply(e,a);this.vol=b;this.warnings=this.errors=null;this.done=!1;this.loadCompleteCb=c;this.loadProgressCb=d;if(e&&e.length)if(e.some(function(a){return!(a instanceof FileSystemFileHandle)&&!(a instanceof File)}))this.done=!0,this.errors="NrrdLoader3D: Invalid item in file list.",this.loadCompleteCb&&this.loadCompleteCb(this);else{var f=new FileReader;f.onload=function(){this._onImageDataLoaded(f)}.bind(this);
f.onerror=function(){this._onImageLoadingError(f)}.bind(this);this.loadProgressCb&&this.loadProgressCb(0,1);a=e[0];a instanceof FileSystemFileHandle?a.getFile().then(function(a){f.readAsArrayBuffer(a)}).catch(function(a){this._onImageLoadingError(f)}.bind(this)):f.readAsArrayBuffer(a)}else this.done=!0,this.warnings="NrrdLoader3D: No files were loaded, because the supplied file list was empty.",this.loadCompleteCb&&this.loadCompleteCb(this)};a.NrrdLoader3D.prototype._onImageLoadingError=function(a){this.cancelled||
this.done||(this.done=!0,this.errors="Error loading image file "+(a.fileName||""),this.loadCompleteCb&&this.loadCompleteCb(this))};a.NrrdLoader3D.prototype._onImageDataLoaded=function(a){var b=this,d,e,f,h,p,r,q,u,x,z,t,y,I,H,Q,K,B,J,U,M,ha,ea,X,O,F,W,L,R,N,na;return $jscomp.asyncExecutePromiseGeneratorProgram(function(g){switch(g.nextAddress){case 1:if(b.cancelled)return g.return();g.setCatchFinallyBlocks(2);f=new Uint8Array(a.result);h=null;for(d=1;d<f.length;d++)if(10==f[d-1]&&10==f[d]){h=(new TextDecoder).decode(f.subarray(0,
d-2));break}if(!h)return b.done=!0,b.errors="Nrrd header not found.",b.loadCompleteCb&&b.loadCompleteCb(b),g.return();p=d+1;r=-1;q=0;u=-1;x="raw";z="little";t=[1,1,1];y=[[1,0,0],[0,1,0],[0,0,1]];I=[0,0,0];H=!1;Q=h.split(/\r?\n/);for(d=0;d<Q.length;d++)if(K=Q[d],K.match(/NRRD\d+/))H=!0;else if(!K.match(/^#/)&&(e=K.match(/(.*):(.*)/)))switch(B=e[1].trim(),J=e[2].trim(),B){case "type":U=$jscomp.makeIterator(b._interpretPixelType(J));r=U.next().value;U.next();q=U.next().value;break;case "dimension":u=
parseInt(J,10);break;case "sizes":M=J.split(/\s+/);t=M.map(function(a){return parseInt(a,10)});break;case "space directions":ha=J.match(/\(.*?\)/g);y=ha.map(function(a){return a.slice(1,-1).split(/,/).map(function(a){return parseFloat(a)})});break;case "spacings":M=J.split(/\s+/);M.map(function(a){return parseFloat(a)});break;case "space origin":I=J.split("(")[1].split(")")[0].split(",");I=I.map(function(a){return parseFloat(a)});break;case "encoding":x=J;break;case "endian":z=J}if(!H)return b.done=
!0,b.errors="Not a valid nrrd file.",b.loadCompleteCb&&b.loadCompleteCb(b),g.return();if(0>r||8!=r&&16!=r||2!=u&&3!=u)return b.done=!0,b.errors="Unsupported data type",b.loadCompleteCb&&b.loadCompleteCb(b),g.return();2==u&&(t=[t[0],t[1],1],y=[[y[0][0],y[0][1],0],[y[1][0],y[1][1],0],[0,0,1]],I=[I[0],I[1],0]);b.errors=b.vol.loadBegin(t,r,z);if(b.errors)return b.done=!0,b.loadCompleteCb&&b.loadCompleteCb(b),g.return();ea=f.subarray(p);X="raw"==x?ea:c.decompressSync(ea);O=8==r?X:new Uint16Array(X.buffer);
b.vol.setAttr("modality","nrrd");b.vol.setAttr("rescaleSlope",1);b.vol.setAttr("rescaleIntercept",0);b.vol.setAttr("dataOffset",q);b.vol.setAttr("sliceGap",1);b.vol.setAttr("rowDir",y[0]);b.vol.setAttr("colDir",y[1]);b.vol.calcNearLphAxes();F=t[2];W=t[0]*t[1];b.imgBufferArray=Array(4);L=8==r?4:2;R=0;case 4:if(!(R<F)){g.leaveTryBlock(0);break}L=Math.min(L,b.vol.dims[2]-R);N={startIndex:R,endIndex:R+L,numLeftToLoad:L,imgBuffers:b.imgBufferArray};d=0;case 7:if(!(d<L)){g.jumpTo(9);break}na=N.startIndex+
d;N.imgBuffers[d]=O.slice(na*W,(na+1)*W).buffer;N.numLeftToLoad--;if(0===N.numLeftToLoad&&(b._copyImagesToTexture(N),N.endIndex==b.vol.dims[2]&&!b.done))return b.vol.loadEnd(),b.done=!0,b.loadCompleteCb&&b.loadCompleteCb(b),g.return();if(!b.loadProgressCb){g.jumpTo(8);break}b.loadProgressCb(N.endIndex-N.numLeftToLoad,b.vol.dims[2]);return g.yield(new Promise(function(a){return setTimeout(a,5)}),11);case 11:if(b.cancelled)return g.return();case 8:d++;g.jumpTo(7);break;case 9:R+=L;g.jumpTo(4);break;
case 2:g.enterCatchBlock(),b._onImageLoadingError(a),g.jumpToEnd()}})};a.NrrdLoader3D.prototype._interpretPixelType=function(a){var b=-1,c=!1,d=0;switch(a){case "uchar":case "unsigned char":case "uint8":case "uint8_t":b=8;break;case "signed char":case "int8":case "int8_t":b=8;c=!0;d=Math.pow(2,b-1);break;case "ushort":case "unsigned short":case "unsigned short int":case "uint16":case "uint16_t":b=16;break;case "short":case "short int":case "signed short":case "signed short int":case "int16":case "int16_t":b=
16;c=!0;d=Math.pow(2,b-1);break;case "uint":case "unsigned int":case "uint32":case "uint32_t":b=32;break;case "int":case "signed int":case "int32":case "int32_t":b=32,c=!0,d=Math.pow(2,b-1)}return[b,c,d]}})(window.BigLime=window.BigLime||{})},{fflate:2}],2:[function(b,h,d){function a(a,b){"function"==typeof a&&(b=a,a={});this.ondata=b;return a}function f(a,b,d){d||(d=b,b={});"function"!=typeof d&&w(7);return oa(a,b,[pa],function(a){return ia(c(a.data[0],a.data[1]))},0,d)}function c(a,b){return la(a,
b||{},0,0)}function e(a,b,c){c||(c=b,b={});"function"!=typeof c&&w(7);return oa(a,b,[qa],function(a){return ia(k(a.data[0],Ka(a.data[1])))},1,c)}function k(a,b){return xa(a,{i:2},b&&b.out,b&&b.dictionary)}function g(a,b,c){c||(c=b,b={});"function"!=typeof c&&w(7);return oa(a,b,[pa,cb,function(){return[l]}],function(a){return ia(l(a.data[0],a.data[1]))},2,c)}function l(a,b){b||(b={});var c=ra(),d=a.length;c.p(a);a=la(a,b,La(b),8);var e=a.length;return Ma(a,b),E(a,e-8,c.d()),E(a,e-4,d),a}function m(a,
b,c){c||(c=b,b={});"function"!=typeof c&&w(7);return oa(a,b,[qa,db,function(){return[n]}],function(a){return ia(n(a.data[0],a.data[1]))},3,c)}function n(a,b){var c=Na(a);c+8>a.length&&w(6,"invalid gzip data");return xa(a.subarray(c,-8),{i:2},b&&b.out||new t(eb(a)),b&&b.dictionary)}function p(a,b){b||(b={});var c=Aa();c.p(a);a=la(a,b,b.dictionary?6:2,4);return Oa(a,b),E(a,a.length-4,c.d()),a}function r(a,b,c){c||(c=b,b={});"function"!=typeof c&&w(7);return oa(a,b,[qa,fb,function(){return[q]}],function(a){return ia(q(a.data[0],
Ka(a.data[1])))},5,c)}function q(a,b){return xa(a.subarray(Pa(a,b&&b.dictionary),-4),{i:2},b&&b.out,b&&b.dictionary)}function u(a,b){if(b){b=new t(a.length);for(var c=0;c<a.length;++c)b[c]=a.charCodeAt(c);return b}if(gb)return gb.encode(a);var d=a.length,e=new t(a.length+(a.length>>1)),f=0,v=function(a){e[f++]=a};for(c=0;c<d;++c){if(f+5>e.length){var g=new t(f+8+(d-c<<1));g.set(e);e=g}g=a.charCodeAt(c);128>g||b?v(g):(2048>g?v(192|g>>6):55295<g&&57344>g?(g=65536+(g&1047552)|a.charCodeAt(++c)&1023,
v(240|g>>18),v(128|g>>12&63),v(128|g>>6&63)):(v(224|g>>12),v(128|g>>6&63)),v(128|g&63))}return Z(e,0,f)}function x(a,b){if(b){b="";for(var c=0;c<a.length;c+=16384)b+=String.fromCharCode.apply(null,a.subarray(c,c+16384));return b}if(Qa)return Qa.decode(a);b=hb(a);a=b.s;b=b.r;b.length&&w(8);return a}var z=b("./node-worker.cjs"),t=Uint8Array,y=Uint16Array,I=Int32Array,H=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Q=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,
11,11,12,12,13,13,0,0]),K=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),B=function(a,b){for(var c=new y(31),d=0;31>d;++d)c[d]=b+=1<<a[d-1];a=new I(c[30]);for(d=1;30>d;++d)for(b=c[d];b<c[d+1];++b)a[b]=b-c[d]<<5|d;return{b:c,r:a}},J=B(H,2),U=J.b,M=J.r;U[28]=258;M[258]=28;for(var ha=B(Q,0),ea=ha.b,X=ha.r,O=new y(32768),F=0;32768>F;++F){var W=(F&43690)>>1|(F&21845)<<1;W=(W&52428)>>2|(W&13107)<<2;W=(W&61680)>>4|(W&3855)<<4;O[F]=((W&65280)>>8|(W&255)<<8)>>1}var L=function(a,b,c){for(var d=a.length,
e=0,f=new y(b);e<d;++e)a[e]&&++f[a[e]-1];var v=new y(b);for(e=1;e<b;++e)v[e]=v[e-1]+f[e-1]<<1;if(c)for(c=new y(1<<b),f=15-b,e=0;e<d;++e){if(a[e]){var g=e<<4|a[e],k=b-a[e],A=v[a[e]-1]++<<k;for(k=A|(1<<k)-1;A<=k;++A)c[O[A]>>f]=g}}else for(c=new y(d),e=0;e<d;++e)a[e]&&(c[e]=O[v[a[e]-1]++]>>15-a[e]);return c},R=new t(288);for(F=0;144>F;++F)R[F]=8;for(F=144;256>F;++F)R[F]=9;for(F=256;280>F;++F)R[F]=7;for(F=280;288>F;++F)R[F]=8;var N=new t(32);for(F=0;32>F;++F)N[F]=5;var na=L(R,9,0),$a=L(R,9,1),ab=L(N,
5,0),bb=L(N,5,1),Ba=function(a){for(var b=a[0],c=1;c<a.length;++c)a[c]>b&&(b=a[c]);return b},aa=function(a,b,c){var d=b/8|0;return(a[d]|a[d+1]<<8)>>(b&7)&c},Ca=function(a,b){var c=b/8|0;return(a[c]|a[c+1]<<8|a[c+2]<<16)>>(b&7)},sa=function(a){return(a+7)/8|0},Z=function(a,b,c){if(null==b||0>b)b=0;if(null==c||c>a.length)c=a.length;return new t(a.subarray(b,c))};d.FlateErrorCode={UnexpectedEOF:0,InvalidBlockType:1,InvalidLengthLiteral:2,InvalidDistance:3,StreamFinished:4,NoStreamHandler:5,InvalidHeader:6,
NoCallback:7,InvalidUTF8:8,ExtraFieldTooLong:9,InvalidDate:10,FilenameTooLong:11,StreamFinishing:12,InvalidZipData:13,UnknownCompressionMethod:14};var ib=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],w=function(a,b,c){b=Error(b||ib[a]);b.code=a;Error.captureStackTrace&&Error.captureStackTrace(b,
w);if(!c)throw b;return b},xa=function(a,b,c,d){var e=a.length,f=d?d.length:0;if(!e||b.f&&!b.l)return c||new t(0);var g=!c,v=g||2!=b.i,k=b.i;g&&(c=new t(3*e));var A=function(a){var b=c.length;a>b&&(a=new t(Math.max(2*b,a)),a.set(c),c=a)},V=b.f||0,l=b.p||0,m=b.b||0,h=b.l,n=b.d,P=b.m,p=b.n,q=8*e;do{if(!h){V=aa(a,l,1);var C=aa(a,l+1,3);l+=3;if(C)if(1==C)h=$a,n=bb,P=9,p=5;else if(2==C){P=aa(a,l,31)+257;n=aa(a,l+10,15)+4;h=P+aa(a,l+5,31)+1;l+=14;p=new t(h);var r=new t(19);for(C=0;C<n;++C)r[K[C]]=aa(a,
l+3*C,7);l+=3*n;C=Ba(r);n=(1<<C)-1;var u=L(r,C,1);for(C=0;C<h;)if(r=u[aa(a,l,n)],l+=r&15,r>>=4,16>r)p[C++]=r;else{var y=0,z=0;16==r?(z=3+aa(a,l,3),l+=2,y=p[C-1]):17==r?(z=3+aa(a,l,7),l+=3):18==r&&(z=11+aa(a,l,127),l+=7);for(;z--;)p[C++]=y}h=p.subarray(0,P);C=p.subarray(P);P=Ba(h);p=Ba(C);h=L(h,P,1);n=L(C,p,1)}else w(1);else{r=sa(l)+4;l=a[r-4]|a[r-3]<<8;C=r+l;if(C>e){k&&w(0);break}v&&A(m+l);c.set(a.subarray(r,C),m);b.b=m+=l;b.p=l=8*C;b.f=V;continue}if(l>q){k&&w(0);break}}v&&A(m+131072);r=(1<<P)-1;
u=(1<<p)-1;for(z=l;;z=l){y=h[Ca(a,l)&r];C=y>>4;l+=y&15;if(l>q){k&&w(0);break}y||w(2);if(256>C)c[m++]=C;else if(256==C){z=l;h=null;break}else{y=C-254;if(264<C){C-=257;var x=H[C];y=aa(a,l,(1<<x)-1)+U[C];l+=x}C=n[Ca(a,l)&u];x=C>>4;C||w(3);l+=C&15;C=ea[x];3<x&&(x=Q[x],C+=Ca(a,l)&(1<<x)-1,l+=x);if(l>q){k&&w(0);break}v&&A(m+131072);y=m+y;if(m<C)for(z=f-C,x=Math.min(C,y),0>z+m&&w(3);m<x;++m)c[m]=d[z+m];for(;m<y;++m)c[m]=c[m-C]}}b.l=h;b.p=z;b.b=m;b.f=V;h&&(V=1,b.m=P,b.d=n,b.n=p)}while(!V);return m!=c.length&&
g?Z(c,0,m):c.subarray(0,m)},fa=function(a,b,c){c<<=b&7;b=b/8|0;a[b]|=c;a[b+1]|=c>>8},ta=function(a,b,c){c<<=b&7;b=b/8|0;a[b]|=c;a[b+1]|=c>>8;a[b+2]|=c>>16},Ea=function(a,b){for(var c=[],d=0;d<a.length;++d)a[d]&&c.push({s:d,f:a[d]});var e=c.length;a=c.slice();if(!e)return{t:ja,l:0};if(1==e)return b=new t(c[0].s+1),b[c[0].s]=1,{t:b,l:1};c.sort(function(a,b){return a.f-b.f});c.push({s:-1,f:25001});d=c[0];var f=c[1],g=0,v=1,k=2;for(c[0]={s:-1,f:d.f+f.f,l:d,r:f};v!=e-1;)d=c[c[g].f<c[k].f?g++:k++],f=c[g!=
v&&c[g].f<c[k].f?g++:k++],c[v++]={s:-1,f:d.f+f.f,l:d,r:f};f=a[0].s;for(d=1;d<e;++d)a[d].s>f&&(f=a[d].s);var A=new y(f+1);v=Da(c[v-1],A,0);if(v>b){c=d=0;f=v-b;g=1<<f;for(a.sort(function(a,b){return A[b.s]-A[a.s]||a.f-b.f});d<e;++d)if(k=a[d].s,A[k]>b)c+=g-(1<<v-A[k]),A[k]=b;else break;for(c>>=f;0<c;)e=a[d].s,A[e]<b?c-=1<<b-A[e]++-1:++d;for(;0<=d&&c;--d)e=a[d].s,A[e]==b&&(--A[e],++c);v=b}return{t:new t(A),l:v}},Da=function(a,b,c){return-1==a.s?Math.max(Da(a.l,b,c+1),Da(a.r,b,c+1)):b[a.s]=c},Ra=function(a){for(var b=
a.length;b&&!a[--b];);for(var c=new y(++b),d=0,e=a[0],f=1,g=function(a){c[d++]=a},k=1;k<=b;++k)if(a[k]==e&&k!=b)++f;else{if(!e&&2<f){for(;138<f;f-=138)g(32754);2<f&&(g(10<f?f-11<<5|28690:f-3<<5|12305),f=0)}else if(3<f){g(e);for(--f;6<f;f-=6)g(8304);2<f&&(g(f-3<<5|8208),f=0)}for(;f--;)g(e);f=1;e=a[k]}return{c:c.subarray(0,d),n:b}},ua=function(a,b){for(var c=0,d=0;d<b.length;++d)c+=a[d]*b[d];return c},Sa=function(a,b,c){var d=c.length;b=sa(b+2);a[b]=d&255;a[b+1]=d>>8;a[b+2]=a[b]^255;a[b+3]=a[b+1]^255;
for(var e=0;e<d;++e)a[b+e+4]=c[e];return 8*(b+4+d)},Ta=function(a,b,c,d,e,f,g,k,l,m,h){fa(b,h++,c);++e[256];c=Ea(e,15);var v=c.t,A=c.l;c=Ea(f,15);var V=c.t,n=c.l;c=Ra(v);var p=c.c,P=c.n;c=Ra(V);for(var q=c.c,Y=c.n,ma=new y(19),G=0;G<p.length;++G)++ma[p[G]&31];for(G=0;G<q.length;++G)++ma[q[G]&31];G=Ea(ma,7);c=G.t;G=G.l;for(var da=19;4<da&&!c[K[da-1]];--da);var r=m+5<<3,t=ua(e,R)+ua(f,N)+g;e=ua(e,v)+ua(f,V)+g+14+3*da+ua(ma,c)+2*ma[16]+3*ma[17]+7*ma[18];if(0<=l&&r<=t&&r<=e)return Sa(b,h,a.subarray(l,
l+m));fa(b,h,1+(e<t));h+=2;if(e<t){a=L(v,A,0);l=v;m=L(V,n,0);v=L(c,G,0);fa(b,h,P-257);fa(b,h+5,Y-1);fa(b,h+10,da-4);h+=14;for(G=0;G<da;++G)fa(b,h+3*G,c[K[G]]);h+=3*da;P=[p,q];for(q=0;2>q;++q)for(Y=P[q],G=0;G<Y.length;++G)p=Y[G]&31,fa(b,h,v[p]),h+=c[p],15<p&&(fa(b,h,Y[G]>>5&127),h+=Y[G]>>12)}else a=na,l=R,m=ab,V=N;for(G=0;G<k;++G)c=d[G],255<c?(p=c>>18&31,ta(b,h,a[p+257]),h+=l[p+257],7<p&&(fa(b,h,c>>23&31),h+=H[p]),p=c&31,ta(b,h,m[p]),h+=V[p],3<p&&(ta(b,h,c>>5&8191),h+=Q[p])):(ta(b,h,a[c]),h+=l[c]);
ta(b,h,a[256]);return h+l[256]},jb=new I([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),ja=new t(0),kb=function(a,b,c,d,e,f){var g=f.z||a.length,k=new t(d+g+5*(1+Math.ceil(g/7E3))+e),v=k.subarray(d,k.length-e),l=f.l,A=(f.r||0)&7;if(b){A&&(v[0]=f.r>>3);var m=jb[b-1];b=m>>13;m&=8191;var V=(1<<c)-1,h=f.p||new y(32768),n=f.h||new y(V+1),p=Math.ceil(c/3),P=2*p,G=function(b){return(a[b]^a[b+1]<<p^a[b+2]<<P)&V},q=new I(25E3),Y=new y(288),r=new y(32),u=0,z=0;c=f.i||0;for(var x=0,w=f.w||
0,B=0;c+2<g;++c){var E=G(c),K=c&32767,F=n[E];h[K]=F;n[E]=K;if(w<=c){var J=g-c;if((7E3<u||24576<x)&&(423<J||!l)){A=Ta(a,v,0,q,Y,r,z,x,B,c-B,A);x=u=z=0;B=c;for(var D=0;286>D;++D)Y[D]=0;for(D=0;30>D;++D)r[D]=0}var L=2,O=0,R=m,N=K-F&32767;if(2<J&&E==G(c-N)){E=Math.min(b,J)-1;var U=Math.min(32767,c);for(J=Math.min(258,J);N<=U&&--R&&K!=F;){if(a[c+L]==a[c+L-N]){for(D=0;D<J&&a[c+D]==a[c+D-N];++D);if(D>L){L=D;O=N;if(D>E)break;K=Math.min(N,D-2);var S=0;for(D=0;D<K;++D){var T=c-N+D&32767,W=T-h[T]&32767;W>S&&
(S=W,F=T)}}}K=F;F=h[K];N+=K-F&32767}}O?(q[x++]=268435456|M[L]<<18|X[O],w=M[L]&31,O=X[O]&31,z+=H[w]+Q[O],++Y[257+w],++r[O],w=c+L,++u):(q[x++]=a[c],++Y[a[c]])}}for(c=Math.max(c,w);c<g;++c)q[x++]=a[c],++Y[a[c]];A=Ta(a,v,l,q,Y,r,z,x,B,c-B,A);l||(f.r=A&7|v[A/8|0]<<3,A-=7,f.h=n,f.p=h,f.i=c,f.w=w)}else{for(c=f.w||0;c<g+l;c+=65535)b=c+65535,b>=g&&(v[A/8|0]=l,b=g),A=Sa(v,A+1,a.subarray(c,b));f.i=g}return Z(k,0,d+sa(A)+e)},lb=function(){for(var a=new Int32Array(256),b=0;256>b;++b){for(var c=b,d=9;--d;)c=(c&
1&&-306674912)^c>>>1;a[b]=c}return a}(),ra=function(){var a=-1;return{p:function(b){for(var c=a,d=0;d<b.length;++d)c=lb[c&255^b[d]]^c>>>8;a=c},d:function(){return~a}}},Aa=function(){var a=1,b=0;return{p:function(c){for(var d=a,e=b,f=c.length|0,g=0;g!=f;){for(var k=Math.min(g+2655,f);g<k;++g)e+=d+=c[g];d=(d&65535)+15*(d>>16);e=(e&65535)+15*(e>>16)}a=d;b=e},d:function(){a%=65521;b%=65521;return(a&255)<<24|(a&65280)<<8|(b&255)<<8|b>>8}}},la=function(a,b,c,d,e){if(!e&&(e={l:1},b.dictionary)){var f=b.dictionary.subarray(-32768),
g=new t(f.length+a.length);g.set(f);g.set(a,f.length);a=g;e.w=f.length}return kb(a,null==b.level?6:b.level,null==b.mem?e.l?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(a.length)))):20:12+b.mem,c,d,e)},ya=function(a,b){var c={},d;for(d in a)c[d]=a[d];for(d in b)c[d]=b[d];return c},mb=function(a,b,c){var d=a();a=a.toString();a=a.slice(a.indexOf("[")+1,a.lastIndexOf("]")).replace(/\s+/g,"").split(",");for(var e=0;e<d.length;++e){var f=d[e],g=a[e];if("function"==typeof f){b+=";"+g+"=";var k=f.toString();
if(f.prototype)if(-1!=k.indexOf("[native code]"))f=k.indexOf(" ",8)+1,b+=k.slice(f,k.indexOf("(",f));else{b+=k;for(var v in f.prototype)b+=";"+g+".prototype."+v+"="+f.prototype[v].toString()}else b+=k}else c[g]=f}return b},Fa=[],nb=function(a,b,c,d){if(!Fa[c]){for(var e="",f={},g=a.length-1,k=0;k<g;++k)e=mb(a[k],e,f);Fa[c]={c:mb(a[g],e,f),e:f}}a=ya({},Fa[c].e);e=(0,z.default);b=Fa[c].c+";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage="+b.toString()+"}";f=[];for(var v in a)a[v].buffer&&
f.push((a[v]=new a[v].constructor(a[v])).buffer);return e(b,c,a,f,d)},qa=function(){return[t,y,I,H,Q,K,U,ea,$a,bb,O,ib,L,Ba,aa,Ca,sa,Z,w,xa,k,ia,Ka]},pa=function(){return[t,y,I,H,Q,K,M,X,na,R,ab,N,O,jb,ja,L,fa,ta,Ea,Da,Ra,ua,Sa,Ta,sa,Z,kb,la,c,ia]},cb=function(){return[Ma,La,E,ra,lb]},db=function(){return[Na,eb]},ob=function(){return[Oa,E,Aa]},fb=function(){return[Pa]},ia=function(a){return postMessage(a,[a.buffer])},Ka=function(a){return a&&{out:a.size&&new t(a.size),dictionary:a.dictionary}},oa=
function(a,b,c,d,e,f){var g=nb(c,d,e,function(a,b){g.terminate();f(a,b)});g.postMessage([a,b],b.consume?[a.buffer]:[]);return function(){g.terminate()}},ba=function(a){a.ondata=function(a,b){return postMessage([a,b],[a.buffer])};return function(b){b.data.length?(a.push(b.data[0],b.data[1]),postMessage([b.data[0].length])):a.flush()}},va=function(a,b,c,d,e,f,g){var k,v=nb(a,d,e,function(a,c){if(a)v.terminate(),b.ondata.call(b,a);else if(Array.isArray(c))if(1==c.length){if(b.queuedSize-=c[0],b.ondrain)b.ondrain(c[0])}else c[1]&&
v.terminate(),b.ondata.call(b,a,c[0],c[1]);else g(c)});v.postMessage(c);b.queuedSize=0;b.push=function(a,c){b.ondata||w(5);if(k)b.ondata(w(4,0,1),null,!!c);b.queuedSize+=a.length;v.postMessage([a,k=c],[a.buffer])};b.terminate=function(){v.terminate()};f&&(b.flush=function(){v.postMessage([])})},S=function(a,b){return a[b]|a[b+1]<<8},D=function(a,b){return(a[b]|a[b+1]<<8|a[b+2]<<16|a[b+3]<<24)>>>0},Ua=function(a,b){return D(a,b)+4294967296*D(a,b+4)},E=function(a,b,c){for(;c;++b)a[b]=c,c>>>=8},Ma=function(a,
b){var c=b.filename;a[0]=31;a[1]=139;a[2]=8;a[8]=2>b.level?4:9==b.level?2:0;a[9]=3;0!=b.mtime&&E(a,4,Math.floor(new Date(b.mtime||Date.now())/1E3));if(c)for(a[3]=8,b=0;b<=c.length;++b)a[b+10]=c.charCodeAt(b)},Na=function(a){31==a[0]&&139==a[1]&&8==a[2]||w(6,"invalid gzip data");var b=a[3],c=10;b&4&&(c+=(a[10]|a[11]<<8)+2);for(var d=(b>>3&1)+(b>>4&1);0<d;d-=!a[c++]);return c+(b&2)},eb=function(a){var b=a.length;return(a[b-4]|a[b-3]<<8|a[b-2]<<16|a[b-1]<<24)>>>0},La=function(a){return 10+(a.filename?
a.filename.length+1:0)},Oa=function(a,b){var c=b.level;a[0]=120;a[1]=(0==c?0:6>c?1:9==c?3:2)<<6|(b.dictionary&&32);a[1]|=31-(a[0]<<8|a[1])%31;b.dictionary&&(c=Aa(),c.p(b.dictionary),E(a,2,c.d()))},Pa=function(a,b){(8!=(a[0]&15)||7<a[0]>>4||(a[0]<<8|a[1])%31)&&w(6,"invalid zlib data");(a[1]>>5&1)==+!b&&w(6,"invalid zlib data: "+(a[1]&32?"need":"unexpected")+" dictionary");return(a[1]>>3&4)+2},ca=function(){function a(a,b){"function"==typeof a&&(b=a,a={});this.ondata=b;this.o=a||{};this.s={l:0,i:32768,
w:32768,z:32768};this.b=new t(98304);this.o.dictionary&&(a=this.o.dictionary.subarray(-32768),this.b.set(a,32768-a.length),this.s.i=32768-a.length)}a.prototype.p=function(a,b){this.ondata(la(a,this.o,0,0,this.s),b)};a.prototype.push=function(a,b){this.ondata||w(5);this.s.l&&w(4);var c=a.length+this.s.z;c>this.b.length?(c>2*this.b.length-32768&&(c=new t(c&-32768),c.set(this.b.subarray(0,this.s.z)),this.b=c),c=this.b.length-this.s.z,this.b.set(a.subarray(0,c),this.s.z),this.s.z=this.b.length,this.p(this.b,
!1),this.b.set(this.b.subarray(-32768)),this.b.set(a.subarray(c),32768),this.s.z=a.length-c+32768,this.s.i=32766,this.s.w=32768):(this.b.set(a,this.s.z),this.s.z+=a.length);this.s.l=b&1;if(this.s.z>this.s.w+8191||b)this.p(this.b,b||!1),this.s.w=this.s.i,this.s.i-=2};a.prototype.flush=function(){this.ondata||w(5);this.s.l&&w(4);this.p(this.b,!1);this.s.w=this.s.i;this.s.i-=2};return a}();d.Deflate=ca;var pb=function(){return function(b,c){va([pa,function(){return[ba,ca]}],this,a.call(this,b,c),function(a){a=
new ca(a.data);onmessage=ba(a)},6,1)}}();d.AsyncDeflate=pb;d.deflate=f;d.deflateSync=c;var T=function(){function a(a,b){"function"==typeof a&&(b=a,a={});this.ondata=b;a=a&&a.dictionary&&a.dictionary.subarray(-32768);this.s={i:0,b:a?a.length:0};this.o=new t(32768);this.p=new t(0);a&&this.o.set(a)}a.prototype.e=function(a){this.ondata||w(5);this.d&&w(4);if(!this.p.length)this.p=a;else if(a.length){var b=new t(this.p.length+a.length);b.set(this.p);b.set(a,this.p.length);this.p=b}};a.prototype.c=function(a){this.s.i=
+(this.d=a||!1);a=this.s.b;var b=xa(this.p,this.s,this.o);this.ondata(Z(b,a,this.s.b),this.d);this.o=Z(b,this.s.b-32768);this.s.b=this.o.length;this.p=Z(this.p,this.s.p/8|0);this.s.p&=7};a.prototype.push=function(a,b){this.e(a);this.c(b)};return a}();d.Inflate=T;var Va=function(){return function(b,c){va([qa,function(){return[ba,T]}],this,a.call(this,b,c),function(a){a=new T(a.data);onmessage=ba(a)},7,0)}}();d.AsyncInflate=Va;d.inflate=e;d.inflateSync=k;var Ga=function(){function a(a,b){this.c=ra();
this.l=0;this.v=1;ca.call(this,a,b)}a.prototype.push=function(a,b){this.c.p(a);this.l+=a.length;ca.prototype.push.call(this,a,b)};a.prototype.p=function(a,b){a=la(a,this.o,this.v&&La(this.o),b&&8,this.s);this.v&&(Ma(a,this.o),this.v=0);b&&(E(a,a.length-8,this.c.d()),E(a,a.length-4,this.l));this.ondata(a,b)};a.prototype.flush=function(){ca.prototype.flush.call(this)};return a}();d.Gzip=Ga;d.Compress=Ga;var qb=function(){return function(b,c){va([pa,cb,function(){return[ba,ca,Ga]}],this,a.call(this,
b,c),function(a){a=new Ga(a.data);onmessage=ba(a)},8,1)}}();d.AsyncGzip=qb;d.AsyncCompress=qb;d.gzip=g;d.compress=g;d.gzipSync=l;d.compressSync=l;var Ha=function(){function a(a,b){this.v=1;this.r=0;T.call(this,a,b)}a.prototype.push=function(a,b){T.prototype.e.call(this,a);this.r+=a.length;if(this.v){a=this.p.subarray(this.v-1);var c=3<a.length?Na(a):4;if(c>a.length){if(!b)return}else if(1<this.v&&this.onmember)this.onmember(this.r-a.length);this.p=a.subarray(c);this.v=0}T.prototype.c.call(this,b);
!this.s.f||this.s.l||b||(this.v=sa(this.s.p)+9,this.s={i:0},this.o=new t(0),this.push(new t(0),b))};return a}();d.Gunzip=Ha;var rb=function(){return function(b,c){var d=this;va([qa,db,function(){return[ba,T,Ha]}],this,a.call(this,b,c),function(a){a=new Ha(a.data);a.onmember=function(a){return postMessage(a)};onmessage=ba(a)},9,0,function(a){return d.onmember&&d.onmember(a)})}}();d.AsyncGunzip=rb;d.gunzip=m;d.gunzipSync=n;var Wa=function(){function a(a,b){this.c=Aa();this.v=1;ca.call(this,a,b)}a.prototype.push=
function(a,b){this.c.p(a);ca.prototype.push.call(this,a,b)};a.prototype.p=function(a,b){a=la(a,this.o,this.v&&(this.o.dictionary?6:2),b&&4,this.s);this.v&&(Oa(a,this.o),this.v=0);b&&E(a,a.length-4,this.c.d());this.ondata(a,b)};a.prototype.flush=function(){ca.prototype.flush.call(this)};return a}();d.Zlib=Wa;var Cb=function(){return function(b,c){va([pa,ob,function(){return[ba,ca,Wa]}],this,a.call(this,b,c),function(a){a=new Wa(a.data);onmessage=ba(a)},10,1)}}();d.AsyncZlib=Cb;d.zlib=function(a,b,
c){c||(c=b,b={});"function"!=typeof c&&w(7);return oa(a,b,[pa,ob,function(){return[p]}],function(a){return ia(p(a.data[0],a.data[1]))},4,c)};d.zlibSync=p;var Ia=function(){function a(a,b){T.call(this,a,b);this.v=a&&a.dictionary?2:1}a.prototype.push=function(a,b){T.prototype.e.call(this,a);if(this.v){if(6>this.p.length&&!b)return;this.p=this.p.subarray(Pa(this.p,this.v-1));this.v=0}b&&(4>this.p.length&&w(6,"invalid zlib data"),this.p=this.p.subarray(0,-4));T.prototype.c.call(this,b)};return a}();d.Unzlib=
Ia;var sb=function(){return function(b,c){va([qa,fb,function(){return[ba,T,Ia]}],this,a.call(this,b,c),function(a){a=new Ia(a.data);onmessage=ba(a)},11,0)}}();d.AsyncUnzlib=sb;d.unzlib=r;d.unzlibSync=q;var Xa=function(){function b(b,c){this.o=a.call(this,b,c)||{};this.G=Ha;this.I=T;this.Z=Ia}b.prototype.i=function(){var a=this;this.s.ondata=function(b,c){a.ondata(b,c)}};b.prototype.push=function(a,b){this.ondata||w(5);if(this.s)this.s.push(a,b);else{if(this.p&&this.p.length){var c=new t(this.p.length+
a.length);c.set(this.p);c.set(a,this.p.length)}else this.p=a;2<this.p.length&&(this.s=31==this.p[0]&&139==this.p[1]&&8==this.p[2]?new this.G(this.o):8!=(this.p[0]&15)||7<this.p[0]>>4||(this.p[0]<<8|this.p[1])%31?new this.I(this.o):new this.Z(this.o),this.i(),this.s.push(this.p,b),this.p=null)}};return b}();d.Decompress=Xa;var Db=function(){function a(a,b){Xa.call(this,a,b);this.queuedSize=0;this.G=rb;this.I=Va;this.Z=sb}a.prototype.i=function(){var a=this;this.s.ondata=function(b,c,d){a.ondata(b,
c,d)};this.s.ondrain=function(b){a.queuedSize-=b;if(a.ondrain)a.ondrain(b)}};a.prototype.push=function(a,b){this.queuedSize+=a.length;Xa.prototype.push.call(this,a,b)};return a}();d.AsyncDecompress=Db;d.decompress=function(a,b,c){c||(c=b,b={});"function"!=typeof c&&w(7);return 31==a[0]&&139==a[1]&&8==a[2]?m(a,b,c):8!=(a[0]&15)||7<a[0]>>4||(a[0]<<8|a[1])%31?e(a,b,c):r(a,b,c)};d.decompressSync=function(a,b){return 31==a[0]&&139==a[1]&&8==a[2]?n(a,b):8!=(a[0]&15)||7<a[0]>>4||(a[0]<<8|a[1])%31?k(a,b):
q(a,b)};var Ya=function(a,b,c,d){for(var e in a){var f=a[e],g=b+e,k=d;Array.isArray(f)&&(k=ya(d,f[1]),f=f[0]);f instanceof t?c[g]=[f,k]:(c[g+="/"]=[new t(0),k],Ya(f,g,c,d))}},gb="undefined"!=typeof TextEncoder&&new TextEncoder,Qa="undefined"!=typeof TextDecoder&&new TextDecoder,tb=0;try{Qa.decode(ja,{stream:!0}),tb=1}catch(A){}var hb=function(a){for(var b="",c=0;;){var d=a[c++],e=(127<d)+(223<d)+(239<d);if(c+e>a.length)return{s:b,r:Z(a,c-1)};e?3==e?(d=((d&15)<<18|(a[c++]&63)<<12|(a[c++]&63)<<6|a[c++]&
63)-65536,b+=String.fromCharCode(55296|d>>10,56320|d&1023)):b=e&1?b+String.fromCharCode((d&31)<<6|a[c++]&63):b+String.fromCharCode((d&15)<<12|(a[c++]&63)<<6|a[c++]&63):b+=String.fromCharCode(d)}},Eb=function(){function a(a){this.ondata=a;tb?this.t=new TextDecoder:this.p=ja}a.prototype.push=function(a,b){this.ondata||w(5);b=!!b;if(this.t)this.ondata(this.t.decode(a,{stream:!0}),b),b&&(this.t.decode().length&&w(8),this.t=null);else{this.p||w(4);var c=new t(this.p.length+a.length);c.set(this.p);c.set(a,
this.p.length);c=hb(c);a=c.s;c=c.r;b?(c.length&&w(8),this.p=null):this.p=c;this.ondata(a,b)}};return a}();d.DecodeUTF8=Eb;var Fb=function(){function a(a){this.ondata=a}a.prototype.push=function(a,b){this.ondata||w(5);this.d&&w(4);this.ondata(u(a),this.d=b||!1)};return a}();d.EncodeUTF8=Fb;d.strToU8=u;d.strFromU8=x;var ub=function(a){return 1==a?3:6>a?2:9==a?1:0},vb=function(a,b){return b+30+S(a,b+26)+S(a,b+28)},xb=function(a,b,c){var d=S(a,b+28),e=x(a.subarray(b+46,b+46+d),!(S(a,b+8)&2048));d=b+46+
d;var f=D(a,b+20),g=c&&4294967295==f?wb(a,d):[f,D(a,b+24),D(a,b+42)];c=g[0];f=g[1];g=g[2];return[S(a,b+10),c,f,e,d+S(a,b+30)+S(a,b+32),g]},wb=function(a,b){for(;1!=S(a,b);b+=4+S(a,b+2));return[Ua(a,b+12),Ua(a,b+4),Ua(a,b+20)]},ka=function(a){var b=0;if(a)for(var c in a){var d=a[c].length;65535<d&&w(9);b+=d+4}return b},wa=function(a,b,c,d,e,f,g,k){var l=d.length,m=c.extra,h=k&&k.length,n=ka(m);E(a,b,null!=g?33639248:67324752);b+=4;null!=g&&(a[b++]=20,a[b++]=c.os);a[b]=20;b+=2;a[b++]=c.flag<<1|(0>f&&
8);a[b++]=e&&8;a[b++]=c.compression&255;a[b++]=c.compression>>8;e=new Date(null==c.mtime?Date.now():c.mtime);var p=e.getFullYear()-1980;(0>p||119<p)&&w(10);E(a,b,p<<25|e.getMonth()+1<<21|e.getDate()<<16|e.getHours()<<11|e.getMinutes()<<5|e.getSeconds()>>1);b+=4;-1!=f&&(E(a,b,c.crc),E(a,b+4,0>f?-f-2:f),E(a,b+8,c.size));E(a,b+12,l);E(a,b+14,n);b+=16;null!=g&&(E(a,b,h),E(a,b+6,c.attrs),E(a,b+10,g),b+=14);a.set(d,b);b+=l;if(n)for(var v in m)c=m[v],d=c.length,E(a,b,+v),E(a,b+2,d),a.set(c,b+4),b+=4+d;h&&
(a.set(k,b),b+=h);return b},Za=function(a,b,c,d,e){E(a,b,101010256);E(a,b+8,c);E(a,b+10,c);E(a,b+12,d);E(a,b+16,e)},za=function(){function a(a){this.filename=a;this.c=ra();this.compression=this.size=0}a.prototype.process=function(a,b){this.ondata(null,a,b)};a.prototype.push=function(a,b){this.ondata||w(5);this.c.p(a);this.size+=a.length;b&&(this.crc=this.c.d());this.process(a,b||!1)};return a}();d.ZipPassThrough=za;var Gb=function(){function a(a,b){var c=this;b||(b={});za.call(this,a);this.d=new ca(b,
function(a,b){c.ondata(null,a,b)});this.compression=8;this.flag=ub(b.level)}a.prototype.process=function(a,b){try{this.d.push(a,b)}catch(P){this.ondata(P,null,b)}};a.prototype.push=function(a,b){za.prototype.push.call(this,a,b)};return a}();d.ZipDeflate=Gb;var Hb=function(){function a(a,b){var c=this;b||(b={});za.call(this,a);this.d=new pb(b,function(a,b,d){c.ondata(a,b,d)});this.compression=8;this.flag=ub(b.level);this.terminate=this.d.terminate}a.prototype.process=function(a,b){this.d.push(a,b)};
a.prototype.push=function(a,b){za.prototype.push.call(this,a,b)};return a}();d.AsyncZipDeflate=Hb;var Ib=function(){function a(a){this.ondata=a;this.u=[];this.d=1}a.prototype.add=function(a){var b=this;this.ondata||w(5);if(this.d&2)this.ondata(w(4+8*(this.d&1),0,1),null,!1);else{var c=u(a.filename),d=c.length,e=a.comment,f=e&&u(e);e=d!=a.filename.length||f&&e.length!=f.length;var g=d+ka(a.extra)+30;if(65535<d)this.ondata(w(11,0,1),null,!1);d=new t(g);wa(d,0,a,c,e,-1);var k=[d],l=function(){for(var a=
0,c=k;a<c.length;a++)b.ondata(null,c[a],!1);k=[]},m=this.d;this.d=0;var h=this.u.length,n=ya(a,{f:c,u:e,o:f,t:function(){a.terminate&&a.terminate()},r:function(){l();if(m){var a=b.u[h+1];a?a.r():b.d=1}m=1}}),p=0;a.ondata=function(c,d,e){c?(b.ondata(c,d,e),b.terminate()):(p+=d.length,k.push(d),e?(c=new t(16),E(c,0,134695760),E(c,4,a.crc),E(c,8,p),E(c,12,a.size),k.push(c),n.c=p,n.b=g+p+16,n.crc=a.crc,n.size=a.size,m&&n.r(),m=1):m&&l())};this.u.push(n)}};a.prototype.end=function(){var a=this;if(this.d&
2)this.ondata(w(4+8*(this.d&1),0,1),null,!0);else this.d?this.e():this.u.push({r:function(){a.d&1&&(a.u.splice(-1,1),a.e())},t:function(){}}),this.d=3};a.prototype.e=function(){for(var a=0,b=0,c=0,d=0,e=this.u;d<e.length;d++){var f=e[d];c+=46+f.f.length+ka(f.extra)+(f.o?f.o.length:0)}d=new t(c+22);e=0;for(var g=this.u;e<g.length;e++)f=g[e],wa(d,a,f,f.f,f.u,-f.c-2,b,f.o),a+=46+f.f.length+ka(f.extra)+(f.o?f.o.length:0),b+=f.b;Za(d,a,this.u.length,c,b);this.ondata(null,d,!0);this.d=2};a.prototype.terminate=
function(){for(var a=0,b=this.u;a<b.length;a++)b[a].t();this.d=2};return a}();d.Zip=Ib;d.zip=function(a,b,d){d||(d=b,b={});"function"!=typeof d&&w(7);var e={};Ya(a,"",e,b);var g=Object.keys(e),k=g.length,l=0,m=0,h=k,n=Array(k),p=[],v=function(){for(var a=0;a<p.length;++a)p[a]()},q=function(a,b){Ja(function(){d(a,b)})};Ja(function(){q=d});var r=function(){for(var a=new t(m+22),b=l,c=m-l,d=m=0;d<h;++d){var e=n[d];try{var f=e.c.length;wa(a,m,e,e.f,e.u,f);var g=30+e.f.length+ka(e.extra),k=m+g;a.set(e.c,
k);wa(a,l,e,e.f,e.u,f,m,e.m);l+=16+g+(e.m?e.m.length:0);m=k+f}catch(Ab){return q(Ab,null)}}Za(a,l,n.length,c,b);q(null,a)};k||r();a=function(a){var b=g[a],d=e[b],h=d[0],A=d[1],t=ra(),z=h.length;t.p(h);var y=u(b),x=y.length,da=A.comment,G=da&&u(da),P=G&&G.length,V=ka(A.extra),B=0==A.level?0:8;d=function(c,d){c?(v(),q(c,null)):(c=d.length,n[a]=ya(A,{size:z,crc:t.d(),c:d,f:y,m:G,u:x!=b.length||G&&da.length!=P,compression:B}),l+=30+x+V+c,m+=76+2*(x+V)+(P||0)+c,--k||r())};65535<x&&d(w(11,0,1),null);if(B)if(16E4>
z)try{d(null,c(h,A))}catch(Bb){d(Bb,null)}else p.push(f(h,A,d));else d(null,h)};for(b=0;b<h;++b)a(b);return v};d.zipSync=function(a,b){b||(b={});var d={},e=[];Ya(a,"",d,b);var f=a=0;for(x in d){b=d[x];var g=b[0],k=b[1],l=0==k.level?0:8;b=u(x);var m=b.length,h=k.comment,n=h&&u(h),p=n&&n.length,q=ka(k.extra);65535<m&&w(11);var v=l?c(g,k):g,r=v.length,A=ra();A.p(g);e.push(ya(k,{size:g.length,crc:A.d(),c:v,f:b,m:n,u:m!=x.length||n&&h.length!=p,o:a,compression:l}));a+=30+m+q+r;f+=76+2*(m+q)+(p||0)+r}d=
new t(f+22);var x=a;f-=a;for(g=0;g<e.length;++g)b=e[g],wa(d,b.o,b,b.f,b.u,b.c.length),k=30+b.f.length+ka(b.extra),d.set(b.c,b.o+k),wa(d,a,b,b.f,b.u,b.c.length,b.o,b.m),a+=16+k+(b.m?b.m.length:0);Za(d,a,e.length,f,x);return d};var yb=function(){function a(){}a.prototype.push=function(a,b){this.ondata(null,a,b)};a.compression=0;return a}();d.UnzipPassThrough=yb;var Jb=function(){function a(){var a=this;this.i=new T(function(b,c){a.ondata(null,b,c)})}a.prototype.push=function(a,b){try{this.i.push(a,
b)}catch(P){this.ondata(P,null,b)}};a.compression=8;return a}();d.UnzipInflate=Jb;var Kb=function(){function a(a,b){var c=this;32E4>b?this.i=new T(function(a,b){c.ondata(null,a,b)}):(this.i=new Va(function(a,b,d){c.ondata(a,b,d)}),this.terminate=this.i.terminate)}a.prototype.push=function(a,b){this.i.terminate&&(a=Z(a,0));this.i.push(a,b)};a.compression=8;return a}();d.AsyncUnzipInflate=Kb;var Lb=function(){function a(a){this.onfile=a;this.k=[];this.o={0:yb};this.p=ja}a.prototype.push=function(a,
b){var c=this;this.onfile||w(5);this.p||w(4);if(0<this.c){var d=Math.min(this.c,a.length),e=a.subarray(0,d);this.c-=d;this.d?this.d.push(e,!this.c):this.k[0].push(e);a=a.subarray(d);if(a.length)return this.push(a,b)}else{var f=0,g=0,k=void 0,l=void 0;this.p.length?a.length?(l=new t(this.p.length+a.length),l.set(this.p),l.set(a,this.p.length)):l=this.p:l=a;var m=l.length,h=this.c;a=h&&this.d;d=function(){var a=D(l,g);if(67324752==a){f=1;k=g;n.d=null;n.c=0;var b=S(l,g+6),d=S(l,g+8);a=b&2048;var e=b&
8,p=S(l,g+26);b=S(l,g+28);if(m>g+30+p+b){var q=[];n.k.unshift(q);f=2;var r=D(l,g+18),t=D(l,g+22),v=x(l.subarray(g+30,g+=30+p),!a);4294967295==r?(a=e?[-2]:wb(l,g),r=a[0],t=a[1]):e&&(r=-1);g+=b;n.c=r;var u,A={name:v,compression:d,start:function(){A.ondata||w(5);if(r){var a=c.o[d];if(!a)A.ondata(w(14,"unknown compression type "+d,1),null,!1);u=0>r?new a(v):new a(v,r,t);u.ondata=function(a,b,c){A.ondata(a,b,c)};for(a=0;a<q.length;a++)u.push(q[a],!1);c.k[0]==q&&c.c?c.d=u:u.push(ja,!0)}else A.ondata(null,
ja,!0)},terminate:function(){u&&u.terminate&&u.terminate()}};0<=r&&(A.size=r,A.originalSize=t);n.onfile(A)}return"break"}if(h){if(134695760==a)return k=g+=12+(-2==h&&8),f=3,n.c=0,"break";if(33639248==a)return k=g-=4,f=3,n.c=0,"break"}};for(var n=this;g<m-4&&"break"!==d();++g);this.p=ja;0>h&&(d=f?l.subarray(0,k-12-(-2==h&&8)-(134695760==D(l,k-16)&&4)):l.subarray(0,g),a?a.push(d,!!f):this.k[+(2==f)].push(d));if(f&2)return this.push(l.subarray(g),b);this.p=l.subarray(g)}b&&(this.c&&w(13),this.p=null)};
a.prototype.register=function(a){this.o[a.compression]=a};return a}();d.Unzip=Lb;var Ja="function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout?setTimeout:function(a){a()};d.unzip=function(a,b,c){c||(c=b,b={});"function"!=typeof c&&w(7);var d=[],f=function(){for(var a=0;a<d.length;++a)d[a]()},g={},l=function(a,b){Ja(function(){c(a,b)})};Ja(function(){l=c});for(var m=a.length-22;101010256!=D(a,m);--m)if(!m||65558<a.length-m)return l(w(13,0,1),null),f;var h=S(a,m+8);if(h){var n=
h,p=D(a,m+16),q=4294967295==p||65535==n;q&&(m=D(a,m-12),q=101075792==D(a,m))&&(n=h=D(a,m+32),p=D(a,m+48));var r=b&&b.filter;b=function(b){var c=xb(a,p,q),m=c[0];b=c[1];var n=c[2],u=c[3],x=c[4];c=vb(a,c[5]);p=x;x=function(a,b){a?(f(),l(a,null)):(b&&(g[u]=b),--h||l(null,g))};if(!r||r({name:u,size:b,originalSize:n,compression:m}))if(m)if(8==m)if(m=a.subarray(c,c+b),524288>n||b>.8*n)try{x(null,k(m,{out:new t(n)}))}catch(zb){x(zb,null)}else d.push(e(m,{size:n},x));else x(w(14,"unknown compression type "+
m,1),null);else x(null,Z(a,c,c+b));else x(null,null)};for(m=0;m<n;++m)b(m)}else l(null,{});return f};d.unzipSync=function(a,b){for(var c={},d=a.length-22;101010256!=D(a,d);--d)(!d||65558<a.length-d)&&w(13);var e=S(a,d+8);if(!e)return{};var f=D(a,d+16),g=4294967295==f||65535==e;g&&(d=D(a,d-12),g=101075792==D(a,d))&&(e=D(a,d+32),f=D(a,d+48));b=b&&b.filter;for(d=0;d<e;++d){var l=xb(a,f,g),m=l[0],h=l[1],n=l[2],p=l[3];f=l[4];l=vb(a,l[5]);if(!b||b({name:p,size:h,originalSize:n,compression:m}))m?8==m?c[p]=
k(a.subarray(l,l+h),{out:new t(n)}):w(14,"unknown compression type "+m):c[p]=Z(a,l,l+h)}return c}},{"./node-worker.cjs":3}],3:[function(b,h,d){var a={};d.default=function(b,c,d,k,g){b=new Worker(a[c]||(a[c]=URL.createObjectURL(new Blob([b+';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'],{type:"text/javascript"}))));b.onmessage=function(a){var b=a.data;(a=b.$e$)?(b=Error(a[0]),b.code=a[1],b.stack=a[2],g(b,null)):g(null,b)};b.postMessage(d,k);return b}},
{}]},{},[1]);
(function(b,h){var d=glMatrix.vec2;b.OpacityControl=function(a,d,c){this.graphAreaColor="#a0a0a0";this.toolsAreaColor="#c0c0c0";this.presets=c;this._buildUi(a,d,c);this.opacityCurve=c?b.OpacityCurve.FromString(c[0].opacityCurveStr):new b.OpacityCurve;this.activePtIndex=0;this.colorPicker.value=b.Color.ToHexString(this.opacityCurve.curvePts[this.activePtIndex]);this._drawGraph();this.graphInteractor=new b.Interactor(this.canvas,"opgraph",{btns:0,shift:h,ctrl:h,alt:!1});this.graphInteractor.addEventListener("start move end",this._onGraphInteract.bind(this));
this.canvas.addEventListener(b.Utils.isTouchDevice()?"touchend":"mouseup",this._onGraphClick.bind(this))};b.OpacityControl.prototype._buildUi=function(a,d,c){var e=b.Ui;this.mainDiv=e.CreateElement("div","opcontrol_maindiv",null,{width:a,height:d});d-=50;this.graphDiv=e.CreateElement("div","opcontrol_graphdiv",this.mainDiv,{width:a,height:d});this.toolsDiv=e.CreateElement("div","opcontrol_toolsdiv",this.mainDiv,{width:a-2,height:50,bottom:0,border:"1px solid #909090"});this.canvas=e.CreateElement("canvas",
"opcontrol_canvas",this.graphDiv,{width:a,height:d},{width:a,height:d,borderWidth:6});this.canvas.addEventListener("contextmenu",function(a){a.preventDefault()});this.colorPicker=e.CreateElement("input","opcontrol_colorpicker",this.toolsDiv,{width:75,height:30,left:20,top:10},{type:"color",value:"#ffffff"});this.colorPicker.addEventListener("change",this._onColorSelected.bind(this));e.CreateElement("label","opcontrol_colorpicker_label",this.toolsDiv,{left:110,top:16},{innerHTML:"Point color"});if(c){this.presetSelector=
e.CreateElement("select","opcontrol_presetselector",this.toolsDiv,{width:140,height:30,right:80,top:10,fontSize:16},{val:"0"});for(a=0;a<c.length;a++)e.CreateElement("option","opcontrol_presetoption",this.presetSelector,{},{value:a.toString(),text:c[a].name});this.presetSelector.addEventListener("change",function(){this.trigger("preset-selected",{val:this.presetSelector.selectedIndex})}.bind(this));e.CreateElement("label","opcontrol_presetselector_label",this.toolsDiv,{right:20,top:16},{innerHTML:"Preset"})}};
b.OpacityControl.prototype.setOpacityCurve=function(a,b){this.opacityCurve.setControlPoints(a.controlPts);this._drawGraph();this.presets&&this._updatePresetSelector();b||this.trigger("opacity-change",{opCurve:this.opacityCurve})};b.OpacityControl.prototype.setPresets=function(a){for(;0<this.presetSelector.options.length;)this.presetSelector.remove(0);a.forEach(function(a,c){b.Ui.CreateElement("option","3dcon_presetoption",this.presetSelector,{},{value:c.toString(),text:a.name})}.bind(this))};b.OpacityControl.prototype._updatePresetSelector=
function(){if(this.presets){for(var a=this.opacityCurve.toString(),b=-1,c=0;c<this.presets.length;c++)if(this.presets[c].opacityCurveStr==a){b=c;break}this.presetSelector.selectedIndex!=b&&(this.presetSelector.selectedIndex=b)}};b.OpacityControl.prototype._onColorSelected=function(){if(null!==this.activePtIndex){var a=this.opacityCurve.curvePts[this.activePtIndex];if(a){var d=b.Color.FromHexString(this.colorPicker.value);a.r=d.r;a.g=d.g;a.b=d.b;this.opacityCurve._updateControlPointsFromCurvePoints()}this._drawGraph();
this.trigger("opacity-change",{opCurve:this.opacityCurve})}};b.OpacityControl.prototype._onGraphInteract=function(a){if("start"==a.type){if(b.Utils.isTouchDevice()||0===a.detail.origEvent.button){var f=this._hitTest(this.graphInteractor.currPoint);if(null!==f){this.activePtIndex=f;this.draggingCurve=!0;this.colorPicker.value=b.Color.ToHexString(this.opacityCurve.curvePts[this.activePtIndex]);this.alphaStart=this.opacityCurve.curvePts[this.activePtIndex].a;for(this.leftPtIndex=this.indxStart=this.activePtIndex;0<
this.leftPtIndex&&!this.opacityCurve.curvePts[this.leftPtIndex-1];)this.leftPtIndex--;for(this.rightPtIndex=this.activePtIndex;this.rightPtIndex<this.opacityCurve.numPoints()-1&&!this.opacityCurve.curvePts[this.rightPtIndex+1];)this.rightPtIndex++;this._drawGraph();this.trigger("opacity-change-start")}}}else if("move"==a.type){if(this.draggingCurve){f=d.create();if(a.detail.origEvent.ctrlKey||a.detail.origEvent.metaKey){d.subtract(f,this._windowPointToCurvePoint(this.graphInteractor.currPoint),this._windowPointToCurvePoint(this.graphInteractor.prevPoint));
a.detail.origEvent.shiftKey&&d.scale(f,f,.2);a=this.opacityCurve.controlPts;var c=a.length/2;if(3<c&&(f=Math.round(f[0]),f=0<f?Math.min(f,Math.max(0,b.OpacityCurve.NumPoints-1-a[2*c-4]-10)):Math.max(f,Math.min(0,-(a[2]-10))),0!=f)){for(var e=2;e<2*c-2;e+=2)a[e]+=f;this.opacityCurve.setControlPoints(a)}}else d.subtract(f,this._windowPointToCurvePoint(this.graphInteractor.currPoint),this._windowPointToCurvePoint(this.graphInteractor.startPoint)),a.detail.origEvent.shiftKey&&d.scale(f,f,.2),a=this.opacityCurve.curvePts,
a[this.activePtIndex].a=Math.max(0,Math.min(255,Math.round(this.alphaStart+f[1]))),0!==this.activePtIndex&&this.activePtIndex!==this.opacityCurve.numPoints()-1&&(f=Math.max(this.leftPtIndex,Math.min(this.rightPtIndex,Math.round(this.indxStart+f[0]))),f!=this.activePtIndex&&(a[f]=a[this.activePtIndex],a[this.activePtIndex]=null,this.activePtIndex=f));this.opacityCurve._updateControlPointsFromCurvePoints();this._drawGraph();this.trigger("opacity-change",{opCurve:this.opacityCurve})}}else"end"==a.type&&
this.draggingCurve&&(this.trigger("opacity-change-end"),this.draggingCurve=!1)};b.OpacityControl.prototype._onGraphClick=function(a){var d=b.Utils.isTouchDevice();if(d||2===a.button)if(!d||a.originalEvent&&a.originalEvent.targetTouches&&a.originalEvent.targetTouches.length){a.preventDefault();d=b.Interactor._getEventCoordinates(a);a=this.canvas.getBoundingClientRect();d=[d[0]-a.left,d[1]-a.top];a=this.opacityCurve.curvePts;var c=this.opacityCurve.numPoints(),e=!1,k=this._hitTest(d);if(k&&k!=c-1)a[k]=
null,this.activePtIndex=0,this.colorPicker.value=b.Color.ToHexString(a[0]),e=!0;else if(d=this._windowPointToCurvePoint(d),!a[d[0]]){e=0;for(c=d[0]-1;0<=c;c--)if(a[c]){e=a[c];break}e=new b.Color(e.r,e.g,e.b,d[1]);a[d[0]]=e;this.activePtIndex=d[0];this.colorPicker.value=b.Color.ToHexString(e);e=!0}e&&(this.opacityCurve._updateControlPointsFromCurvePoints(),this._drawGraph(),this.trigger("opacity-change",{opCurve:this.opacityCurve}))}};b.OpacityControl.prototype._hitTest=function(a){a=this._windowPointToCurvePoint(a);
for(var b=this.opacityCurve.curvePts,c=b.length,d=256/c*(this.canvas.width/this.canvas.height),k=Number.MAX_SAFE_INTEGER,g=-1,l=0;l<c;l++)if(b[l]){var m=(l-a[0])*d,h=b[l].a-a[1];m=m*m+h*h;m<k&&(k=m,g=l)}return 10>Math.sqrt(k)?g:null};b.OpacityControl.prototype._windowPointToCurvePoint=function(a){var b=this.canvas.borderWidth,c=this.canvas.width-2*b,d=this.canvas.height-2*b,k=this.opacityCurve.numPoints()-1;c=Math.round((a[0]-b)*k/c);c=Math.max(0,Math.min(k,c));a=Math.round(255*(this.canvas.height-
1-a[1]-b)/d);a=Math.max(0,Math.min(255,a));return[c,a]};b.OpacityControl.prototype._drawGraph=function(){var a=this.canvas.getContext("2d"),d=this.canvas.width,c=this.canvas.height,e=this.canvas.borderWidth,k=d-2*e,g=c-2*e;a.clearRect(0,0,d,c);a.beginPath();a.fillStyle=this.graphAreaColor;a.fillRect(0,0,d,c);a.beginPath();a.strokeStyle="#606060";a.rect(0,0,d,c);a.stroke();a.rect(e,e,d-2*e,c-2*e);a.stroke();d=this.opacityCurve.controlPts;for(var l=b.OpacityCurve.NumPoints,m,h,p,r=0;r<d.length;r+=2){var q=
d[r],u=d[r+1],x=b.Color.ToHexString(u),z=e+q/(l-1)*k;u=c-(e+u.a/255*g);q=q==this.activePtIndex?6:4;a.beginPath();a.arc(z,u,q,0,2*Math.PI,!0);a.fillStyle=x;a.fill();if(m||0===m)q=a.createLinearGradient(m,h,z,u),q.addColorStop(0,p),q.addColorStop(1,x),a.strokeStyle=q,a.beginPath(),a.moveTo(m,h),a.lineTo(z,u),a.stroke();m=z;h=u;p=x}};b.OpacityControl.prototype.addEventListener=function(a,d){b.Notifier.prototype.addEventListener.call(this,a,d)};b.OpacityControl.prototype.removeEventListener=function(a,
d){b.Notifier.prototype.removeEventListener.call(this,a,d)};b.OpacityControl.prototype.trigger=function(a,d){b.Notifier.prototype.trigger.call(this,a,d)}})(window.BigLime=window.BigLime||{});
(function(b,h){b.OpacityCurve=function(d){var a=b.OpacityCurve.NumPoints;this.curvePts=Array(a);this.controlPts=[];d=d||[0,new b.Color(255,255,255,0),a/4,new b.Color(255,180,140,0),3*a/4,new b.Color(255,255,255,240),a-1,new b.Color(255,255,255,240)];this.setControlPoints(d);this.rgbaBuf=new Uint8Array(4*a)};b.OpacityCurve.NumPoints=1024;b.OpacityCurve.prototype.clone=function(){return new b.OpacityCurve(this.controlPts)};b.OpacityCurve.prototype.updateFrom=function(b){this.setControlPoints(b.controlPts)};
b.OpacityCurve.prototype.numPoints=function(){return this.curvePts.length};b.OpacityCurve.prototype.setControlPoints=function(d){this.controlPts=[];for(var a=0;a<this.curvePts.length;a++)this.curvePts[a]=null;for(a=0;a<d.length;a+=2)this.controlPts.push(d[a]),this.controlPts.push(b.Color.Clone(d[a+1])),this.curvePts[d[a]]=b.Color.Clone(d[a+1])};b.OpacityCurve.prototype.copyToTexture=function(d){if(d.width!=this.curvePts.length)b.Logger.Report("OpacityCurve.copyToTexture: Invalid texture size.",b.Logger.Severity.Error);
else{for(var a=this.curvePts,f=a.length,c=0,e=1,k=a[0]||new b.Color(0,0,0,0);e<f;){var g=a[e];g||e!=f-1||(g=new b.Color(0,0,0,0));if(g){for(var l=c;l<=e;l++){var m=(l-c)/(e-c);this.rgbaBuf[4*l]=Math.round(k.r+m*(g.r-k.r));this.rgbaBuf[4*l+1]=Math.round(k.g+m*(g.g-k.g));this.rgbaBuf[4*l+2]=Math.round(k.b+m*(g.b-k.b));this.rgbaBuf[4*l+3]=Math.round(k.a+m*(g.a-k.a))}c=e;k=g}e++}a=d.context.gl;d.bind();a.texSubImage2D(a.TEXTURE_2D,0,0,0,f,1,a.RGBA,a.UNSIGNED_BYTE,this.rgbaBuf);a.texSubImage2D(a.TEXTURE_2D,
0,0,1,f,1,a.RGBA,a.UNSIGNED_BYTE,this.rgbaBuf)}};b.OpacityCurve.prototype.toString=function(){for(var b="",a=this.controlPts,f=0;f<a.length;f+=2)b+="["+a[f].toString()+"]"+a[f+1].toString()+(f<a.length-2?"; ":"");return b};b.OpacityCurve.FromString=function(d){var a=null;try{var f=d.trim().split(";");d=[];for(var c=0;c<f.length;c++){var e=f[c],k=e.indexOf("["),g=e.indexOf("]"),l=parseInt(e.substring(k+1,g)),m=b.Color.FromString(e.substring(g+1));d.push(l,m)}a=new b.OpacityCurve(d)}catch(n){b.Logger.Report("OpacityCurve.FromString: Invalid input string",
b.Logger.Severity.Error)}return a};b.OpacityCurve.prototype._updateControlPointsFromCurvePoints=function(){this.controlPts=[];for(var d=0;d<this.curvePts.length;d++)this.curvePts[d]&&(this.controlPts.push(d),this.controlPts.push(b.Color.Clone(this.curvePts[d])))}})(window.BigLime=window.BigLime||{});
(function(b,h){b.ReliefMask=function(d,a,f,c){this.context=d;this.width=Math.round(f);this.height=Math.round(c);f=this.context.gl;this.texture=new b.Texture2D(d,a,this.width,this.height,f.RGBA,f.LINEAR);this.dataBuffer=new ArrayBuffer(4*this.width*this.height);this.dataView=new DataView(this.dataBuffer);this.dataBuffer8=new Uint8Array(this.dataBuffer);this.copyDataToTexture()};b.ReliefMask.prototype.destroy=function(){this.context&&(this.texture.destroy(),this.context=this.texture=null)};b.ReliefMask.prototype.copyDataToTexture=
function(b){b=b===h?null:b;var a=this.context.gl;this.texture.bind();var d=b?Math.max(0,b[0]):0,c=b?Math.min(this.height-d,b[1]-d+1):this.height;b=b?this.dataBuffer8.subarray(d*this.width*4,(d+c)*this.width*4):this.dataBuffer8;a.texSubImage2D(a.TEXTURE_2D,0,0,d,this.width,c,a.RGBA,a.UNSIGNED_BYTE,b)}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=b.Logger.Severity,a=glMatrix.vec3,f=glMatrix.vec4,c=glMatrix.mat4;b.RenderEngine=function(a){a=a===h?{}:a;this.canvas=a.canvas||b.Ui.CreateElement("canvas","renderengine_canvas",null,{width:100,height:100,background:"black"});this.ctx=new b.GLContext(this.canvas,a.options);this.volume=null;this.shaders={};this.frameBuffers={};this.vertexBuffers={};this.lutTexture=null;this.prevOpacityCurve="";this.loader=null;this.pickMode=this.loadingData=!1;this.shadowMapRez=.5;this.viewport=
[0,0,300,150];this.smViewport=[0,0,300,150];this.transforms={model:c.create(),view:c.create(),mvp:c.create(),mvpInv:c.create(),shadowMvp:[c.create(),c.create()],shadowMvpInv:[c.create(),c.create()]};a=this.ctx;this.volume=1==a.glVersion?new b.VolumeT2(a,a.GlMaxTextures-2):new b.VolumeT3(a,0);this.renderParams=new b.RenderParams;this.renderParams.slab=new b.Slab(this.volume);this.volume.setInterpType(this.renderParams.interpType);var d=a.gl;this.vertexBuffers.threed=a.createAttrBuffer(new b.Shapes3D.Cube(1),
3);this.vertexBuffers.twod=a.createAttrBuffer(new b.Shapes3D.Rectangle(2,2),3);this.frameBuffers.threed=new b.FrameBuffer(a,a.GlMaxTextures-1,this.canvas.width,this.canvas.height,d.RGBA,d.LINEAR,!1);this.frameBuffers.shadows=null;this.frameBuffers.gfx=null;this.lutTexture=new b.Texture2D(a,a.GlMaxTextures-2,b.OpacityCurve.NumPoints,16,d.RGBA,d.LINEAR);this._createColorMapLuts();this.mask=null;this.clearDisplay()};b.RenderEngine.prototype.destroy=function(){this.ctx&&(this.volume&&this.volume.destroy(),
this.lutTexture&&this.lutTexture.destroy(),this.mask&&this.mask.destroy(),Object.values(this.frameBuffers).forEach(function(a){a&&a.destroy()}),Object.values(this.vertexBuffers).forEach(function(a){a&&a.destroy()}),Object.values(this.shaders).forEach(function(a){a&&a.destroy()}),this.mask=this.volume=this.lutTexture=null,this.frameBuffers={},this.vertexBuffers={},this.shaders={},this.ctx=null)};b.RenderEngine.prototype.sizeRasterFor=function(a,b,c){b=b===h?1:b;c=c===h?!1:c;a=a.getBoundingClientRect();
var d=Math.round(b*a.width),e=Math.round(b*a.height);this.viewport=[0,0,d,e];d=c?d:Math.max(this.canvas.width,d);e=c?e:Math.max(this.canvas.height,e);this.canvas.width!=d&&(this.canvas.width=d);this.canvas.height!=e&&(this.canvas.height=e);this.frameBuffers.threed.resize(d,e);var f=this.renderParams;this.frameBuffers.gfx&&f.showGraphics&&this.frameBuffers.gfx.resize(2*d,2*e);this.frameBuffers.shadows&&f.lightSet.shadowsEnabled()&&(b=Math.min(this.shadowMapRez,b),a=$jscomp.makeIterator([Math.round(b*
a.width),Math.round(b*a.height)]),b=a.next().value,a=a.next().value,this.smViewport=[0,0,b,a],d=this.frameBuffers.shadows,d.resize(c?b:Math.max(d.width,b),c?2*a:Math.max(d.height,2*a)))};b.RenderEngine.prototype.clearDisplay=function(){var a=this.renderParams;a=a.renderType==b.RenderType.VR?a.vrBackColor||b.Color.Black():b.Color.Black();this.ctx.clearCanvas(a)};b.RenderEngine.prototype.setRenderParams=function(a){this.renderParams=a};b.RenderEngine.prototype.loadVolume=function(a){a=a===h?{}:a;if(this.loadingData)b.Logger.Report("RenderEngine ignored an overlapping load request.",
d.Warn),completionCb&&completionCb("RenderEngine ignored an overlapping load request.",null,this);else{this.clearDisplay();this.frameBuffers.gfx&&this.frameBuffers.gfx.destroy();this.frameBuffers.shadows&&this.frameBuffers.shadows.destroy();this.mask&&this.mask.destroy();this.frameBuffers.shadows=null;this.mask=this.frameBuffers.gfx=null;this.ctx.setCurrentProgram(null);Object.values(this.shaders).forEach(function(a){a&&a.destroy()});this.shaders={};var c=this.loader=a.loader;c.clientData=c.clientData||
{};c.clientData.renderEngineData={completionCb:a.completionCb};this.loadingData=!0;if(c=c.loadImagesIntoVolume(a.imgFiles,this.volume,this._onVolumeLoaded.bind(this),a.progressCb))return b.Logger.Report(c,d.Error),this.loadingData=!1,a.completionCb&&a.completionCb(c,null,this),this.loader=null,c}};b.RenderEngine.prototype.cancelLoading=function(){this.loadingData&&(this.loadingData=!1,this.loader.cancelLoading(),this.loader=null)};b.RenderEngine.prototype._onVolumeLoaded=function(a){this.loadingData=
!1;this.loader=null;var c=a.clientData.renderEngineData;if(a.errors)c.completionCb&&c.completionCb(a.errors,a.warnings,this);else{try{var d=this.ctx,e=this.volume,f=d.GlMaxTextures-2-e.numTextures(),h=this.frameBuffers.threed.width,p=this.frameBuffers.threed.height;1<=f&&(this.frameBuffers.shadows=new b.FrameBuffer(d,d.GlMaxTextures-3,Math.round(this.shadowMapRez*h),2*Math.round(this.shadowMapRez*p),d.gl.RGBA,d.gl.LINEAR,!1));2<=f&&(this.frameBuffers.gfx=new b.FrameBuffer(d,d.GlMaxTextures-4,2*h,
2*p,d.gl.RGBA,d.gl.LINEAR,!0));3<=f&&(this.mask=new b.ReliefMask(d,d.GlMaxTextures-5,e.dims[0],e.dims[1]));this.baseRayStepSize=1/Math.max(e.dims[0],e.dims[1],e.dims[2],64)}catch(r){d="RenderEngine exception: "+r.message;c.completionCb&&c.completionCb(d,a.warnings,this);return}c.completionCb&&c.completionCb("",a.warnings,this)}};b.RenderEngine.prototype.hasImageData=function(){return this.volume.loaded};b.RenderEngine.prototype.animate=function(a,c){if(this.isAnimating())b.Logger.Report("RenderEngine: Overlapping animate request ignored.",
d.Warn);else{var e=0<a?1E3/a:0,f=performance.now(),k=c||this.render.bind(this),h=function(){if(0>=e)k();else{var a=performance.now();a-f>e&&(f=a,k())}this.animId=b.Utils.requestAnimFrame(h)}.bind(this);this.animId=b.Utils.requestAnimFrame(h)}};b.RenderEngine.prototype.stopAnimation=function(){this.isAnimating()&&(b.Utils.cancelAnimFrame(this.animId),this.animId=null)};b.RenderEngine.prototype.isAnimating=function(){return!!this.animId};b.RenderEngine.prototype.render=function(a){a=a===h?null:a;var c=
this.volume;if(c.loaded&&!this.loadingData){var d=this.renderParams;c.setInterpType(d.interpType);var e=this._getCurrentVolShaderNames(),f=e.vol;e=e.shadow;this.ctx.gl.enable(this.ctx.gl.CULL_FACE);this.updateTransforms();var n=d.slab?d.slab.getVerticesTx().map(function(a){return[].concat($jscomp.arrayFromIterable(a))}).flat():Array(24).fill(0),p=d.renderType==b.RenderType.VR,r=d.renderType==b.RenderType.XRAY;if(p||r)r=d.opacityCurve.toString(),r!=this.prevOpacityCurve&&(d.opacityCurve.copyToTexture(this.lutTexture),
this.prevOpacityCurve=r);""!=e&&this._renderShadowMaps(e,n);p&&this.frameBuffers.gfx&&d.showGraphics&&0<c.meshManager.numVisibleMeshes()&&this._renderGraphics();this._renderVolToFramebuffer(f,n);this._renderFramebufferToCanvas(a)}};b.RenderEngine.prototype._renderShadowMaps=function(a,c){var d=this.volume,e=d.getOpacityRange(),f=this.renderParams;a=this._useShader(a);a.setUniform("uBitsPerPixel",d.bpp);a.setUniform("uMosaicDims",d.txInfo?d.txInfo.mosaicDims:[1,1,1]);a.setUniform("uNumTextures",d.numTextures());
a.setUniform("uVolShape",d.shape);a.setUniform("uOpacityRange",[e[0],1/e[1]]);a.setUniform("uRayStepSize",this.baseRayStepSize);a.setUniform("uMaskEnabled",f.useMask);a.setUniform("uSlabInfo",c);a.setUniform("uVolNumImages",d.dims[2]);a.setAttribute("aPosition",this.vertexBuffers.threed);c=this.frameBuffers.shadows.height/2;for(d=0;d<f.lightSet.dirLights.length;d++)0<f.lightSet.dirLights[d].shadowDarkness&&(a.setUniform("uShadowMvpTransform",this.transforms.shadowMvp[d]),a.setUniform("uShadowMvpInvTransform",
this.transforms.shadowMvpInv[d]),a.draw({target:this.frameBuffers.shadows,clearColor:b.Color.White(),viewport:[0,d*c,this.smViewport[2],this.smViewport[3]]}))};b.RenderEngine.prototype._renderGraphics=function(){var a=this.volume;if(a.loaded&&!this.loadingData){var b=this._useShader("gfx");b.setUniform("uMvpTransform",this.transforms.mvp);b.setUniform("uMvpInvTransform",this.transforms.mvpInv);b.setUniform("uRotMatrix",this.renderParams.rotMatrix);b.setUniform("uPersp",this.renderParams.persp);var c=
this.ctx.gl;c.bindFramebuffer(c.FRAMEBUFFER,this.frameBuffers.gfx.glFrameBuffer);c.clearColor(1,1,1,1);c.clear(c.COLOR_BUFFER_BIT|c.DEPTH_BUFFER_BIT);c.enable(c.DEPTH_TEST);for(var d=c.drawingBufferWidth,f=c.drawingBufferHeight,h=this.viewport[2],p=this.viewport[3],r=0;2>r;r++){var q=a.meshManager.numVisibleVertices(r);0<q&&(a.meshManager.activateMeshes(r,b),b.setUniform("uRenderDepthMap",!1),b.draw({numVertices:q,target:this.frameBuffers.gfx,clear:!1,viewport:[0,r*f,h,p]}),b.setUniform("uRenderDepthMap",
!0),b.draw({numVertices:q,target:this.frameBuffers.gfx,clear:!1,viewport:[d,r*f,h,p]}))}c.disable(c.DEPTH_TEST)}};b.RenderEngine.prototype._renderVolToFramebuffer=function(c,d){var e=this.volume;if(e.loaded&&!this.loadingData){var k=this.transforms,h=this.renderParams;c=this._useShader(c);c.setUniform("uModelTransform",k.model);c.setUniform("uViewTransform",k.view);c.setUniform("uMvpTransform",k.mvp);c.setUniform("uMvpInvTransform",k.mvpInv);c.setUniform("uRayStepSize",this.baseRayStepSize/h.rayOversamp);
c.setUniform("uPersp",h.persp);c.setUniform("uMarkerLoc",h.markerLoc);c.setUniform("uMarkerSize",h.markerSize);c.setUniform("uShowMarker",h.showMarker);c.setUniform("uMaskEnabled",h.useMask);c.setUniform("uSlabInfo",d);c.setUniform("uVolShape",e.shape);c.setUniform("uVolNumImages",e.dims[2]);c.setUniform("uBitsPerPixel",e.bpp);c.setUniform("uNumTextures",e.numTextures());c.setUniform("uMosaicDims",e.txInfo?e.txInfo.mosaicDims:[1,1,1]);c.setAttribute("aPosition",this.vertexBuffers.threed);if(d=h.renderType==
b.RenderType.VR){var n=this.frameBuffers.shadows;e=e.getOpacityRange();c.setUniform("uAntiAlias",h.antiAlias?1:0);c.setUniform("uGfxBlendWeight",h.gfxBlendWeight);c.setUniform("uMarkerColor",b.Color.ScaleTo1(h.markerColor));c.setUniform("uOpacityRange",[e[0],1/e[1]]);c.setUniform("uOutBufferSize",this.frameBuffers.threed.getSize());c.setUniform("uSealBorders",h.sealBorders);c.setUniform("uShadowSampler",n?n.txIndex:-1);c.setUniform("uShadowTxScale",(this.smViewport[2]+this.smViewport[3])/(n.width+
n.height/2));c.setUniform("uVrBackColor",b.Color.ScaleTo1(h.vrBackColor).slice(0,3));if(!this.pickMode)for(c.setUniform("uAmbientLight",h.lightSet.ambientLight),e=0;e<h.lightSet.dirLights.length;e++){var p=h.lightSet.dirLights[e];n="uLights["+e.toString()+"].";c.setUniform(n+"diffuse",p.diffuse);c.setUniform(n+"specStrength",p.specStrength);c.setUniform(n+"specExp",p.specExp);c.setUniform(n+"shadowDarkness",p.shadowDarkness);c.setUniform(n+"shadowSoftness",p.shadowSoftness);c.setUniform(n+"shadowMvp",
k.shadowMvp[e]);p=f.fromValues(p.dir[0],p.dir[1],p.dir[2],0);f.normalize(p,f.transformMat4(p,p,k.mvpInv));c.setUniform(n+"dir",a.fromValues(p[0],p[1],p[2]))}}else h.renderType==b.RenderType.XRAY&&(e=e.getOpacityRange(),c.setUniform("uOpacityRange",[e[0],1/e[1]]),c.setUniform("uUseLut",h.useXrayLut));k=d?h.vrBackColor||b.Color.Black():b.Color.Black();c.draw({target:this.frameBuffers.threed,clearColor:k,viewport:this.viewport})}};b.RenderEngine.prototype._renderFramebufferToCanvas=function(a){if(this.volume.loaded&&
!this.loadingData){var c=this.ctx.gl,d=this.renderParams,e=this._useShader("winLevel");e.setInputTexture("uWLSampler",this.frameBuffers.threed.texture);e.setInputTexture("uLutSampler",this.lutTexture);e.setUniform("uWinWidth",d.winWidth);e.setUniform("uWinLevel",d.winLevel);e.setUniform("uMarkerColor",b.Color.ScaleTo1(d.markerColor));e.setUniform("uPassThruMode",d.renderType==b.RenderType.VR?1:0);e.setUniform("uColorMapIndex",d.colorMapIndex);e.setAttribute("aPosition",this.vertexBuffers.twod);e.draw();
a&&(a=a(this.transforms))&&(e=this._useShader("slab"),e.setUniform("uMvpTransform",this.transforms.mvp),e.setUniform("uPersp",d.persp),e.setAttribute("aPosition",a.vertexBuffer),e.setAttribute("aColor",a.attrBuffer),e.draw({clear:!1,drawMode:c.LINES,numVertices:2*a.numLines,viewport:this.viewport}))}};b.RenderEngine.prototype._getCurrentVolShaderNames=function(){var a=this.volume;if(a.loaded&&!this.loadingData){var c=this.renderParams,d=c.renderType==b.RenderType.VR,f=c.renderType==b.RenderType.XRAY,
h=d?"vr":f?"xray":"mip",n=c.clipToSlab?"_slab":"";f=!f&&c.showGraphics&&this.frameBuffers.gfx&&0<a.meshManager.numVisibleMeshes()?"_gfx":"";var p=d&&this.frameBuffers.shadows&&c.lightSet.shadowsEnabled()?"_shadows":"",r="";1===this.ctx.glVersion&&(c=c.interpType==b.Interp3D.TriLinear?"lin":"nn",r=1>=a.numTextures()?"_st":"_mt",r="_"+a.bpp.toString()+"bit_"+c+r);return{vol:h+n+f+p+r,shadow:d?"shadows"+n+r:""}}};b.RenderEngine.prototype._useShader=function(a){a=this.shaders[a]||this._createShader(a);
this.ctx.setCurrentProgram(a);return a};b.RenderEngine.prototype._createShader=function(a){var c=this.volume,d=this.ctx.glVersion.toString(),e=a.split("_"),f=e[0],h=b.ShaderCode[f+"_vert_"+d];d=b.ShaderCode[f+"_frag_"+d];var p="";-1!==a.indexOf("_slab")&&(p+="\n#define CLIP_TO_SLAB");-1!==a.indexOf("_gfx")&&(p+="\n#define RENDER_GRAPHICS");-1!==a.indexOf("_shadows")&&(p+="\n#define RENDER_SHADOWS");if("vr"==f||"shadows"==f||"xray"==f||"winLevel"==f){var r=1/this.lutTexture.height;p+="\n#define LUT_TX_YOFFSET "+
r.toString()+(0==r%1?".0":"")}if("winLevel"==f){r=256/this.lutTexture.width;var q=2/this.lutTexture.height;p+="\n#define LUT_TX_XSCALE "+r.toString()+(0==r%1?".0":"");p+="\n#define LUT_TX_YSCALE "+q.toString()+(0==q%1?".0":"")}1==this.ctx.glVersion&&(p+="\n#define PIXEL_LAYOUT_"+e.slice(e.length-3).join("_").toUpperCase(),p+="\n#define NUM_IMAGE_TEXTURES "+c.numTextures());e={"//<<SYMBOL_DEFS>>//":p};h=new b.ShaderProgram(this.ctx,a,h,d,e,e,!0);this.shaders[a]=h;"vr"==f&&h.setInputTexture("uGfxSampler",
this.frameBuffers.gfx?this.frameBuffers.gfx.texture:null);"vr"!=f&&"shadows"!=f&&"xray"!=f||h.setInputTexture("uLutSampler",this.lutTexture);if("vr"==f||"shadows"==f||"xray"==f||"mip"==f)h.setInputTexture("uMaskSampler",this.mask?this.mask.texture:null),2===this.ctx.glVersion?h.setInputTexture("uVolumeSampler",c.texture):1==c.numTextures()?h.setInputTexture("uSampler",c.textures[0]):h.setInputTexture("uSamplers",c.textures);return h};b.RenderEngine.prototype.updateTransforms=function(){this.calcTransforms(this.renderParams,
this.viewport[3]/this.viewport[2],{result:this.transforms})};b.RenderEngine.prototype.calcTransforms=function(d,f,g){g=g===h?{omitLights:!1,result:null}:g;var e=g.result||{model:c.create(),view:c.create(),mvp:c.create(),mvpInv:c.create(),shadowMvp:g.omitLights?null:[c.create(),c.create()],shadowMvpInv:g.omitLights?null:[c.create(),c.create()]};if(!this.volume.loaded)return e;var k=a.normalize(a.create(),this.volume.shape);a.scale(k,k,2);c.fromScaling(e.model,k);k=c.fromTranslation(c.create(),a.fromValues(-d.pan[0],
-d.pan[1],0));var n=Array.isArray(d.zoom)?d.zoom:[d.zoom,d.zoom];n=c.fromScaling(c.create(),a.fromValues(n[0],n[1],1));c.multiply(e.view,n,c.multiply(c.create(),k,d.rotMatrix));f=c.fromScaling(c.create(),a.fromValues(Math.min(f,1),Math.min(1/f,1),1));c.multiply(e.mvp,f,c.multiply(c.create(),e.view,e.model));c.invert(e.mvpInv,e.mvp);if(!g.omitLights&&d.renderType==b.RenderType.VR)for(g=0;g<d.lightSet.dirLights.length;g++){var p=d.lightSet.dirLights[g];if(0<p.shadowDarkness){k=e.shadowMvp[g];c.copy(k,
e.model);n=c.clone(d.rotMatrix);p=a.cross(a.create(),a.fromValues(0,0,1),p.dir);var r=Math.asin(a.length(p));1E-4<Math.abs(r)&&(p=c.fromRotation(c.create(),-r,p),c.multiply(n,p,n));c.multiply(k,n,k);c.multiply(k,f,k);c.invert(e.shadowMvpInv[g],k)}}return e};b.RenderEngine.prototype._createColorMapLuts=function(){var a=Math.min(257,this.lutTexture.width),b=this.lutTexture.context.gl,c=new Uint8Array(4*a);this.lutTexture.bind();var d,f,h=[];h.push([0,0,0,255]);h.push([1,1,171,255]);h.push([1,1,224,
255]);h.push([0,110,255,255]);h.push([1,171,254,255]);h.push([1,224,254,255]);h.push([1,254,1,255]);h.push([190,255,0,255]);h.push([255,255,0,255]);h.push([255,224,0,255]);h.push([255,141,0,255]);h.push([250,94,0,255]);h.push([245,0,0,255]);h.push([245,0,197,255]);h.push([222,180,222,255]);h.push([255,255,255,255]);h.push([255,255,255,255]);for(d=0;d<a;d++){var p=h[Math.floor(d/16)];for(f=0;4>f;f++)c[4*d+f]=p[f]}b.texSubImage2D(b.TEXTURE_2D,0,0,2,a,1,b.RGBA,b.UNSIGNED_BYTE,c);b.texSubImage2D(b.TEXTURE_2D,
0,0,3,a,1,b.RGBA,b.UNSIGNED_BYTE,c)}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=glMatrix.vec2,a=glMatrix.vec3,f=glMatrix.mat4;b.RenderParams=function(c){this.antiAlias=!1;this.clipToSlab=!0;this.gfxBlendWeight=.5;this.interpType=b.Interp3D.TriLinear;this.lightSet=new b.LightSet;this.markerColor=b.Color.FromName("green");this.markerLoc=a.fromValues(.5,.5,.5);this.markerSize=.0075;this.opacityCurve=new b.OpacityCurve;this.pan=d.fromValues(0,0);this.persp=0;this.rayOversamp=1;this.renderType=b.RenderType.VR;this.rotMatrix=f.create();this.sealBorders=!1;this.showSlab=
this.showMarker=this.showGraphics=!0;this.slab=null;this.useMask=!1;this.colorMapIndex=0;this.useXrayLut=!1;this.vrBackColor=new b.Color(18,9,57);this.winLevel=0;this.zoom=this.winWidth=1;c&&this.updateFrom(c)};b.RenderParams.prototype.updateFrom=function(c){Object.hasOwn(c,"antiAlias")&&(this.antiAlias=c.antiAlias);Object.hasOwn(c,"clipToSlab")&&(this.clipToSlab=c.clipToSlab);Object.hasOwn(c,"gfxBlendWeight")&&(this.gfxBlendWeight=c.gfxBlendWeight);Object.hasOwn(c,"interpType")&&(this.interpType=
c.interpType);Object.hasOwn(c,"lightSet")&&this.lightSet.updateFrom(c.lightSet);Object.hasOwn(c,"markerColor")&&(this.markerColor=b.Color.Clone(c.markerColor));Object.hasOwn(c,"markerLoc")&&a.copy(this.markerLoc,c.markerLoc);Object.hasOwn(c,"markerSize")&&(this.markerSize=c.markerSize);Object.hasOwn(c,"pan")&&d.copy(this.pan,c.pan);Object.hasOwn(c,"persp")&&(this.persp=c.persp);Object.hasOwn(c,"rayOversamp")&&(this.rayOversamp=c.rayOversamp);Object.hasOwn(c,"renderType")&&(this.renderType=c.renderType);
Object.hasOwn(c,"rotMatrix")&&f.copy(this.rotMatrix,c.rotMatrix);Object.hasOwn(c,"sealBorders")&&(this.sealBorders=c.sealBorders);Object.hasOwn(c,"showGraphics")&&(this.showGraphics=c.showGraphics);Object.hasOwn(c,"showMarker")&&(this.showMarker=c.showMarker);Object.hasOwn(c,"showSlab")&&(this.showSlab=c.showSlab);Object.hasOwn(c,"useMask")&&(this.useMask=c.useMask);Object.hasOwn(c,"useXrayLut")&&(this.useXrayLut=c.useXrayLut);Object.hasOwn(c,"colorMapIndex")&&(this.colorMapIndex=c.colorMapIndex);
Object.hasOwn(c,"vrBackColor")&&(this.vrBackColor=b.Color.Clone(c.vrBackColor));Object.hasOwn(c,"winLevel")&&(this.winLevel=c.winLevel);Object.hasOwn(c,"winWidth")&&(this.winWidth=c.winWidth);Object.hasOwn(c,"opacityCurveStr")?this.opacityCurve.updateFrom(b.OpacityCurve.FromString(c.opacityCurveStr)):Object.hasOwn(c,"opacityCurve")&&this.opacityCurve.updateFrom(c.opacityCurve);Object.hasOwn(c,"slab")&&(this.slab?this.slab.updateFrom(c.slab):this.slab=c.slab.clone());Object.hasOwn(c,"zoom")&&(Array.isArray(c.zoom)?
Array.isArray(this.zoom)?d.copy(this.zoom,c.zoom):this.zoom=d.clone(c.zoom):Array.isArray(this.zoom)?d.set(this.zoom,c.zoom,c.zoom):this.zoom=c.zoom)}})(window.BigLime=window.BigLime||{});
(function(b,h){b.Settings=function(d){this.antiAlias=!1;this.interpType=b.Interp3D.TriLinear;this.lightSet=new b.LightSet;this.opacityCurveStr=(new b.OpacityCurve).toString();this.useXrayLut=!1;this.persp=this.colorMapIndex=0;this.rayOversamp=1;this.renderType=b.RenderType.VR;this.sealBorders=!1;this.vrBackColor=new b.Color(18,9,57);d&&this.updateFrom(d)};b.Settings.prototype.updateFrom=function(d){Object.hasOwn(d,"antiAlias")&&(this.antiAlias=d.antiAlias);Object.hasOwn(d,"interpType")&&(this.interpType=
d.interpType);Object.hasOwn(d,"lightSet")&&this.lightSet.updateFrom(d.lightSet);Object.hasOwn(d,"useXrayLut")&&(this.useXrayLut=d.useXrayLut);Object.hasOwn(d,"colorMapIndex")&&(this.colorMapIndex=d.colorMapIndex);Object.hasOwn(d,"persp")&&(this.persp=d.persp);Object.hasOwn(d,"rayOversamp")&&(this.rayOversamp=d.rayOversamp);Object.hasOwn(d,"renderType")&&(this.renderType=d.renderType);Object.hasOwn(d,"sealBorders")&&(this.sealBorders=d.sealBorders);Object.hasOwn(d,"vrBackColor")&&(this.vrBackColor=
b.Color.Clone(d.vrBackColor));Object.hasOwn(d,"opacityCurveStr")?this.opacityCurveStr=d.opacityCurveStr:Object.hasOwn(d,"opacityCurve")&&(this.opacityCurveStr=d.opacityCurve.toString())};b.Settings.prototype.matches=function(d){return this.antiAlias==d.antiAlias&&this.interpType==d.interpType&&this.lightSet.valueEquals(d.lightSet)&&this.opacityCurveStr==d.opacityCurve.toString()&&this.useXrayLut==d.useXrayLut&&this.colorMapIndex==d.colorMapIndex&&this.persp==d.persp&&this.rayOversamp==d.rayOversamp&&
this.renderType==d.renderType&&this.sealBorders==d.sealBorders&&b.Color.AreEqual(this.vrBackColor,d.vrBackColor)?!0:!1};b.Settings.prototype.toJsonString=function(){return JSON.stringify(this,function(b,a){return a.toFixed?Number(a.toFixed(8)):a},4)};b.Settings.FromJsonString=function(d){d=JSON.parse(d);var a=new b.Settings;a.updateFrom(d);a.name=d.name;return a}})(window.BigLime=window.BigLime||{});
(function(b,h){b.Shader=function(b,a,f,c,e,k){this.context=b;this.type=a;this.name=f||"";this.code="";this.glShader=null;this.isCompiled=!1;if(e)for(var d in e)e.hasOwnProperty(d)&&(c=c.split(d).join(e[d]));this.code=c;this.glShader=b.gl.createShader(this.type);b.gl.shaderSource(this.glShader,this.code);("undefined"===typeof k||k)&&this.compile()};b.Shader.prototype.destroy=function(){this.context&&(this.glShader&&this.context.gl.deleteShader(this.glShader),this.context=null,this.code="",this.glShader=
null,this.isCompiled=!1)};b.Shader.prototype.compile=function(){if(!this.isCompiled){var d=this.context.gl;d.compileShader(this.glShader);d.getShaderParameter(this.glShader,d.COMPILE_STATUS)||d.isContextLost()?this.isCompiled=!0:b.Logger.Report("Shader.compile: "+this.name+" compilation error(s):\n"+d.getShaderInfoLog(this.glShader),b.Logger.Severity.Error)}}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=b.Logger.Severity;b.ShaderProgram=function(a,d,c,e,k,g,l){this.context=a;this.name=d||"";this.glProgram=this.fShader=this.vShader=null;this.uniforms={};this.attributes={};this.numVertices=h;this.indexBuffer=null;this.isCompiled=!1;d=this.context.gl;this.vShader=new b.Shader(a,d.VERTEX_SHADER,this.name+"_vshader",c,k,l);this.fShader=new b.Shader(a,d.FRAGMENT_SHADER,this.name+"_fshader",e,g,l);this.glProgram=d.createProgram();d.attachShader(this.glProgram,this.vShader.glShader);
d.attachShader(this.glProgram,this.fShader.glShader);("undefined"===typeof l||l)&&this.compile()};b.ShaderProgram.prototype.destroy=function(){this.context&&(this.glProgram&&this.context.gl.deleteProgram(this.glProgram),this.vShader&&this.vShader.destroy(),this.fShader&&this.fShader.destroy(),this.fShader=this.vShader=this.glProgram=null,this.uniforms={},this.attributes={},this.context=null)};b.ShaderProgram.prototype.compile=function(){if(!this.isCompiled){this.vShader.compile();this.fShader.compile();
var a=this.context.gl,f=this.glProgram;a.linkProgram(f);if(a.getProgramParameter(f,a.LINK_STATUS)||a.isContextLost()){var c,e=a.getProgramParameter(f,a.ACTIVE_UNIFORMS);for(c=0;c<e;++c){var k=a.getActiveUniform(f,c),g=k.name.lastIndexOf("[0]")==k.name.length-3?k.name.slice(0,-3):k.name;this.uniforms[g]={index:c,type:k.type,size:k.size,loc:a.getUniformLocation(f,k.name)}}e=a.getProgramParameter(f,a.ACTIVE_ATTRIBUTES);for(c=0;c<e;++c)k=a.getActiveAttrib(f,c),this.attributes[k.name]={index:c,type:k.type,
size:k.size,loc:a.getAttribLocation(f,k.name),attrBuffer:null,bufferOffset:0};this.isCompiled=!0;a.detachShader(f,this.vShader.glShader);a.detachShader(f,this.fShader.glShader);a.deleteShader(this.vShader.glShader);a.deleteShader(this.fShader.glShader);this.vShader.glShader=null;this.fShader.glShader=null}else b.Logger.Report("ShaderProgram.compile: "+this.name+" link error(s):\n"+a.getProgramInfoLog(f),d.Error)}};b.ShaderProgram.prototype.setUniform=function(a,f,c){this.context.setCurrentProgram(this);
a.lastIndexOf("[0]")==a.length-3&&(a=a.slice(0,-3));var e=this.uniforms[a];e?(a=e.loc,e=this.context.uniformSetters[e.type],a&&e&&e(a,f)):"undefined"===typeof c||c||b.Logger.Report("ShaderProgram.setUniform: Unrecognized uniform: "+a,d.Warn)};b.ShaderProgram.prototype.setUniforms=function(a,b){for(var c in a)a.hasOwnProperty(c)&&this.setUniform(c,a[c],b)};b.ShaderProgram.prototype.getUniform=function(a,b){this.context.setCurrentProgram(this);var c=this.context.gl,d=this.uniforms[a];return d?b===h?
c.getUniform(this.glProgram,d.loc):(a=c.getUniformLocation(this.glProgram,a+"["+b.toString()+"]"))?c.getUniform(this.glProgram,a):null:null};b.ShaderProgram.prototype.hasUniform=function(a){a.lastIndexOf("[0]")==a.length-3&&(a=a.slice(0,-3));return this.uniforms.hasOwnProperty(a)};b.ShaderProgram.prototype.setAttribute=function(a,f,c,e){c=c===h?!0:c;e=e===h?0:e;this.attributes[a]?(this.attributes[a].attrBuffer=f,this.attributes[a].bufferOffset=e,this.numVertices=(f.numBytes-e)/f.bytesPerVertex,c&&
this.bindAttributes([a])):b.Logger.Report("ShaderProgram.setAttribute: Unrecognized attribute: "+a,d.Error)};b.ShaderProgram.prototype.bindAttributes=function(a){a=(a=a===h?[]:a)||[];var b=this.context.gl,c;for(c in this.attributes)if(this.hasAttribute(c)&&(0===a.length||0<=a.indexOf(c))){var d=this.attributes[c];d.attrBuffer&&(b.bindBuffer(b.ARRAY_BUFFER,d.attrBuffer.glBuffer),b.enableVertexAttribArray(d.loc),b.vertexAttribPointer(d.loc,d.attrBuffer.attrDim,d.attrBuffer.dataType,d.attrBuffer.normalizeValues,
0,d.bufferOffset))}};b.ShaderProgram.prototype.hasAttribute=function(a){return this.attributes.hasOwnProperty(a)};b.ShaderProgram.prototype.setIndexBuffer=function(a){this.indexBuffer=a};b.ShaderProgram.prototype.setInputTexture=function(a,b){if(Array.isArray(b)){for(var c=new Int32Array(b.length),d=0;d<b.length;d++)b[d].bind(),c[d]=b[d].txIndex;this.setUniform(a,c)}else b?(b.bind(),this.setUniform(a,b.txIndex)):this.setUniform(a,-1)};b.ShaderProgram.prototype.draw=function(a){var d=this.context.gl,
c=this.indexBuffer?this.indexBuffer.numIndices:this.numVertices,e=0,k=!0,g=[0,0,0,1],h=d.TRIANGLES,m=null,n=[0,0,d.drawingBufferWidth,d.drawingBufferHeight];a&&("undefined"!==typeof a.numVertices&&(c=a.numVertices),"undefined"!==typeof a.firstVertex&&(e=a.firstVertex),"undefined"!==typeof a.clear&&(k=a.clear),"undefined"!==typeof a.clearColor&&(g=b.Color.ScaleTo1(a.clearColor)),"undefined"!==typeof a.drawMode&&(h=a.drawMode),"undefined"!==typeof a.target&&(m=a.target),"undefined"!==typeof a.viewport&&
(n=a.viewport));d.bindFramebuffer(d.FRAMEBUFFER,m?m.glFrameBuffer:null);this.context.setCurrentProgram(this);d.viewport(n[0],n[1],n[2],n[3]);k&&(d.clearColor(g[0],g[1],g[2],g[3]),d.clear(d.COLOR_BUFFER_BIT));this.indexBuffer?(this.indexBuffer.bind(),d.drawElements(h,c,this.indexBuffer.dataType,e*this.indexBuffer.elemSize)):d.drawArrays(h,e,c)}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=glMatrix.vec3;b.Shapes3D=function(){};b.Shapes3D.Cube=function(a,d,c){d=d||[0,0,0];a/=2;a=[-a,-a,-a,+a,-a,-a,-a,+a,-a,-a,+a,-a,+a,-a,-a,+a,+a,-a,+a,-a,-a,+a,-a,+a,+a,+a,-a,+a,+a,-a,+a,-a,+a,+a,+a,+a,-a,+a,-a,+a,+a,-a,-a,+a,+a,-a,+a,+a,+a,+a,-a,+a,+a,+a,-a,-a,+a,-a,+a,+a,+a,-a,+a,-a,+a,+a,+a,+a,+a,+a,-a,+a,-a,-a,-a,-a,+a,-a,-a,-a,+a,-a,+a,-a,-a,+a,+a,-a,-a,+a,-a,-a,-a,-a,-a,+a,+a,-a,-a,-a,-a,+a,+a,-a,+a,+a,-a,-a];for(var e=0;e<a.length;e++)a[e]+=d[e%3];if(!c||!c.length)return a;
d=[];for(e=0;6>e;e++){var f=c[e%c.length];"string"==typeof f&&(f=b.Color.FromName(f,!0));for(var g=0;18>g;g++)d.push(f[g%3])}return{vertices:a,colors:d}};b.Shapes3D.Rectangle=function(a,f,c,e,k,g){var h=[];c=c||[0,0,0];e=e||[1,0,0];k=k||[0,1,0];d.normalize(e,e);d.normalize(k,k);a/=2;f/=2;var m=[0,0,0];d.scaleAndAdd(m,d.scaleAndAdd(m,c,e,-a),k,-f);h=h.concat(m);d.scaleAndAdd(m,d.scaleAndAdd(m,c,e,a),k,-f);h=h.concat(m);d.scaleAndAdd(m,d.scaleAndAdd(m,c,e,a),k,f);h=h.concat(m);d.scaleAndAdd(m,d.scaleAndAdd(m,
c,e,-a),k,-f);h=h.concat(m);d.scaleAndAdd(m,d.scaleAndAdd(m,c,e,a),k,f);h=h.concat(m);d.scaleAndAdd(m,d.scaleAndAdd(m,c,e,-a),k,f);h=h.concat(m);if(!g)return h;c=[];"string"==typeof ccolorol&&(g=b.Color.FromName(g,!0));for(e=0;18>e;e++)c.push(g[e%3]);return{vertices:h,colors:c}}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=glMatrix.vec3,a=glMatrix.mat4;b.Slab=function(b,c,e,k){this.vol=b;this.center=c?d.clone(c):d.scale(d.create(),b.shape,.5);this.shape=e?d.clone(e):d.clone(b.shape);this.orient=k?a.clone(k):a.create()};b.Slab.prototype.clone=function(){return new b.Slab(this.vol,this.center,this.shape,this.orient)};b.Slab.prototype.updateFrom=function(b){d.copy(this.center,b.center);d.copy(this.shape,b.shape);a.copy(this.orient,b.orient)};b.Slab.prototype.reset=function(){d.scale(this.center,this.vol.shape,
.5);d.copy(this.shape,this.vol.shape);a.identity(this.orient)};b.Slab.prototype.getVerticesTx=function(){var a=$jscomp.makeIterator(this.shape),b=a.next().value,e=a.next().value;a=a.next().value;var k=[b/2,e/2,a/2];return[[0,0,0],[b,0,0],[0,e,0],[b,e,0],[0,0,a],[b,0,a],[0,e,a],[b,e,a]].map(function(a){a=d.subtract(d.create(),a,k);d.transformMat4(a,a,this.orient);d.add(a,a,this.center);return d.divide(a,a,this.vol.shape)}.bind(this))}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=b.Logger.Severity;b.Texture2D=function(a,f,c,e,k,g){this.context=a;this.txIndex=f;this.width=Math.round(c);this.height=Math.round(e);this.pixelType=k;this.interpType=g;this.glTexture=null;this.is3D=!1;a=this.context.gl;0>f||f>=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS)?b.Logger.Report("Texture2D.ctor: Invalid texture index.",d.Error):0>=this.width||0>=this.height?b.Logger.Report("Texture2D.ctor: Texture size cannot be zero.",d.Error):(f=this.context.GlMaxTextureSize,this.width>
f||this.height>f?b.Logger.Report("Texture2D.ctor: The requested texture size is too large.",d.Error):(this.glTexture=a.createTexture(),this.bind(),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,this.interpType),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,this.interpType),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texImage2D(a.TEXTURE_2D,0,this.pixelType,this.width,this.height,0,this.pixelType,a.UNSIGNED_BYTE,
null)))};b.Texture2D.prototype.destroy=function(){if(this.context){var a=this.context.gl;this.bind();a.texImage2D(a.TEXTURE_2D,0,this.pixelType,1,1,0,this.pixelType,a.UNSIGNED_BYTE,null);this.unbind();a.deleteTexture(this.glTexture);this.context=this.glTexture=null}};b.Texture2D.prototype.bind=function(){this.context.bindTexture(this)};b.Texture2D.prototype.unbind=function(){this.context.unbindTexture(this)};b.Texture2D.prototype.setInterpType=function(a){if(this.interpType!=a){this.bind();var b=
this.context.gl;b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,a);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,a);this.interpType=a}};b.Texture2D.prototype.sizeEquals=function(a,b){return this.width==a&&this.height==b};b.Texture2D.prototype.resize=function(a,f){a=Math.round(a);f=Math.round(f);if(0>=a||0>=f)b.Logger.Report("Texture2D.resize: Texture size cannot be zero.",d.Error);else{var c=this.context.GlMaxTextureSize;a>c||f>c?b.Logger.Report("Texture2D.resize: Requested texture size is not supported on this device.",
d.Error):(c=this.context.gl,this.bind(),c.texImage2D(c.TEXTURE_2D,0,this.pixelType,a,f,0,this.pixelType,c.UNSIGNED_BYTE,null),this.width=a,this.height=f)}}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=b.Logger.Severity;b.Texture3D=function(a,f,c,e,k,g,h){this.context=a;this.txIndex=f;this.width=Math.round(c);this.height=Math.round(e);this.depth=Math.round(k);this.pixelType=g;this.interpType=h;this.glTexture=null;this.is3D=!0;0>=this.width||0>=this.height||0>=this.depth?b.Logger.Report("Texture3D.ctor: Invalid dimensions.",d.Error):(a=this.context.gl,0>f||f>=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS)?b.Logger.Report("Texture3D.ctor: Invalid texture index.",d.Error):(this.glTexture=
a.createTexture(),this.bind(),a.texParameteri(a.TEXTURE_3D,a.TEXTURE_MIN_FILTER,this.interpType),a.texParameteri(a.TEXTURE_3D,a.TEXTURE_MAG_FILTER,this.interpType),a.texParameteri(a.TEXTURE_3D,a.TEXTURE_WRAP_R,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_3D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_3D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texStorage3D(a.TEXTURE_3D,1,this.pixelType,this.width,this.height,this.depth)))};b.Texture3D.prototype.destroy=function(){if(this.context){var a=this.context.gl;
this.unbind();a.deleteTexture(this.glTexture);this.context=this.glTexture=null}};b.Texture3D.prototype.bind=function(){this.context.bindTexture(this)};b.Texture3D.prototype.unbind=function(){this.context.unbindTexture(this)};b.Texture3D.prototype.setInterpType=function(a){if(this.interpType!=a){this.bind();var b=this.context.gl;b.texParameteri(b.TEXTURE_3D,b.TEXTURE_MIN_FILTER,a);b.texParameteri(b.TEXTURE_3D,b.TEXTURE_MAG_FILTER,a);this.interpType=a}};b.Texture3D.prototype.sizeEquals=function(a,b,
c){return this.width==a&&this.height==b&&this.depth==c}})(window.BigLime=window.BigLime||{});
(function(b,h){b.ThreeDControls=function(d,a,f){this.options=f||{};this.tabs=[];this.pages=[];this.renderParams=new b.RenderParams;this.contentWidth=this.options.width||640;this.contentHeight=this.options.minimal?440:585;b.Dialog.call(this,{parent:d,title:this.options.title||"3D Controls",width:this.contentWidth+"px",height:this.contentHeight+32+"px",bkgndColor:"#cdb79a",titleBarColor:"#cdb79a",borderWidth:f.borderWidth,borderColor:f.borderColor});this.setContent(this._createContentDiv(a))};b.ThreeDControls.prototype=
Object.create(b.Dialog.prototype);b.ThreeDControls.prototype.constructor=b.ThreeDControls;b.ThreeDControls.prototype.setRenderParams=function(b){this.renderParams=b;this.syncWith(b)};b.ThreeDControls.prototype.setPosition=function(d,a){b.Ui.StyleElement(this.mainDiv,{left:d,top:a})};b.ThreeDControls.prototype._createContentDiv=function(d){for(var a=this.contentWidth,f=this.contentHeight,c=f-40-2,e=b.Ui,k=e.CreateElement("div","3dcon_contentdiv",null,{width:a,height:f,userSelect:"none"}),g=this.options.minimal?
["Opacity","Lights"]:["Main","Lights","Misc"],h=e.CreateElement("ul","3dcon_tablist",k,{width:a,height:f,listStyle:"none"}),m=0;m<g.length;m++){var n=m.toString(),p=(2).toString()+"px ",r=e.CreateElement("li","tablistitem",h,null,{dataTab:n});e.StyleElement(r,{width:100,height:40,left:102*m,top:0,textAlign:"center",verticalAlign:"middle",lineHeight:40,borderColor:"gray",borderStyle:"solid",borderWidth:p+p+"0px 0px",backgroundColor:0===m?"#e5cfb2":"#cdb79a"});r.innerHTML=g[m];this.tabs.push(r);n=e.CreateElement("div",
"3dcon_tabpage"+n,k,{width:a,height:c,left:0,top:f-c,display:0===m?"inherit":"none",backgroundColor:"#e5cfb2"});this.pages.push(n)}var q=this;f=function(){for(var a=parseInt(this.dataTab),b=0;b<g.length;b++)b===a?(e.StyleElement(q.pages[b],{display:"inherit"}),e.StyleElement(q.tabs[b],{backgroundColor:"#e5cfb2"})):(e.StyleElement(q.pages[b],{display:"none"}),e.StyleElement(q.tabs[b],{backgroundColor:"#cdb79a"}))};for(h=0;h<g.length;h++)this.tabs[h].addEventListener("click",f);this._createMainPage(this.pages[0]);
1<g.length&&this._createLightingPage(this.pages[1],a,c);2<g.length&&this._createMiscPage(this.pages[2],a,c,d);return k};b.ThreeDControls.prototype._createMainPage=function(d){var a=parseFloat(d.style.width),f=parseFloat(d.style.height),c=this.options.minimal?350:300,e=b.Ui;d=e.CreateElement("div","3dcon_mainpage_div",d,{width:a,height:f,fontSize:16});this.opacityControl=new b.OpacityControl(a-48,c);e.StyleElement(this.opacityControl.mainDiv,{left:24,top:24});d.append(this.opacityControl.mainDiv);
this.opacityControl.addEventListener("opacity-change-start opacity-change opacity-change-end",function(a){this.trigger(a.type,a.detail)}.bind(this));if(!this.options.minimal){a=this.options&&this.options.hideSlabGroup;c+=48;f=e.CreateButtonGroup("3dcon_mode",d,{width:a?180:120,height:170,left:24,top:c,fontSize:16},[{label:"MIP",value:"mip",checked:!0},{label:"VR",value:"vr"}],function(a){this.trigger("mode-change",{mode:a.target.value})}.bind(this),{btnSize:26,btnLeft:a?50:0});this.mipModeBtn=f.btns[0];
this.vrModeBtn=f.btns[1];f=e.CreateButtonGroup("3dcon_slab",d,{width:170,height:170,left:164,top:c,fontSize:16},[{label:"Show Marker",value:"show-marker-change",checked:!0},{label:"Show slab",value:"show-slab-change"},{label:"Clip to slab",value:"clip-to-slab-change"}],function(a){this.trigger(a.target.value,{val:a.target.checked})}.bind(this),{btnSize:26,independent:!0});this.showMarkerBtn=f.btns[0];this.showSlabBtn=f.btns[1];this.clipToSlabBtn=f.btns[2];f.btns[1].addEventListener("dblclick",function(){this.trigger("reset-slab-request")}.bind(this));
a&&(f.div.style.display="none");f=a?43:15;d=e.CreateElement("div","3dcon_persp",d,{width:a?300:180,height:170,top:c,right:24,border:"1px solid #606060"});var k=this.perspInput=e.CreateElement("select","3dcon_perspsel",d,{top:21,left:f,height:30,width:100,fontSize:16});e.CreateElement("option","3dcon_perspsel_0",k,{},{value:0,text:"Off"});e.CreateElement("option","3dcon_perspsel_0",k,{},{value:1,text:"Low"});e.CreateElement("option","3dcon_perspsel_2",k,{},{value:3,text:"Medium"});e.CreateElement("option",
"3dcon_perspsel_3",k,{},{value:8,text:"High"});k.value=0;k.addEventListener("change",function(){this.trigger("persp-change",{val:parseInt(k.value)})}.bind(this));e.CreateElement("label","3dcon_persp_label",d,{left:f+110,top:25},{innerHTML:"Perspective"});this.saveSettingsBtn=e.CreateSaveFileButton({id:"3dcon_savesettings_btn",parent:d,text:"Save Settings",flatStyle:!1,dbTag:"threedControlsSaveSettings",suggestedName:"Settings.txt",callback:this._onSaveSettings.bind(this),styles:{width:210,height:30,
top:72,left:f,fontSize:14}});this.loadSettingsBtn=e.CreateLoadFileButton({id:"3dcon_loadsettings_btn",parent:d,text:"Load Settings",flatStyle:!1,dbTag:"threedControlsLoadSettings",multiple:!1,callback:this._onLoadSettings.bind(this),styles:{width:210,height:30,top:122,left:f,fontSize:14}})}};b.ThreeDControls.prototype._createLightingPage=function(d,a,f){var c=b.Ui;d=c.CreateElement("div","3dcon_page_div",d,{width:a,height:f-30,top:30,fontSize:16});this.ambientSlider=c.CreateHSlider("3dcon_ambient",
d,{styles:{width:a-64,height:50,left:32,top:0},props:{}},{styles:{},props:{min:0,max:200,value:50,valueScale:.01}},{styles:{width:80},props:{innerHTML:"Ambient"}},{styles:{width:60},props:{}},function(a){this.renderParams.lightSet.ambientLight=a;this.trigger("change")}.bind(this),function(){this.trigger("change-start")}.bind(this),function(){this.trigger("change-end")}.bind(this));c.CreateElement("label","3dcon_lightsel_label",d,{left:32,top:115},{innerHTML:"Light #"});var e=this.lightSel=c.CreateElement("select",
"3dcon_lightsel_inp",d,{top:110,left:112,height:30,width:70});c.CreateElement("option","3dcon_lightsel_1",e,{},{value:0,text:"1"});c.CreateElement("option","3dcon_lightsel_2",e,{},{value:1,text:"2"});e.value=0;e.addEventListener("change",function(){var a=this.renderParams.lightSet.dirLights[this.lightSel.value];this.diffuseSlider.value=Math.round(100*a.diffuse);this.shadowsSlider.value=Math.round(100*a.shadowDarkness);this.specExpSlider.value=Math.round(100*Math.log2(a.specExp));this.specStrengthSlider.value=
Math.round(100*a.specStrength);this.shadowsSlider.value=Math.round(100*a.shadowDarkness);this.diffuseSlider.valLabel.innerHTML=a.diffuse.toFixed(2);this.specExpSlider.valLabel.innerHTML=a.specExp.toFixed(0);this.shadowsSlider.valLabel.innerHTML=a.shadowDarkness.toFixed(2);this.specStrengthSlider.valLabel.innerHTML=a.specStrength.toFixed(2);this.lightPositioner.setLightDirection(a.dir)}.bind(this));this.diffuseSlider=c.CreateHSlider("3dcon_diffuse",d,{styles:{width:a-300,height:50,left:32,top:150},
props:{}},{styles:{},props:{min:0,max:100,value:50,valueScale:.01}},{styles:{width:80},props:{innerHTML:"Diffuse"}},{styles:{width:50},props:{}},function(a){this.renderParams.lightSet.dirLights[e.value].diffuse=a;this.trigger("change")}.bind(this),function(){this.trigger("change-start")}.bind(this),function(){this.trigger("change-end")}.bind(this));this.specStrengthSlider=c.CreateHSlider("3dcon_specstr",d,{styles:{width:a-300,height:50,left:32,top:200},props:{}},{styles:{},props:{min:0,max:100,value:50,
valueScale:.01}},{styles:{width:80},props:{innerHTML:"Specular"}},{styles:{width:50},props:{}},function(a){this.renderParams.lightSet.dirLights[e.value].specStrength=a;this.trigger("change")}.bind(this),function(){this.trigger("change-start")}.bind(this),function(){this.trigger("change-end")}.bind(this));this.specExpSlider=c.CreateHSlider("3dcon_specstr",d,{styles:{width:a-300,height:50,left:32,top:250},props:{}},{styles:{},props:{min:0,max:1E3,value:700,decimals:0,xfrm:function(a){return Math.round(Math.pow(2,
a/100))}}},{styles:{width:80},props:{innerHTML:"Spec Exp"}},{styles:{width:50},props:{}},function(a){this.renderParams.lightSet.dirLights[e.value].specExp=a;this.trigger("change")}.bind(this),function(){this.trigger("change-start")}.bind(this),function(){this.trigger("change-end")}.bind(this));this.shadowsSlider=c.CreateHSlider("3dcon_specstr",d,{styles:{width:a-300,height:50,left:32,top:300},props:{}},{styles:{},props:{min:0,max:150,value:50,valueScale:.01}},{styles:{width:80},props:{innerHTML:"Shadows"}},
{styles:{width:50},props:{}},function(a){this.renderParams.lightSet.dirLights[e.value].shadowDarkness=a;this.trigger("change")}.bind(this),function(){this.trigger("change-start")}.bind(this),function(){this.trigger("change-end")}.bind(this));c.CreateElement("label","3dcon_lightpos_label",d,{right:90,top:95},{innerHTML:"Light Position"});a=c.CreateElement("div","3dcon_lightpos",d,{width:240,height:240,top:110,right:15});var k=this.lightPositioner=new b.LightPositioner(a);k.addEventListener("change",
function(){this.renderParams.lightSet.dirLights[e.value].dir=k.getLightDirection()}.bind(this));k.addEventListener("changeStart",function(){this.trigger("change-start")}.bind(this));k.addEventListener("changeEnd",function(){this.trigger("change-end")}.bind(this))};b.ThreeDControls.prototype._createMiscPage=function(d,a,f,c){var e=b.Ui;d=e.CreateElement("div","3dcon_page_div",d,{width:a,height:f-20,top:20,left:0,fontSize:16});this.antiAliasBtn=e.CreateButtonGroup("3dcon_antialias",d,{width:230,height:80,
left:32,top:10,fontSize:16},[{label:"Anti-alias",value:"",checked:!0}],function(a){this.trigger("antialias-change",{val:a.target.checked})}.bind(this),{btnSize:26,independent:!0}).btns[0];e.CreateElement("label","3dcon_respon_title",d,{width:200,height:40,top:125,left:32,fontSize:16},{innerHTML:"Interactive quality"});this.iQualBtns=e.CreateButtonGroup("3dcon_respon",d,{width:230,height:200,left:32,top:150,fontSize:16},[{label:"1  Highest",value:1},{label:"2  Medium",value:.5,checked:!0},{label:"3  Lower",
value:.25},{label:"4  Lowest",value:.125}],function(a){this.trigger("iqual-change",{val:a.target.value})}.bind(this),{btnSize:26}).btns;e.CreateElement("label","3dcon_speedtest_title",d,{width:160,height:40,bottom:95,left:32,fontSize:16},{innerHTML:"Speed test"});a=e.CreateElement("div","3dcon_speedtest",d,{width:230,height:80,bottom:25,left:32,border:"1px solid #606060"});var k=e.CreateElement("label","3dcon_speedtest_fps",a,{width:80,height:40,top:30,left:125,fontSize:16},{innerHTML:"FPS: 0"}),
g=e.CreateElement("button","3dcon_speedtest_btn",a,{width:80,height:40,top:20,left:30,fontSize:16});g.innerHTML="Run";g.addEventListener("click",function(){this.trigger("speedtest-toggle",{stateChangeCb:function(a){g.innerHTML="started"==a?"Stop":"Run"}.bind(this),fpsChangeCb:function(a){k.innerHTML="FPS: "+(a?a.toFixed(0):"--")}.bind(this)})}.bind(this));e.CreateElement("div","3dcon_infobox",d,{top:10,bottom:25,left:300,right:32,padding:10,border:"1px solid #606060",fontSize:16}).innerHTML="GL version: "+
c.GlVersionInfo+"<br/><br/>Renderer: "+c.RendererInfo+"<br/><br/>App build: "+b.Utils.getBuildInfo()};b.ThreeDControls.prototype.syncWith=function(d){var a=d.renderType===b.RenderType.VR,f=d.opacityCurve||b.OpacityCurve.FromString(d.opacityCurveStr);this.opacityControl.setOpacityCurve(f,!0);f=d.lightSet.dirLights[this.lightSel.value];this.ambientSlider.value=Math.round(100*d.lightSet.ambientLight);this.diffuseSlider.value=Math.round(100*f.diffuse);this.shadowsSlider.value=Math.round(100*f.shadowDarkness);
this.specExpSlider.value=Math.round(100*Math.log2(f.specExp));this.specStrengthSlider.value=Math.round(100*f.specStrength);this.shadowsSlider.value=Math.round(100*f.shadowDarkness);this.ambientSlider.valLabel.innerHTML=d.lightSet.ambientLight.toFixed(2);this.diffuseSlider.valLabel.innerHTML=f.diffuse.toFixed(2);this.specExpSlider.valLabel.innerHTML=f.specExp.toFixed(0);this.shadowsSlider.valLabel.innerHTML=f.shadowDarkness.toFixed(2);this.specStrengthSlider.valLabel.innerHTML=f.specStrength.toFixed(2);
this.lightPositioner.setLightDirection(f.dir);if(!this.options.minimal)for(this.vrModeBtn.checked=a,this.mipModeBtn.checked=!a,d instanceof b.RenderParam&&(this.showMarkerBtn.checked=d.showMarker,this.showSlabBtn.checked=d.showSlab,this.clipToSlabBtn.checked=d.clipToSlab),this.perspInput.value=d.persp,this.antiAliasBtn.checked=d.antiAlias,this.iQualBtns[1].checked=!0,d=$jscomp.makeIterator(this.iQualBtns),a=d.next();!a.done;a=d.next())a=a.value,parseFloat(a.value)===engine.fastDrawFactor&&(a.checked=
!0)};b.ThreeDControls.prototype._onSaveSettings=function(b){this.trigger("save-settings-request",{fileHandle:b})};b.ThreeDControls.prototype._onLoadSettings=function(d){if(d&&d.length){var a=new FileReader;a.onload=function(a){this.loadSettingsBtn.disabled=!1;try{var c=new b.Settings(JSON.parse(a.target.result));this.trigger("settings-file-loaded",{val:c})}catch(e){b.Logger.Report("Failed to read settings file",b.Logger.Severity.Warn,!0)}}.bind(this);a.onerror=function(){b.Logger.Report("Failed to read settings file",
b.Logger.Severity.Warn,!0);this.loadSettingsBtn.disabled=!1};d[0].getFile().then(function(b){a.readAsText(b)}).catch(function(){this.loadSettingsBtn.disabled=!1}.bind(this))}else this.loadSettingsBtn.disabled=!1};b.ThreeDControls.prototype.addEventListener=function(d,a){b.Notifier.prototype.addEventListener.call(this,d,a)};b.ThreeDControls.prototype.removeEventListener=function(d,a){b.Notifier.prototype.removeEventListener.call(this,d,a)};b.ThreeDControls.prototype.trigger=function(d,a){b.Notifier.prototype.trigger.call(this,
d,a)}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=glMatrix.vec2,a=glMatrix.vec3,f=glMatrix.mat4;b.ThreeDViewer=function(a){a=a===h?{}:a;this.site=a.site;this.controller=a.controller;this.canvas=b.Ui.CreateElement("canvas","threedviewer_canvas",this.site,{width:"100%",height:"100%",backgroundColor:"#000000"});this.canvas.addEventListener("contextmenu",function(a){a.preventDefault()});this.renderEngine=a.renderEngine?a.renderEngine:new b.RenderEngine({options:a.engineOptions});this.ownsEngine=!a.renderEngine;this.renderParams=
new b.RenderParams;this.renderParams.slab=new b.Slab(this.renderEngine.volume);this.renderParams.persp=2;this.defaultOrient=b.Utils.GetRotMatrix([1,0,0],[0,0,-1]);this.fastDrawDownsamp=.5;this.renderCallbacks=[];this.resizeTimerId=null;var c=this.renderEngine.ctx;this.slabLinesInfo={vertexBuffer:c.createAttrBuffer(new Float32Array(144),3,{drawMode:c.gl.DYNAMIC_DRAW}),attrBuffer:c.createAttrBuffer(new Float32Array(192),4,{drawMode:c.gl.STATIC_DRAW}),numLines:0};this.slabLinesInfo.attrBuffer.setData(Array.from({length:96},
function(a,b){return 0==b%2?0:1}));this.controller&&(this.controllerListener=this._onControllerEvent.bind(this),this.controller.addEventListener("AllEvents",this.controllerListener));a.omitInteractor||(this.interactor=new b.MultiInteractor(this.canvas),this.interactor.addEventListener("start move end",this._onInteractorEvent.bind(this)));!1!==a.autoResize&&(this.resizeListener=this.onResize.bind(this),window.addEventListener("resize",this.resizeListener));this.onResize()};b.ThreeDViewer.prototype.destroy=
function(){this.renderEngine&&(clearTimeout(this.resizeTimerId),this.resizeListener&&window.removeEventListener("resize",this.resizeListener),b.Utils.cancelAnimFrame(this.rafId),this.interactor&&this.interactor.stopListening(),this.controllerListener&&this.controller.removeEventListener("AllEvents",this.controllerListener),this.ownsEngine&&this.renderEngine.destroy(),this.renderEngine=null,this.canvas.remove())};b.ThreeDViewer.prototype.onResize=function(a){var c=this.canvas.getBoundingClientRect();
this.canvas.width=Math.round(c.width);this.canvas.height=Math.round(c.height);this.rafId=b.Utils.requestAnimFrame(this.render.bind(this));a?this.resizeTimerId=null:(this.resizeTimerId&&clearTimeout(this.resizeTimerId),this.resizeTimerId=setTimeout(function(){this.onResize(!0)}.bind(this),300))};b.ThreeDViewer.prototype.clear=function(){this.canvas.getContext("2d").clearRect(0,0,this.canvas.width,this.canvas.height)};b.ThreeDViewer.prototype.loadVolume=function(a,b,d,f){var c=function(a,b){if(!a)this.onNewVolumeLoaded();
d&&d(a,b,this)}.bind(this);this.renderEngine.loadVolume({imgFiles:a,loader:b,completionCb:c,progressCb:f,omitRender:!0,omitResetView:!0})};b.ThreeDViewer.prototype.cancelLoading=function(){this.renderEngine.cancelLoading()};b.ThreeDViewer.prototype.onNewVolumeLoaded=function(){};b.ThreeDViewer.prototype.render=function(){var a=this,b=this.renderEngine;if(b.hasImageData()){b.setRenderParams(this.renderParams);var d=b.isAnimating()?this.fastDrawDownsamp:1;b.sizeRasterFor(this.canvas,d);b.render(this.calcSlabLines.bind(this));
d=this.canvas.getContext("2d");var f=$jscomp.makeIterator([this.canvas.width,this.canvas.height]),h=f.next().value;f=f.next().value;var m=$jscomp.makeIterator([b.canvas.width,b.canvas.height]);m.next();m=m.next().value;var n=$jscomp.makeIterator([b.viewport[2],b.viewport[3]]),p=n.next().value;n=n.next().value;d.clearRect(0,0,h,f);d.drawImage(b.canvas,0,m-n,p,n,0,0,h,f);this.renderCallbacks.forEach(function(b){b(a)})}};b.ThreeDViewer.prototype._onInteractorEvent=function(a){var b=this.renderEngine,
c=this.renderParams,g=this.interactor;if("start"==a.type)g.setInitialValues({zoom:c.zoom,pan:c.pan,rot:c.rotMatrix,lighting:{ambient:c.lightSet.ambientLight,shadow:c.lightSet.dirLights[0].shadowDarkness}}),b.animate(15,this.render.bind(this));else if("move"==a.type)switch(g.interactMode){case "zoom":case "wheelzoom":c.zoom=g.currentZoom;break;case "pan":d.copy(c.pan,g.currentPan);break;case "panzoom":c.zoom=g.currentZoom;d.copy(c.pan,g.currentPan);break;case "rotate":f.copy(c.rotMatrix,g.currentRot);
break;case "light":c.lightSet.ambientLight=g.ambient,c.lightSet.dirLights[0].shadowDarkness=g.shadow}else"end"==a.type&&(b.stopAnimation(),this.render())};b.ThreeDViewer.prototype._onControllerEvent=function(a){var b=this.renderParams,c=this.renderEngine;switch(a.type){case "change-start":case "opacity-change-start":c.animate(5,this.render.bind(this));break;case "change-end":case "opacity-change-end":c.stopAnimation(),this.render();case "change":this.renderEngine.isAnimating()||this.render();break;
case "opacity-change":b.opacityCurve=a.detail.opCurve;this.renderEngine.isAnimating()||this.render();break;case "antialias-change":b.antiAlias=a.detail.val;this.render();break;case "iqual-change":this.fastDrawDownsamp=parseFloat(a.detail.val)}};b.ThreeDViewer.prototype.setPerspectiveFactor=function(a){var b=this.renderParams,c=b.persp;b.persp=a;b.zoom*=this._calcPerspectiveZoomFactor(b.persp)/this._calcPerspectiveZoomFactor(c)};b.ThreeDViewer.prototype.setDefaultOrientation=function(a){f.copy(this.defaultOrient,
a)};b.ThreeDViewer.prototype.resetOrientation=function(){f.copy(this.renderParams.rotMatrix,this.defaultOrient)};b.ThreeDViewer.prototype.resetZoom=function(){var a=this.renderParams;a.zoom=this.calcDefaultOrthoZoom()*this._calcPerspectiveZoomFactor(a.persp)};b.ThreeDViewer.prototype.resetPan=function(){d.copy(this.renderParams.pan,[0,0])};b.ThreeDViewer.prototype.resetWindowWidthAndLevel=function(){var a=$jscomp.makeIterator(this.renderEngine.volume.getAutoWinLevel());this.renderParams.winWidth=
a.next().value;this.renderParams.winLevel=a.next().value};b.ThreeDViewer.prototype.calcDefaultOrthoZoom=function(){var a=1;if(this.renderEngine.hasImageData()){a=this.renderEngine.volume;var b=[this.defaultOrient[1],this.defaultOrient[5],this.defaultOrient[9]],d=[this.defaultOrient[0],this.defaultOrient[4],this.defaultOrient[8]].reduce(function(a,b,c,d){return Math.abs(b)>Math.abs(d[a])?c:a},0);b=b.reduce(function(a,b,c,d){return Math.abs(b)>Math.abs(d[a])?c:a},0);var f=this.canvas.width/this.canvas.height;
a=a.shape[d]/a.shape[b]>f?a.diagSize/a.shape[d]*Math.max(1,f):a.diagSize/a.shape[b]*Math.max(1,1/f)}return a};b.ThreeDViewer.prototype._calcPerspectiveZoomFactor=function(b){var c=this.renderEngine.calcTransforms(this.renderParams,this.canvas.height/this.canvas.width,{omitLights:!0}),d=a.fromValues(.5,.5,.5);a.transformMat4(d,d,c.mvp);return 1+Math.max(0,1-Math.abs(d[2]))*b};b.ThreeDViewer.prototype.calcSlabLines=function(b){function c(b,c,d,e,g,k){var l=a.subtract(a.create(),b[e],b[d]);a.normalize(l,
l);b=a.subtract(a.create(),b[g],b[d]);a.normalize(b,b);if(1E-4<l[0]*b[1]-l[1]*b[0])for(d=[d,e,d,g,k,e,k,g],e=0;8>e;e+=2)k=$jscomp.makeIterator([d[e],d[e+1]]),g=k.next().value,k=k.next().value,l=g<k?10*g+k:10*k+g,h.includes(l)||(h.push(l),f.set(c[g],m),f.set(c[k],m+3),m+=6)}var d=this.renderParams.slab;if(!d)return null;var f=new Float32Array(144),h=[],m=0,n=d.getVerticesTx().map(function(b){return a.subtract(a.create(),b,[.5,.5,.5])}),p=this.renderParams,r=n.map(function(c){c=a.transformMat4(a.create(),
c,b.mvp);var d=1+p.persp*(c[2]+1);return a.divide(c,c,[d,d,1])});[[0,1,2,3],[1,5,3,7],[2,3,6,7],[4,0,6,2],[4,5,0,1],[5,4,7,6]].forEach(function(a){c.apply(null,[r,n].concat($jscomp.arrayFromIterable(a)))});this.slabLinesInfo.vertexBuffer.setData(f);this.slabLinesInfo.numLines=m/6;return this.slabLinesInfo};b.ThreeDViewer.prototype.txToViewport=function(b){var c=this.renderParams,d=$jscomp.makeIterator([this.canvas.width,this.canvas.height]),f=d.next().value;d=d.next().value;var h=this.renderEngine.calcTransforms(c,
d/f,{omitLights:!0});b=a.subtract(a.create(),b,[.5,.5,.5]);b=a.transformMat4(a.create(),b,h.mvp);c=1+c.persp*(b[2]+1);a.divide(b,b,[c,c,1]);return[(1+b[0])*f/2,(1-b[1])*d/2]};b.ThreeDViewer.prototype.viewportToTx=function(b,d){d=d===h?0:d;var c=$jscomp.makeIterator([this.canvas.width,this.canvas.height]),e=c.next().value;c=c.next().value;b=[2*b[0]/e-1,1-2*b[1]/c,d];var f=this.renderParams;d=1+f.persp*(d+1);a.multiply(b,b,[d,d,1]);e=this.renderEngine.calcTransforms(f,c/e,{omitLights:!0});e=a.transformMat4(a.create(),
b,e.mvpInv);return a.add(a.create(),e,[.5,.5,.5])}})(window.BigLime=window.BigLime||{});
(function(b,h){var d=glMatrix.vec3;b.TiffLoader3D=function(a){b.Loader3D.call(this);this.imgBufferArray=null;this.fileList=[];this.extraAttrs=a};b.TiffLoader3D.prototype=Object.create(b.Loader3D.prototype);b.TiffLoader3D.prototype.constructor=b.TiffLoader3D;b.TiffLoader3D.prototype.getImageDims=function(a){return $jscomp.asyncExecutePromiseGeneratorProgram(function(b){return b.return(new Promise(function(b,d){try{var c=new FileReader;c.onload=function(){try{var a=UTIF.decode(c.result);b([a[0].t256[0],
a[0].t257[0]])}catch(l){d(l)}};c.onerror=function(a){d(a)};a instanceof FileSystemFileHandle?a.getFile().then(function(a){c.readAsArrayBuffer(a)}).catch(function(a){d(a)}):c.readAsArrayBuffer(a)}catch(g){d(g)}}))})};b.TiffLoader3D.prototype.loadImagesIntoVolume=function(a,b,c,d){this.fileList=[];Array.prototype.push.apply(this.fileList,a);this.vol=b;this.warnings=this.errors=null;this.done=!1;this.loadCompleteCb=c;this.loadProgressCb=d;if(this.fileList&&this.fileList.length)if(this.fileList.some(function(a){return!(a instanceof
FileSystemFileHandle)&&!(a instanceof File)}))this.done=!0,this.errors="TiffLoader3D: Invalid item in file list.",this.loadCompleteCb&&this.loadCompleteCb(this);else{var e=new FileReader;e.onload=function(){this._onInitialImageLoaded(e)}.bind(this);e.onerror=function(){this._onImageLoadingError(e)}.bind(this);(a=this.fileList.find(function(a){return!a.name.toLowerCase().startsWith("slicegap")}))?(this.loadProgressCb&&this.loadProgressCb(0,this.fileList.length),a instanceof FileSystemFileHandle?a.getFile().then(function(a){e.readAsArrayBuffer(a)}).catch(function(a){this._onImageLoadingError(e)}.bind(this)):
e.readAsArrayBuffer(a)):this.done||(this.done=!0,this.errors="No tiff files were specified.",this.loadCompleteCb&&this.loadCompleteCb(this))}else this.done=!0,this.warnings="TiffLoader3D: No files were loaded, because the supplied file list was empty.",this.loadCompleteCb&&this.loadCompleteCb(this)};b.TiffLoader3D.prototype._onInitialImageLoaded=function(a){if(!this.cancelled)try{var f=UTIF.decode(a.result);if(1<f.length)this._handleMultiImageTiff(a.result,f);else{UTIF.decodeImage(a.result,f[0]);
var c=f[0].isLE?"little":"big",e=f[0].width,h=f[0].height,g=f[0].t258[0],l=1,m=!1,n=this.fileList.find(function(a){return a.name.toLowerCase().startsWith("slicegap")});if(n)try{l=parseFloat(n.name.substring(8)),0>l&&(m=!0),l=Math.abs(l)}catch(x){b.Logger.Report("Failed to read slice gap. Defaulting to 1.0.",b.Logger.Severity.Warn)}this.fileList=this.fileList.filter(function(a){return!a.name.toLowerCase().startsWith("slicegap")});this.fileList=m?this.fileList.sort(function(a,b){return a.name.localeCompare(b.name)}):
this.fileList.sort(function(a,b){return b.name.localeCompare(a.name)});if(this.errors=this.vol.loadBegin([e,h,this.fileList.length],g,c))this.done=!0,this.loadCompleteCb&&this.loadCompleteCb(this);else{this.vol.setAttr("modality","Tiff");this.vol.setAttr("rescaleSlope",1);this.vol.setAttr("rescaleIntercept",0);this.vol.setAttr("dataOffset",0);this.vol.setAttr("sliceGap",l);this.vol.setAttr("rowDir",d.fromValues(1,0,0));this.vol.setAttr("colDir",d.fromValues(0,1,0));this.vol.calcNearLphAxes();try{if(this.extraAttrs)for(var p=
$jscomp.makeIterator(this.extraAttrs),r=p.next();!r.done;r=p.next()){var q=r.value,u=f[0]["t"+q[0].toString()];Array.isArray(u)&&(u=u[0]);u||0===u||(u="");this.vol.setAttr(q[1],u.toString())}}catch(x){}this.imgBufferArray=Array(4);this._loadNextBatch(0)}}}catch(x){this._onImageLoadingError(a)}};b.TiffLoader3D.prototype._loadNextBatch=function(a){var b=8==this.vol.bpp?4:2;b=Math.min(b,this.vol.dims[2]-a);for(var c={startIndex:a,endIndex:a+b,numLeftToLoad:b,imgBuffers:this.imgBufferArray},d=0;d<b;d++)this._loadSingleImage(a+
d,c)};b.TiffLoader3D.prototype._loadSingleImage=function(a,b){var c=new FileReader;c.fileName=this.fileList[a].name;c.batchInfo=b;c.onload=function(){this._onImageLoaded(a,c)}.bind(this);c.onerror=function(){this._onImageLoadingError(c)}.bind(this);b=this.fileList[a];if(b instanceof FileSystemFileHandle)try{b.getFile().then(function(a){c.readAsArrayBuffer(a)})}catch(e){this._onImageLoadingError(c)}else c.readAsArrayBuffer(b)};b.TiffLoader3D.prototype._onImageLoadingError=function(a){this.cancelled||
this.done||(this.done=!0,this.errors="Error loading image "+(a.fileName||""),this.loadCompleteCb&&this.loadCompleteCb(this))};b.TiffLoader3D.prototype._onImageLoaded=function(a,b){if(!this.done&&!this.cancelled)try{var c=UTIF.decode(b.result);UTIF.decodeImage(b.result,c[0]);var d=b.batchInfo;d.imgBuffers[a-d.startIndex]=16==this.vol.bpp?new Uint16Array(c[0].data.buffer):new Uint8Array(c[0].data.buffer);d.numLeftToLoad--;this.loadProgressCb&&this.loadProgressCb(d.endIndex-d.numLeftToLoad,this.vol.dims[2]);
0===d.numLeftToLoad&&(this._copyImagesToTexture(d),d.endIndex<this.vol.dims[2]?this._loadNextBatch(d.endIndex):this.done||(this.vol.loadEnd(),this.done=!0,this.loadCompleteCb&&this.loadCompleteCb(this)))}catch(k){this._onImageLoadingError(b)}};b.TiffLoader3D.prototype._handleMultiImageTiff=function(a,b){var c=this,e,f,g,h,m,n,p,r,q,u,x,z,t,y,I,H,Q;return $jscomp.asyncExecutePromiseGeneratorProgram(function(k){switch(k.nextAddress){case 1:k.setCatchFinallyBlocks(2);UTIF.decodeImage(a,b[0]);e=b[0].isLE?
"little":"big";f=b[0].width;g=b[0].height;h=b.length;m=b[0].t258[0];n=1;if(p=c.fileList.find(function(a){return a.name.toLowerCase().startsWith("slicegap")}))try{n=parseFloat(p.name.substring(8))}catch(B){Lib3D.MiscUtils.reportMessage("Failed to read slice gap. Defaulting to 1.0")}r=[f,g,h];c.errors=c.vol.loadBegin(r,m,e);if(c.errors)return c.done=!0,c.loadCompleteCb&&c.loadCompleteCb(c),k.return();c.vol.setAttr("modality","Tiff");c.vol.setAttr("rescaleSlope",1);c.vol.setAttr("rescaleIntercept",0);
c.vol.setAttr("dataOffset",0);c.vol.setAttr("sliceGap",n);c.vol.setAttr("rowDir",d.fromValues(1,0,0));c.vol.setAttr("colDir",d.fromValues(0,1,0));c.vol.calcNearLphAxes();try{if(c.extraAttrs)for(q=$jscomp.makeIterator(c.extraAttrs),u=q.next();!u.done;u=q.next())x=u.value,z=b[0]["t"+x[0].toString()],Array.isArray(z)&&(z=z[0]),z||0===z||(z=""),c.vol.setAttr(x[1],z.toString())}catch(B){}c.imgBufferArray=Array(4);t=8==c.vol.bpp?4:2;b=b.slice().reverse();y=0;case 4:if(!(y<h)){k.leaveTryBlock(0);break}t=
Math.min(t,h-y);I={startIndex:y,endIndex:y+t,numLeftToLoad:t,imgBuffers:c.imgBufferArray};for(H=0;H<t;H++)if(Q=I.startIndex+H,0<Q&&(b[Q-1].data=null),UTIF.decodeImage(a,b[Q]),I.imgBuffers[H]=16==c.vol.bpp?new Uint16Array(b[Q].data.buffer):new Uint8Array(b[Q].data.buffer),I.numLeftToLoad--,0===I.numLeftToLoad&&(c._copyImagesToTexture(I),I.endIndex==h&&!c.done))return c.vol.loadEnd(),c.done=!0,c.loadCompleteCb&&c.loadCompleteCb(c),k.return();if(!c.loadProgressCb){k.jumpTo(7);break}c.loadProgressCb(I.endIndex-
I.numLeftToLoad,c.vol.dims[2]);return k.yield(new Promise(function(a){return setTimeout(a,5)}),8);case 8:if(c.cancelled)return k.return();case 7:y+=t;k.jumpTo(4);break;case 2:k.enterCatchBlock(),c._onImageLoadingError(fileReader),k.jumpToEnd()}})}})(window.BigLime=window.BigLime||{});
(function(b,h){b.VolumeT2=function(d,a){this.context=d;this.dims=[1,1,1];this.sliceGap=1;this.bpp=0;this.bigEndian=!1;this.sizeInBytes=0;this.shape=[1,1,1];this.diagSize=Math.sqrt(3);this.aspect=[1,1,1];this.attrs={};this.textures=[];this.txInfo=null;this.maxNumTextures=a;this.interpType=b.Interp3D.TriLinear;this.histogram=new b.Histogram3D(65536);this.loaded=!1;this.autoWinLevel=this.opacityRange=null;this.meshManager=new b.MeshManager(this);this.calcNearLphAxes()};b.VolumeT2.prototype.destroy=function(){if(this.context){for(var b=
0;b<this.textures.length;b++)this.textures[b].destroy();this.textures=[];this.context=this.nearLphAxes=this.attrs=this.dims=null}};b.VolumeT2.prototype.setInterpType=function(d){if(!(this.interpType=d)){this.interpType=d;var a=this.context.gl;d=d==b.Interp3D.NN?a.NEAREST:a.LINEAR;for(a=0;a<this.textures.length;a++)this.textures[a].setInterpType(d)}};b.VolumeT2.prototype.numTextures=function(){return this.textures.length};b.VolumeT2.prototype.addMesh=function(b){this.meshManager.addMesh(b)};b.VolumeT2.prototype.removeMesh=
function(b){return this.meshManager.removeMesh(b)};b.VolumeT2.prototype.removeAllMeshes=function(){return this.meshManager.removeAllMeshes()};b.VolumeT2.prototype.containsMesh=function(b){return this.meshManager.contains(b)};b.VolumeT2.prototype.loadBegin=function(d,a,f){this.loaded=!1;this.histogram.clear();this.autoWinLevel=this.opacityRange=null;this.sliceGap=1;this.meshManager.removeAllMeshes();if(8!=a&&16!=a)return"Unsupported bits-per-pixel.";var c=b.VolumeT2._calcMosaicTextureParams(d,a,this.context);
if(c.count>this.maxNumTextures)return"Volume is too large for this device.";try{this.dims=[d[0],d[1],d[2]];this.bpp=a;this.bigEndian=f.toLowerCase().startsWith("b");this.txInfo=c;this.sizeInBytes=a/8*d[1]*d[2]*d[0];var e=c.count,h=this.textures;this.textures=[];var g;for(g=e;g<h.length;g++)h[g].destroy();var l=this.context.gl;for(g=0;g<e;g++){var m=c.dims[g<e-1?0:2],n=c.dims[g<e-1?1:3];if(g<h.length&&h[g].sizeEquals(m,n))this.textures.push(h[g]);else{g<h.length&&h[g].destroy();var p=new b.Texture2D(this.context,
g,m,n,l.RGBA,l.LINEAR);p.setInterpType(this.interpType==b.Interp3D.NN?l.NEAREST:l.LINEAR);this.textures.push(p)}}}catch(r){return"Error configuring volume\n\n"+r.message}};b.VolumeT2._calcMosaicTextureParams=function(b,a,f){var c=b[0],d=b[1];b=b[2];var h=f.GlMaxTextureSize;a=32/a;f=Math.min(Math.floor(h/c),Math.ceil(Math.sqrt(b/a)));h=Math.min(Math.floor(h/d),Math.ceil(b/(f*a)));var g=f*h*a,l=Math.ceil(b/g);b=Math.ceil((b-(l-1)*g)/(f*a));return{count:l,dims:[f*c,h*d,f*c,b*d],mosaicDims:[f,h,f,b],
NTx:f,NTy:h,imgsPerTile:a,imgsPerTexture:g,tilesPerTexture:f*h}};b.VolumeT2.prototype.loadEnd=function(){this.loaded=!0;this.shape=[this.dims[0],this.dims[1],this.dims[2]*this.sliceGap];this.diagSize=glMatrix.vec3.length(this.shape);glMatrix.vec3.scale(this.aspect,this.shape,1/Math.max.apply(Math,$jscomp.arrayFromIterable(this.shape)))};b.VolumeT2.prototype.setAttr=function(b,a){b=b.toLowerCase();this.attrs[b]=a;"slicegap"==b&&(this.sliceGap=Number(a))};b.VolumeT2.prototype.getAttr=function(b,a){b=
this.attrs[b.toLowerCase()];if("undefined"===typeof b||null===b)b=a;return b};b.VolumeT2.prototype.modality=function(){return this.getAttr("modality","").toUpperCase()};b.VolumeT2.prototype.getOpacityRange=function(){if(this.opacityRange)return this.opacityRange;if("CT"==this.modality()){var b=this.getAttr("rescaleSlope",1);var a=(-1024-this.getAttr("rescaleIntercept",0))/b-this.getAttr("dataOffset",0);b=4096/b}else b=this.histogram.getThreshedMinMax(.5),a=b[0],b=Math.max(b[1]-b[0],1E-4);return this.opacityRange=
[a,b]};b.VolumeT2.prototype.getAutoWinLevel=function(){if(this.autoWinLevel)return this.autoWinLevel;if(!this.loaded)return[2048,1024];if("CT"==this.modality()){var b=this.getAttr("rescaleSlope",1);var a=(-1024-this.getAttr("rescaleIntercept",0)+640)/b-this.getAttr("dataOffset",0);b=1024/b}else b=this.histogram.getThreshedMinMax(.5),a=b[0],b=Math.max(b[1]-b[0],1E-4);return this.autoWinLevel=[b,a+b/2]};b.VolumeT2.prototype.calcNearLphAxes=function(){var b=glMatrix.vec3;this.nearLphAxes={};var a=this.getAttr("rowDir"),
f=this.getAttr("colDir");if(a&&f){var c=[0,0,0];b.cross(c,a,f);c=[a,f,c];var e=-1,h=0;for(a=0;3>a;a++)f=c[a][0],Math.abs(f)>Math.abs(h)&&(h=f,e=a);this.nearLphAxes.L=[0,0,0];this.nearLphAxes.L[e]=Math.sign(h);this.nearLphAxes.R=[0,0,0];b.negate(this.nearLphAxes.R,this.nearLphAxes.L);var g=-1;for(a=h=0;3>a;a++)a!=e&&(f=c[a][1],Math.abs(f)>Math.abs(h)&&(h=f,g=a));this.nearLphAxes.P=[0,0,0];this.nearLphAxes.P[g]=Math.sign(h);this.nearLphAxes.A=[0,0,0];b.negate(this.nearLphAxes.A,this.nearLphAxes.P);
this.nearLphAxes.H=[0,0,0];b.cross(this.nearLphAxes.H,this.nearLphAxes.L,this.nearLphAxes.P);this.nearLphAxes.F=[0,0,0];b.negate(this.nearLphAxes.F,this.nearLphAxes.H);return this.nearLphAxes}this.nearLphAxes.L=[1,0,0];this.nearLphAxes.R=[-1,0,0];this.nearLphAxes.P=[0,1,0];this.nearLphAxes.A=[0,-1,0];this.nearLphAxes.H=[0,0,1];this.nearLphAxes.F=[0,0,-1]}})(window.BigLime=window.BigLime||{});
(function(b,h){b.VolumeT3=function(d,a){this.context=d;this.txIndex=a;this.dims=[1,1,1];this.sliceGap=1;this.bpp=0;this.bigEndian=!1;this.sizeInBytes=0;this.shape=[1,1,1];this.diagSize=Math.sqrt(3);this.aspect=[1,1,1];this.attrs={};this.texture=null;this.interpType=b.Interp3D.TriLinear;this.histogram=new b.Histogram3D(65536);this.loaded=!1;this.autoWinLevel=this.opacityRange=null;this.meshManager=new b.MeshManager(this);this.calcNearLphAxes()};b.VolumeT3.prototype.destroy=function(){this.context&&
(this.texture&&(this.texture.destroy(),this.texture=null),this.context=this.nearLphAxes=this.attrs=this.dims=null)};b.VolumeT3.prototype.setInterpType=function(d){if(this.interpType!=d){var a=this.context.gl;d=d==b.Interp3D.NN?a.NEAREST:a.LINEAR;this.texture&&this.texture.setInterpType(d)}};b.VolumeT3.prototype.numTextures=function(){return 1};b.VolumeT3.prototype.addMesh=function(b){this.meshManager.addMesh(b)};b.VolumeT3.prototype.removeMesh=function(b){return this.meshManager.removeMesh(b)};b.VolumeT3.prototype.removeAllMeshes=
function(){return this.meshManager.removeAllMeshes()};b.VolumeT3.prototype.containsMesh=function(b){return this.meshManager.contains(b)};b.VolumeT3.prototype.loadBegin=function(d,a,f){this.loaded=!1;this.histogram.clear();this.autoWinLevel=this.opacityRange=null;this.sliceGap=1;this.meshManager.removeAllMeshes();if(8!=a&&16!=a)return"Unsupported bits-per-pixel.";try{var c=this.context.gl;!this.texture||this.texture.sizeEquals(d[0],d[1],d[2])&&a==this.bpp||(this.texture.destroy(),this.texture=null);
this.texture||(this.texture=new b.Texture3D(this.context,this.txIndex,d[0],d[1],d[2],8==a?c.R8:c.RG8,c.LINEAR),this.setInterpType(this.interpType));this.dims=[d[0],d[1],d[2]];this.bpp=a;this.bigEndian=f.toLowerCase().startsWith("b");this.sizeInBytes=a/8*d[1]*d[2]*d[0]}catch(e){return"Error configuring volume\n\n"+e.message}};b.VolumeT3.prototype.loadEnd=function(){this.loaded=!0;this.shape=[this.dims[0],this.dims[1],this.dims[2]*this.sliceGap];this.diagSize=glMatrix.vec3.length(this.shape);glMatrix.vec3.scale(this.aspect,
this.shape,1/Math.max.apply(Math,$jscomp.arrayFromIterable(this.shape)))};b.VolumeT3.prototype.setAttr=function(b,a){b=b.toLowerCase();this.attrs[b]=a;"slicegap"==b&&(this.sliceGap=Number(a))};b.VolumeT3.prototype.getAttr=function(b,a){b=this.attrs[b.toLowerCase()];if("undefined"===typeof b||null===b)b=a;return b};b.VolumeT3.prototype.modality=function(){return this.getAttr("modality","").toUpperCase()};b.VolumeT3.prototype.getOpacityRange=function(){return b.VolumeT2.prototype.getOpacityRange.call(this)};
b.VolumeT3.prototype.getAutoWinLevel=function(){return b.VolumeT2.prototype.getAutoWinLevel.call(this)};b.VolumeT3.prototype.calcNearLphAxes=function(){return b.VolumeT2.prototype.calcNearLphAxes.call(this)}})(window.BigLime=window.BigLime||{});
(function(b,h){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.gfx_vert_1="// gfx_vert_1\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; \nprecision highp int;\n\nattribute vec4 aPosition;\nattribute vec3 aNormal;\nattribute vec4 aColor;\nattribute vec4 aMaterial;\n\nuniform mat4 uMvpTransform;\nuniform mat4 uRotMatrix;\nuniform float uPersp;\n\nvarying vec4 vPosition;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec4 vMaterial;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition; \n    gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0);\n\n    // Transform the normal as well\n    vNormal = mat3(uRotMatrix) * aNormal; \n\n    // Set varying values\n    vPosition = gl_Position;\n    vMaterial = aMaterial;\n    vColor = aColor;\n}\n";b.ShaderCode.gfx_frag_1=
"// gfx_frag_1\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; \nprecision highp int;\n\nuniform bool  uRenderDepthMap;\nvarying vec4  vPosition;\nvarying vec3  vNormal;\nvarying vec4  vColor;\nvarying vec4  vMaterial;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    if (uRenderDepthMap) \n    {\n        // Encode the depth in the b and a channels of the output color\n        float depth = 65535.0*clamp((vPosition.z+1.0)/2.0, 0.0, 1.0);\n        float dHigh = floor(depth/256.0);\n        float dLo = (depth - dHigh*256.0);\n        gl_FragColor = vec4(0.0, 0.0, dHigh/255.0, dLo/255.0);\n    }\n    else\n    {\n        // Apply lighting to the fragment color\n        float mAmbient      = vMaterial.r * 2.0;\n        float mDiffuse      = vMaterial.g * 2.0;\n        float mSpecStrength = vMaterial.b * 2.0;\n        float mSpecPower    = vMaterial.a * 255.0;\n\n        vec3 lightDir = vec3(0.0, 0.0, 1.0);\n        float cdot = clamp(-dot(normalize(vNormal), lightDir), 0.0, 1.0);\n        float diffuse = mDiffuse*(cdot - 0.6);\n        float specular = (mSpecStrength == 0.0) ? 0.0 : mSpecStrength * pow(cdot,mSpecPower);\n        \n        float light = max(0.0, mAmbient + diffuse + specular );   \n        gl_FragColor = vec4(vColor.rgb*light, vColor.a);\n    }\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,h){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.mip_vert_1="// mip_vert_1\n//-----------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nuniform mat4   uMvpTransform;\nuniform mat4   uMvpInvTransform;\nuniform float  uPersp;\nattribute vec4 aPosition;\nvarying vec3   vRayStartT;\nvarying vec3   vRayDirT;\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition;\n    float w = gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0); \n\n\t// Pass the ray's starting point and direction to the fragment shader (in texture coordinates).\n\t// Note that scaling of vRayDirT by w is necessary for perspective-correct interpolation.\n\tvRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = w * (uMvpInvTransform * vec4(gl_Position.xy*(uPersp/w), 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.mip_frag_1=
"// mip_frag_1\n//-----------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\n// Uniforms and varyings\nuniform sampler2D  uSampler;                      // For volumes that fit in a single texture\nuniform sampler2D  uSamplers[NUM_IMAGE_TEXTURES]; // For volumes that span multiple textures\nuniform sampler2D  uMaskSampler;\nuniform bool       uMaskEnabled;\nuniform float  uRayStepSize;\nuniform vec3   uVolShape;\nuniform float  uVolNumImages;\nuniform vec4   uMosaicDims;\nuniform int    uNumTextures;\nuniform float  uSlabInfo[24];\nuniform bool   uPickMode;\nuniform vec2   uPickPoint;\nuniform bool   uShowMarker;\nuniform vec3   uMarkerLoc;\nuniform float  uMarkerSize;\nvarying vec3   vRayStartT;\nvarying vec3   vRayDirT;\n\n// Constants\nconst float BBoxTol   = 0.002; \nconst vec3 BboxMin    = vec3(-BBoxTol);\nconst vec3 BboxMax    = vec3(1.0 + BBoxTol);\nconst vec3 Zeros      = vec3(0.0);\nconst vec3 Ones       = vec3(1.0);\nconst vec4 ByteMaskRG = vec4(1.0, 256.0, 0.0, 0.0);\nconst vec4 ByteMaskBA = vec4(0.0, 0.0, 1.0, 256.0);\nconst vec2 ByteMask   = vec2(1.0, 256.0);\nconst vec2 ToFloat16  = vec2(256.0, 1.0)/257.0; // For converting a pair of bytes to a float \n\n// Globals\nfloat NzM1, MxInv, MyInv;\nint NumMosaicsM1;\nvec2 MinvFirst, MinvLast;\nvec3 VolAspect;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii;\nmat4 SlabXfrm;\n#endif\n\n// Function prototypes\nbool calcMipValue(vec3);\nbool calcPickLocation(vec3);\nfloat getPixVal(vec3);\nvec4 sampleTexture(vec2, int);\nvec4 encodeVec3(vec3);\nbool isMasked(vec3 pos);\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Perform ray casting\n\tvec3 rayDir = normalize(vRayDirT);\t\n\tbool stat = calcPickLocation(rayDir) || calcMipValue(rayDir);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the maximum intensity along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcMipValue(vec3 rayDir)\n{\n\t// Initialize some globals needed by the getPixVal() routines\n\tNumMosaicsM1 = uNumTextures - 1;\t\n\tNzM1 = uVolNumImages - 1.0;\n\tMxInv = 1.0/uMosaicDims[0];\n\tMyInv = 1.0/uMosaicDims[1];    \n\tMinvFirst = vec2(1.0/uMosaicDims[0], 1.0/uMosaicDims[1]);\n\tMinvLast  = vec2(1.0/uMosaicDims[2], 1.0/uMosaicDims[3]);\n\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\t\n\t// Initialize the ray\n\tvec3 pos = vRayStartT;\n\tvec3 rayStep = rayDir*uRayStepSize;\n\tfloat rayToMarkerDist = 10.0;\n\tbool enteredSlab = false;\n\t\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\t\n\n\t// Walk along the ray\n\tfloat maxPixVal = 0.0;\n\tfor (int i = 0; i < 32768; i++)\n\t{\t\t\n\t\t// Check whether the ray has exited the volume\n\t\tif ( any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\t\t\n\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tpos += rayStep;\n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\t\t\n\t\t// Get the current pixel value and compare it with the maximum\n\t\tif (!uMaskEnabled || !isMasked(pos)) { \n\t\t\tmaxPixVal = max( maxPixVal, getPixVal(pos) );\t\n\t\t}\t\n\t\t\t\n\t\t// Check whether to display a marker\n\t\trayToMarkerDist = min(rayToMarkerDist, length((pos-uMarkerLoc)*VolAspect));\t\n\n\t\tpos += rayStep;\n\t}\n\n\t// Encode the 16-bit pixel value in two 8-bit color channels\t\n\tmaxPixVal *= 255.0;\n\tmaxPixVal = max(maxPixVal, 1.0); // Don't allow zero, as we use zero to indicate background\n\tfloat highByte = floor(maxPixVal/256.0);\n\tfloat lowByte = maxPixVal - 256.0*highByte;\n\tfloat b = float(uShowMarker) * max(0.0, 1.0-rayToMarkerDist/uMarkerSize);\n    gl_FragColor = vec4(lowByte/255.0, highByte/255.0, b, 1.0);\n\treturn true;\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the location of the maximum intensity point along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcPickLocation(vec3 rayDir)\n{\n    if (!uPickMode) { return false; }\n\n\tfloat tol = 1.0; // NB: Units here are pixels, not fractional texture coordinates\n\tif ( (abs(gl_FragCoord.x - uPickPoint.x) > tol) ||  (abs(gl_FragCoord.y - uPickPoint.y) > tol) ) \n\t{\n\t\t// Skip the computation if this is not the target fragment\n\t\tgl_FragColor = vec4(0.0);\n\t}\n\telse\n\t{\n        // Initialize some globals\n        NumMosaicsM1 = uNumTextures - 1;\t\n        NzM1 = uVolNumImages - 1.0;\n        MxInv = 1.0/uMosaicDims[0];\n        MyInv = 1.0/uMosaicDims[1];    \n        MinvFirst = vec2(1.0/uMosaicDims[0], 1.0/uMosaicDims[1]);\n        MinvLast  = vec2(1.0/uMosaicDims[2], 1.0/uMosaicDims[3]);\n\t\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\n\t\t// Initialize the ray\n\t\tvec3 pos = vRayStartT;\n\t\tvec3 rayStep = rayDir*uRayStepSize;\n\t\tbool enteredSlab = false;\n\t\t\n\t\t// Initialize slab variables\n\t\t#ifdef CLIP_TO_SLAB\n\t\tfloat slabOffset;\n\t\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\t\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t\t#endif\n\t\n\t\t// Initialize max info\n\t\tfloat maxPixVal = 0.0;\n\t\tvec3 maxLoc = vec3(-1.0);\n\n\t\t// Walk along the ray\n\t\tfor (int i = 0; i < 32768; i++)\n\t\t{\t\n\t\t\t// Check whether the ray has exited the volume\t\t\t\n\t\t\tif ( any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\t\t\n\n\t\t\t// Honor any slab constraints\n\t\t\t#ifdef CLIP_TO_SLAB\n\t\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\t\tif ( enteredSlab ) { break; }\n\t\t\t\tpos += rayStep;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tenteredSlab = true;\n\t\t\t#endif\n\t\t\t\n\t\t\tif (!uMaskEnabled || !isMasked(pos)) { \n\t\t\t\tfloat pixVal = getPixVal(pos);\n\t\t\t\tif (pixVal > maxPixVal) {\n\t\t\t\t\tmaxPixVal = pixVal;\n\t\t\t\t\tmaxLoc = pos;\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos += rayStep;\n\t\t}\n\n\t\t// Encode the max location in the output color\t\n\t\tgl_FragColor = encodeVec3(maxLoc);\n\t}\n\treturn true;\n}\n\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tvec3 slabAxis0 = normalize(p1 - p0);\n\tvec3 slabAxis1 = normalize(p2 - p0);\n\tvec3 slabAxis2 = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*slabAxis0.x,  VolAspect.x*slabAxis1.x,  VolAspect.x*slabAxis2.x,  0.0,\n\t\tVolAspect.y*slabAxis0.y,  VolAspect.y*slabAxis1.y,  VolAspect.y*slabAxis2.y,  0.0,\n\t\tVolAspect.z*slabAxis0.z,  VolAspect.z*slabAxis1.z,  VolAspect.z*slabAxis2.z,  0.0,\n       -dot(slabCtr, slabAxis0), -dot(slabCtr, slabAxis1), -dot(slabCtr, slabAxis2),  1.0\n\t);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Encodes the components of a vec3 in an rgba color.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 encodeVec3(vec3 loc)\n{\n\tif ( any(lessThan(loc,Zeros)) || any(greaterThan(loc,Ones)) ) \n\t{\n\t\t// We indicate an invalid value by setting the rightmost bit\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t}\t\n\n\t// Use 10 bits for each coordinate\n\thighp int xi = int( min(1023.0, (loc.x*1023.0 + 0.5)) );\n\thighp int yi = int( min(1023.0, (loc.y*1023.0 + 0.5)) );\n\thighp int zi = int( min(1023.0, (loc.z*1023.0 + 0.5)) );\n\n\tint zLo = zi - (zi/128) * 128;\n\tint zHi = (zi - zLo)/128;\n\n\tint yLo = yi - (yi/32) * 32;\n\tint yHi = (yi - yLo)/32;\n\n\tint xLo = xi - (xi/8) * 8;\n\tint xHi = (xi - xLo)/8;\n\n\tfloat a = float(zLo*2)/255.0;\n\tfloat b = float(zHi + 8*yLo)/255.0;\n\tfloat g = float(yHi + 32*xLo)/255.0;\n\tfloat r = float(xHi)/255.0;\n\n\treturn vec4(r, g, b, a);\n}\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point. \n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.5) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.5) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel values\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif ( sliceBelowIsEven ) \n\t{\n\t\tpixValB = dot(sampB.rg, ByteMask);\n\t\tpixValA = dot(sampB.ba, ByteMask);\n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.5) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\t\t\n\t\tpixValB = dot(sampB.ba, ByteMask);\n\t\tpixValA = dot(sampA.rg, ByteMask); \n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.25) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.25) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.25) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n \n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.5) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.5) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif (sliceBelowIsEven) \n\t{\n\t\tpixValB = dot(sampB, ByteMaskRG); \n\t\tpixValA = dot(sampB, ByteMaskBA); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.5) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = dot(sampB, ByteMaskBA);\n\t\tpixValA = dot(sampA, ByteMaskRG);\n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.25) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.25) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) components\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.25) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Samples a given texture at a given texture coordinate.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 sampleTexture(vec2 tc, int textureIndex)\n{\n\t// Performance seems to be better if we unroll the first few terms:\n\tif (textureIndex == 0) {\n\t\treturn texture2D(uSamplers[0], tc);\n\t}\n\t#if NUM_IMAGE_TEXTURES >= 2\n\telse if (textureIndex == 1) {\n\t\treturn texture2D(uSamplers[1], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 3\n\telse if (textureIndex == 2) {\n\t\treturn texture2D(uSamplers[2], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 4\n\telse if (textureIndex == 3) {\n\t\treturn texture2D(uSamplers[3], tc);\n\t} \n\t#endif\n\t#endif\n\t#endif\n\telse \n\t{\n\t\tfor (int i=4; i<NUM_IMAGE_TEXTURES; i++) \n\t\t{\n\t\t\tif (i == textureIndex) { return texture2D(uSamplers[i], tc);}\n\t\t}\n\t}\n} \n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture2D(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,h){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.shadows_vert_1="// shadows_vert_1\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nuniform mat4   uShadowMvpTransform;\nuniform mat4   uShadowMvpInvTransform;\nattribute vec4 aPosition;\nvarying vec3   vRayStartT;\nvarying vec3   vRayDirT;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space\n    gl_Position = uShadowMvpTransform * aPosition; \n\n    // Pass the ray's starting point and direction, in texture coordinates, to the fragment shader\n    vRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = (uShadowMvpInvTransform * vec4(0.0, 0.0, 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.shadows_frag_1=
"// shadows_frag_1\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\nprecision highp sampler2D;\n\n// Uniforms and varyings\nuniform sampler2D  uSampler;                      // For volumes that fit in a single texture\nuniform sampler2D  uSamplers[NUM_IMAGE_TEXTURES]; // For volumes that are split across multiple textures\nuniform sampler2D  uLutSampler;\nuniform sampler2D  uMaskSampler;\nuniform bool       uMaskEnabled;\nuniform vec3   uVolShape;\nuniform float  uVolNumImages;\nuniform vec4   uMosaicDims;\nuniform int    uNumTextures;\nuniform float  uRayStepSize;\nuniform float  uOpacityRange[2];\nuniform float  uSlabInfo[24];\nuniform mat4   uShadowMvpTransform;\n\nvarying  vec3  vRayStartT;\nvarying  vec3  vRayDirT;\n\n// Constants\nconst vec3 Ones             = vec3(1.0);\nconst vec3 Zeros            = vec3(0.0);\nconst float BBoxTol         = 0.002; \nconst vec3 BboxMin          = vec3(-BBoxTol);\nconst vec3 BboxMax          = vec3(1.0+BBoxTol);\nconst float TransparencySat = 0.02; // Saturation value\nconst vec2 ToFloat16        = vec2(256.0, 1.0)/257.0; // For converting a pair of bytes to a float \nconst vec4 ByteMaskRG       = vec4(1.0, 256.0, 0.0, 0.0);\nconst vec4 ByteMaskBA       = vec4(0.0, 0.0, 1.0, 256.0);\nconst vec2 ByteMask         = vec2(1.0, 256.0);\n\n// Globals\nfloat PixScale, PixOffset;\nfloat NzM1, MxInv, MyInv;\nint NumMosaicsM1;\nvec2 MinvFirst, MinvLast; \nvec3 VolAspect;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii, SlabAxes[3];\nmat4 SlabXfrm;\n#endif\n\n// Function prototypes\nvec4 renderShadowMap(vec3);\nfloat getNormalizedPixVal(vec3);\nvec4  sampleTexture(vec2, int);\nvec4  encodeFloat(float);\nbool isMasked(vec3 pos);\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n\t// Initialize globals\n\tPixScale  = 255.0 * uOpacityRange[1];\n\tPixOffset = uOpacityRange[0] * uOpacityRange[1];\n\n\t// Compute the shadow map\n    gl_FragColor = renderShadowMap( normalize(vRayDirT) );\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the shadow map.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 renderShadowMap(vec3 rayDir)\n{\n\t// Initialize some globals\n\tNumMosaicsM1 = uNumTextures - 1;\t\n\tNzM1 = uVolNumImages - 1.0;\n\tMxInv = 1.0/uMosaicDims[0];\n\tMyInv = 1.0/uMosaicDims[1];\n\tMinvFirst = vec2(1.0/uMosaicDims[0], 1.0/uMosaicDims[1]);\n\tMinvLast  = vec2(1.0/uMosaicDims[2], 1.0/uMosaicDims[3]);\n\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\t\n\t// Initialize locals\n\tfloat stepSize   = uRayStepSize;\n\tvec3  rayStep    = stepSize * rayDir;\n\tfloat opacityExp = stepSize * 128.0;\n\tfloat bestDelta  = -1.0; \n\tfloat bestDepth  =  1.0;\n\tvec4 shadowMvp   = vec4(uShadowMvpTransform[0][2], uShadowMvpTransform[1][2], uShadowMvpTransform[2][2], uShadowMvpTransform[3][2]);\n\n\t// Initialize the ray\n\tvec3 pos        = vRayStartT;\n\tfloat tTot      = 1.0;\n\tfloat tBase     = 1.0;\n\tbool climbing   = false;\n\tbool enteredSlab = false;\n\t\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\n\n\t// Walk along the ray, looking for the largest jump in opacity\n\tfor (int i = 0; i < 32768; i++)\n\t{\t\t\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\t\t\t\n\t\t\tpos += rayStep; \n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\n\t\tif (uMaskEnabled && isMasked(pos)) { \n\t\t\tpos += rayStep; \n\t\t\tcontinue; \n\t\t}\n\t\t\t\n\t\t// Get the current voxel's opacity \n\t\tfloat opac = texture2D( uLutSampler, vec2(getNormalizedPixVal(pos), LUT_TX_YOFFSET)).a;\n\t\tif (opac == 0.0)\n\t\t{\n\t\t\t// We have entered an empty-space region, so increase the stepsize\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\n\t\t}\n\t\telse if (stepSize > 1.5*uRayStepSize) \n\t\t{\n\t\t\t// Revert to normal-size steps, and back-up a bit\n\t\t\tstepSize = uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\n\t\t\tpos -= rayStep;\n\t\t\topac = texture2D( uLutSampler, vec2(getNormalizedPixVal(pos), LUT_TX_YOFFSET)).a;\n\t\t}\n\n\t\t// Update the accumulated transparency\n\t\tfloat t = pow(max(0.0, 1.0-opac), opacityExp);\n\t\ttBase = mix(tBase, tTot, float(!climbing));\n\t\ttTot *= t;\n\t\tclimbing = climbing || (t < 0.99);\n\n\t\t// Check whether we are ending a climb, or maybe even the whole ray\n\t\tvec3 nextPos = pos + rayStep;\n\t\tbool terminateRay = (tTot < TransparencySat) || any(lessThan(nextPos, BboxMin)) || any(greaterThan(nextPos, BboxMax));\n\t\tif ( climbing && ((t >= 0.99) || terminateRay) ) // We are ending a climb\n\t\t{\n\t\t\tclimbing = false;\n\t\t\tfloat delta = tBase - tTot; \n\t\t\tfloat improved = float(delta > bestDelta);\n\t\t\tbestDelta = mix(bestDelta, delta, improved);\n\t\t\tbestDepth = mix(bestDepth, dot(shadowMvp, vec4(pos-0.5, 1.0)), improved);\n\t\t\tterminateRay = terminateRay || (bestDelta >= tTot);  \t\t\t\t\n\t\t}\n\t\tif (terminateRay) { break; }\n\n\t\tpos = nextPos;\n\t}\n\t\n\t// Return the best depth estimate\n\tfloat d = (bestDepth + 1.0)/2.0; // Ranges between 0.0 and 1.0\n\treturn encodeFloat(d);\n}\n\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tSlabAxes[0] = normalize(p1 - p0);\n\tSlabAxes[1] = normalize(p2 - p0);\n\tSlabAxes[2] = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*SlabAxes[0].x,  VolAspect.x*SlabAxes[1].x,  VolAspect.x*SlabAxes[2].x,  0.0,\n\t\tVolAspect.y*SlabAxes[0].y,  VolAspect.y*SlabAxes[1].y,  VolAspect.y*SlabAxes[2].y,  0.0,\n\t\tVolAspect.z*SlabAxes[0].z,  VolAspect.z*SlabAxes[1].z,  VolAspect.z*SlabAxes[2].z,  0.0,\n       -dot(slabCtr, SlabAxes[0]), -dot(slabCtr, SlabAxes[1]), -dot(slabCtr, SlabAxes[2]),  1.0\n\t);\n}\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Encodes a float value in the first two components of a vec4.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 encodeFloat(float val)\n{\n\tfloat cVal = 65535.0 * clamp(val, 0.0, 1.0);\n\tfloat dHi = floor(cVal/256.0);\n\tfloat dLo = cVal - dHi*256.0;\n\treturn vec4(dHi/255.0, dLo/255.0, 0.0, 1.0);\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Samples a given texture at a given texture coordinate.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 sampleTexture(vec2 tc, int textureIndex)\n{\n\t// Performance seems to be better if we unroll the first few terms:\n\tif (textureIndex == 0) {\n\t\treturn texture2D(uSamplers[0], tc);\n\t}\n\t#if NUM_IMAGE_TEXTURES >= 2\n\telse if (textureIndex == 1) {\n\t\treturn texture2D(uSamplers[1], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 3\n\telse if (textureIndex == 2) {\n\t\treturn texture2D(uSamplers[2], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 4\n\telse if (textureIndex == 3) {\n\t\treturn texture2D(uSamplers[3], tc);\n\t} \n\t#endif\n\t#endif\n\t#endif\n\telse \n\t{\n\t\tfor (int i=4; i<NUM_IMAGE_TEXTURES; i++) \n\t\t{\n\t\t\tif (i == textureIndex) { return texture2D(uSamplers[i], tc);}\n\t\t}\n\t}\n} \n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point. \n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.5) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.5) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel values\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif ( sliceBelowIsEven ) \n\t{\n\t\tpixValB = dot(sampB.rg, ByteMask);\n\t\tpixValA = dot(sampB.ba, ByteMask);\n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.5) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\t\t\n\t\tpixValB = dot(sampB.ba, ByteMask);\n\t\tpixValA = dot(sampA.rg, ByteMask); \n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.25) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.25) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.25) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.5) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.5) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif (sliceBelowIsEven) \n\t{\n\t\tpixValB = dot(sampB, ByteMaskRG); \n\t\tpixValA = dot(sampB, ByteMaskBA); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.5) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = dot(sampB, ByteMaskBA);\n\t\tpixValA = dot(sampA, ByteMaskRG);\n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.25) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.25) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.25) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\t\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture2D(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,h){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.slab_vert_1="// slab_vert_1\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float;\nprecision highp int;\n\nattribute vec4 aPosition;\nattribute vec4 aColor;\nvarying vec4   vColor;\nuniform mat4   uMvpTransform;\nuniform float  uPersp;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    gl_Position = uMvpTransform * aPosition;\n    gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0);\n    vColor = aColor;\n}\n";b.ShaderCode.slab_frag_1=
"// slab_frag_1\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; \nprecision highp int;\nvarying vec4    vColor;\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    gl_FragColor = vColor;\n}\n"})(window.BigLime=window.BigLime||{});
(function(b,h){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.vr_vert_1="// vr_vert_1\n//-----------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nattribute vec4 aPosition;\nuniform mat4   uMvpTransform;\nuniform mat4   uMvpInvTransform;\nuniform float  uPersp;\nvarying vec3   vRayStartT;\nvarying vec3   vRayDirT;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition;\n    float w = gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0); \n\n\t// Pass the ray's starting point and direction to the fragment shader (in texture coordinates).\n\t// Note that scaling of vRayDirT by w is necessary for perspective-correct interpolation.\n\tvRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = w * (uMvpInvTransform * vec4(gl_Position.xy*(uPersp/w), 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.vr_frag_1=
"// vr_frag_1\n//-----------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\nprecision highp sampler2D;\n\n// Uniforms and varyings\nuniform sampler2D  uSampler;                      // For volumes that fit in a single texture\nuniform sampler2D  uSamplers[NUM_IMAGE_TEXTURES]; // For volumes that span multiple textures\nuniform sampler2D  uLutSampler;\nuniform sampler2D  uMaskSampler;\nuniform bool       uMaskEnabled;\nuniform vec3   uVrBackColor;\nuniform vec3   uVolShape;\nuniform float  uVolNumImages;\nuniform vec4   uMosaicDims;\nuniform int    uNumTextures;\nuniform float  uRayStepSize;\nuniform vec2   uOutBufferSize;\nuniform float  uOpacityRange[2];\nuniform int    uAntiAlias;\nuniform float  uSlabInfo[24];\nuniform bool   uSealBorders;\nuniform bool   uPickMode;\nuniform vec2   uPickPoint;\nuniform bool   uShowMarker;\nuniform vec3   uMarkerLoc;\nuniform float  uMarkerSize;\nuniform vec4   uMarkerColor;\nuniform mat4   uModelTransform;\nuniform mat4   uViewTransform;\nuniform float  uAmbientLight;\nstruct Light {\n\tfloat diffuse;\n\tfloat specStrength;\n\tfloat specExp;\n\tfloat shadowDarkness;\n\tfloat shadowSoftness;\n\tvec3  dir;\n\tmat4  shadowMvp;\n};\nuniform Light uLights[2];\n\n#ifdef RENDER_GRAPHICS\nuniform sampler2D uGfxSampler;\nuniform float uGfxBlendWeight;\n#endif\n#ifdef RENDER_SHADOWS\nuniform sampler2D uShadowSampler;\nuniform float uShadowTxScale;\n#endif\n\nvarying vec3 vRayStartT;\nvarying vec3 vRayDirT;\n\n \n// Constants\nvec3 UnitVectors[3];\nconst vec3 Ones             = vec3(1.0);\nconst vec3 Zeros            = vec3(0.0);\nconst float BBoxTol         = 0.002; \nconst vec3 BboxMin          = vec3(-BBoxTol);\nconst vec3 BboxMax          = vec3(1.0 + BBoxTol);\nconst float TransparencySat = 0.02; // Saturation value\nconst vec2 ToFloat16        = vec2(256.0, 1.0)/257.0; // For converting a pair of bytes to a float \nconst vec4 ByteMaskRG       = vec4(1.0, 256.0, 0.0, 0.0);\nconst vec4 ByteMaskBA       = vec4(0.0, 0.0, 1.0, 256.0);\nconst vec2 ByteMask         = vec2(1.0, 256.0);\n\n// Globals\nfloat PixScale, PixOffset;\nfloat NzM1, MxInv, MyInv;\nint NumMosaicsM1;\nvec2 MinvFirst, MinvLast; \nvec3 VolAspect;\nvec3 BorderNormal, GradOffset;\nfloat BorderNormalWeight, BorderReflectanceWeight;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii, SlabAxes[3];\nmat4 SlabXfrm;\n#endif\n\n\n// Function prototypes\nbool  calcVrValue(vec3);\nbool  calcPickLocation(vec3);\nfloat getNormalizedPixVal(vec3);\nvec4  sampleTexture(vec2, int);\nvoid  getBorderInfo(vec3, vec3, vec3, float, vec3);\nfloat rand(vec2);\nvec4  encodeVec3(vec3);\nbool isMasked(vec3 pos);\n\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n#ifdef RENDER_SHADOWS\nfloat calcShadowWeight(vec3, int);\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\t\t\n\t// Initialize globals\n\tPixScale  = 255.0 * uOpacityRange[1];\n\tPixOffset = uOpacityRange[0] * uOpacityRange[1];\n\t\n\t// Perform ray casting\n\tvec3 rayDir = normalize(vRayDirT);\n\tbool stat = calcPickLocation(rayDir) || calcVrValue(rayDir);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the integrated color and opacity along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcVrValue(vec3 rayDir)\n{\n\t// Initialize some globals\n\tNumMosaicsM1 = uNumTextures - 1;\t\n\tNzM1 = uVolNumImages - 1.0;\n\tMxInv = 1.0/uMosaicDims[0];\n\tMyInv = 1.0/uMosaicDims[1];\n    MinvFirst = vec2(1.0/uMosaicDims[0], 1.0/uMosaicDims[1]);\n\tMinvLast  = vec2(1.0/uMosaicDims[2], 1.0/uMosaicDims[3]);\n\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\t\n\t// Initialize constants\n\tUnitVectors[0]      = vec3(1.0, 0.0, 0.0);\n\tUnitVectors[1]      = vec3(0.0, 1.0, 0.0);\n\tUnitVectors[2]      = vec3(0.0, 0.0, 1.0);\t\n\tvec3 gdx            = vec3(1.0/uVolShape[0], 0.0, 0.0);      // Offset for computing grad.x\n\tvec3 gdy            = vec3(0.0, 1.0/uVolShape[1], 0.0);      // Offset for computing grad.y\n\tvec3 gdz            = vec3(0.0, 0.0, 1.0/uVolShape[2]);      // Offset for computing grad.z\n\tvec3 gradDelta      = 1.5 * vec3(gdx.x, gdy.y, gdz.z);       // Offsets for computing gradients near borders\n\tfloat stepSize      = uRayStepSize;                          // The step-size for raycasting\n\tvec3 rayStep        = uRayStepSize * rayDir;                 // The ray increment\n\tfloat opacityExp    = uRayStepSize * 128.0;                  // For scaling the opacity to the ray step size\n\tfloat borderThresh  = uRayStepSize * 5.0;                    // Distance threshold for shading border surfaces\n\tfloat random        = rand(gl_FragCoord.xy);                 // For antialiasing\n\tint randIndex       = int(10.0*random + 1.0);\n\tfloat randRayOffset = float(uAntiAlias) * uRayStepSize * (random - 0.5); \n\n\t// Default border values\n\tBorderNormal = vec3(1.0, 0.0, 0.0);\n\tBorderNormalWeight = 0.0;\n\tBorderReflectanceWeight = 1.0;\n\tGradOffset = vec3(0.0);\n\n\t// Initialize the ray\n\tfloat tTot            = 1.0;                                 // Accumulated transparency\n\tvec3 cTot             = vec3(0.0);                           // Accumulated color\n\tvec3 pos              = vRayStartT;                          // Current ray position\n\tvec3 pos_s            = vec3(0.0);                           // Current ray position in slab coordinates\n\tfloat currPixVal      = getNormalizedPixVal(pos);\n\tfloat prevPixVal      = 0.0;\n\tfloat nextPixVal      = 0.0;\n\tvec3 prevGrad         = vec3(0.0);\t\n\tfloat perpMarkerDist  = length( cross( (pos-uMarkerLoc)*VolAspect, normalize(rayDir*VolAspect) ) );\n\tbool omitMarkerTest   = !uShowMarker || (perpMarkerDist > uMarkerSize);\n\tbool enteredSlab      = false;\n\t\n\t#ifdef RENDER_GRAPHICS\n\tvec2 fragCoord = 0.5*gl_FragCoord.xy/uOutBufferSize;\n\tvec4 gfxColor0 = texture2D(uGfxSampler, vec2(fragCoord.x,       fragCoord.y      ));\n\tvec4 gfxDepth0 = texture2D(uGfxSampler, vec2(fragCoord.x + 0.5, fragCoord.y      ));\n\tvec4 gfxColor1 = texture2D(uGfxSampler, vec2(fragCoord.x,       fragCoord.y + 0.5));\n\tvec4 gfxDepth1 = texture2D(uGfxSampler, vec2(fragCoord.x + 0.5, fragCoord.y + 0.5));\n\tfloat depth0 = 2.0* dot(gfxDepth0.ba, ToFloat16) - 1.0;\n\tfloat depth1 = 2.0* dot(gfxDepth1.ba, ToFloat16) - 1.0;\n\tbool omitG0Test = (depth0 > 0.999);\n\tbool omitG1Test = (depth1 > 0.999);\n\tmat4 mvTransform = uViewTransform * uModelTransform;\n\tvec4 mvTransformZ = vec4(mvTransform[0][2], mvTransform[1][2], mvTransform[2][2], mvTransform[3][2]);\n\t#endif\n\n\tfloat prevShadowWeight0 = -1.0;\n\tfloat prevShadowWeight1 = -1.0;\n\tfloat sh0 = uLights[0].shadowDarkness;\n\tfloat sh1 = uLights[1].shadowDarkness;\n\tfloat drel0 = (uLights[0].diffuse == uLights[1].diffuse) ? 0.5 : uLights[0].diffuse/(uLights[0].diffuse + uLights[1].diffuse + 0.0001);\n\tfloat drel1 = 1.0 - drel0;\n\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\n\n\t// Walk along the ray\n\tfor (int i = 0; i < 32768; i++)\n\t{\t\t\n\t\t// We're done if the ray has exited the volume, or if the opacity threshold is exceeded\n\t\tif ( (tTot < TransparencySat) || any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\n\n\t\t// Does the current ray position intersect the marker?\n\t\tif (!omitMarkerTest)\n\t\t{\t\n\t\t\tvec3 pmVec = (pos - uMarkerLoc)*VolAspect;\t\n\t\t\tif ( length(pmVec) <= uMarkerSize ) {\n\t\t\t\tfloat pmPerpDist = length( cross(pmVec, normalize(rayDir*VolAspect)) );\n\t\t\t\tfloat shade = mix(1.0 - pmPerpDist/uMarkerSize, 1.0, 0.4);\n\t\t\t\tcTot += shade * uMarkerColor.rgb * uMarkerColor.a * tTot;\n\t\t\t\ttTot *= 1.0 - uMarkerColor.a;\n\t\t\t\tomitMarkerTest = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t\t\t\t\n\t\t// Apply random ray offset for antialiasing\n\t\tpos += (float(i == randIndex) * randRayOffset) * rayDir;\n\n\t\t#ifdef RENDER_GRAPHICS\t\t\n\t\tif ( !omitG0Test || !omitG1Test )\n\t\t{\t\n\t\t\tfloat gPosZ = dot(mvTransformZ, vec4(pos-0.5, 1.0));\n\t\t\tif ((!omitG1Test) && (gPosZ > depth1)) {\n\t\t\t\tcTot += gfxColor1.rgb * gfxColor1.a * tTot;\n\t\t\t\tcTot = mix(cTot, gfxColor1.rgb, uGfxBlendWeight);\n\t\t\t\ttTot *= 1.0 - gfxColor1.a;\n\t\t\t\tomitG1Test = true;\n\t\t\t\tcontinue;\t\t\t\n\t\t\t}\n\t\t\tif ((!omitG0Test) && (gPosZ > depth0)) {\n\t\t\t\tcTot += gfxColor0.rgb * gfxColor0.a * tTot;\n\t\t\t\tcTot = mix(cTot, gfxColor0.rgb, uGfxBlendWeight);\n\t\t\t\ttTot *= 1.0 - gfxColor0.a;\n\t\t\t\tomitG0Test = true;\n\t\t\t\tcontinue;\t\t\t\n\t\t\t}\n\t\t}\n\t\t#endif\t\t\n\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tpos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tprevPixVal = 0.0;  currPixVal = 0.0;\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\t\t\t\n\t\t\tpos += rayStep;  \n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\n\t\t// Get the pixel value. Use 3-point averaging along the ray\n\t\tnextPixVal = getNormalizedPixVal(pos + rayStep);\n\t\tfloat pixVal = 0.25*( prevPixVal + 2.0*currPixVal + nextPixVal );\n\t\tprevPixVal = currPixVal;  currPixVal = nextPixVal;\n\n\t\t// Check the opacity value\n\t\tvec4 lutVal = (uMaskEnabled && isMasked(pos)) ? vec4(0.0) : texture2D(uLutSampler, vec2(pixVal, LUT_TX_YOFFSET)); \n\n\t\tif (lutVal.a == 0.0)\n\t\t{\n\t\t\t// We have entered an empty-space region, so increase the stepsize\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (stepSize > 1.5*uRayStepSize) {\n\t\t\t\t// Revert to normal-size steps, and back-up\n\t\t\t\tstepSize    = uRayStepSize;\n\t\t\t\trayStep     = stepSize*rayDir;\n\t\t\t\tpos        -= rayStep;\n\t\t\t\tcurrPixVal  = getNormalizedPixVal(pos);\n\t\t\t\tprevPixVal  = getNormalizedPixVal(pos - rayStep);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check whether we are near a border\n\t\t\tif (uSealBorders) {\n\t\t\t\tgetBorderInfo(pos, rayDir, pos_s, borderThresh, gradDelta);\n\t\t\t}\n\n\t\t\t// Compute the intensity gradient\n\t\t\tvec3 gpos = pos + GradOffset;\n\t\t\tvec3 grad = vec3( \n\t\t\t\tgetNormalizedPixVal(gpos + gdx) - getNormalizedPixVal(gpos - gdx),\n\t\t\t\tgetNormalizedPixVal(gpos + gdy) - getNormalizedPixVal(gpos - gdy),\n\t\t\t\tgetNormalizedPixVal(gpos + gdz) - getNormalizedPixVal(gpos - gdz) );\t\n\n\t\t\t// Modify the gradient near borders\n\t\t\tgrad = mix(grad, BorderNormal, BorderNormalWeight);\n\t\t\tgrad = mix(grad, prevGrad, 0.5);\n\t\t\tprevGrad = grad;\n\t\t\tfloat gradMag = length(grad);\n\n\t\t\t// Compute the lighting factors\n\t\t\tvec3 N = grad/gradMag;\n\t\t\tvec3 L0 = uLights[0].dir;\n\t\t\tvec3 L1 = uLights[1].dir;\n\t\t\tvec3 R0 = reflect(-1.0*L0, N); // Assumes that L0, L1 are normalized\n\t\t\tvec3 R1 = reflect(-1.0*L1, N);\n\n\t\t\tfloat diffuse0 = 2.0 * uLights[0].diffuse * max(0.0, dot(N,L0));\n\t\t\tfloat diffuse1 = 2.0 * uLights[1].diffuse * max(0.0, dot(N,L1));\n\n\t\t\tfloat sdot0 = max(0.0, dot(R0, rayDir));\n\t\t\tfloat sdot1 = max(0.0, dot(R1, rayDir));\n\t\t\tfloat specular0 = 2.0 * uLights[0].specStrength * pow(sdot0, uLights[0].specExp);\n\t\t\tfloat specular1 = 2.0 * uLights[1].specStrength * pow(sdot1, uLights[1].specExp);\n\n\t\t\tfloat dsFactor = float(gradMag > 0.001)*BorderReflectanceWeight;\n\t\t\tfloat light0 = uAmbientLight*drel0 + (diffuse0 + specular0)*dsFactor; \n\t\t\tfloat light1 = uAmbientLight*drel1 + (diffuse1 + specular1)*dsFactor; \n\n\t\t\t// Maybe draw shadows\n\t\t\t#ifdef RENDER_SHADOWS\n\t\t\tif (sh0 > 0.0) { \n\t\t\t\tfloat shadowWeight0 = ((prevShadowWeight0 < 0.0) || (tTot > 0.10)) ? calcShadowWeight(pos,0) : prevShadowWeight0;\n\t\t\t\tlight0 *= max(0.0, 1.0-sh0*shadowWeight0);\n\t\t\t\tprevShadowWeight0 = shadowWeight0;\n\t\t\t}\n\t\t\tif (sh1 > 0.0) {\n\t\t\t\tfloat shadowWeight1 = ((prevShadowWeight1 < 0.0) || (tTot > 0.10)) ? calcShadowWeight(pos,1) : prevShadowWeight1;\n\t\t\t\tlight1 *= max(0.0, 1.0-sh1*shadowWeight1); \n\t\t\t\tprevShadowWeight1 = shadowWeight1;\n\t\t\t}\n\t\t\t\t#endif // RENDER_SHADOWS\n\n\t\t\t// Update the total color\n\t\t\tfloat light = light0 + light1;\n\n\t\t\t// Update the total color\n\t\t\tfloat t = pow(max(0.0, 1.0-lutVal.a), opacityExp);\n\t\t\tvec3 c = lutVal.rgb * (1.0 - t) * light;\n\t\t\tcTot += c*tTot;\n\t\t\ttTot *= t;\n\t\t}\n\t\t\t\n\t\tpos += rayStep;\n\t}\n\t\n\tcTot += uVrBackColor*tTot;\n\tgl_FragColor = vec4(cTot, 1.0);\n\treturn true;\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the location of the most salient point along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcPickLocation(vec3 rayDir)\n{\n    if (!uPickMode) { return false; }\n\n\tfloat tol = 1.0; // NB: Units here are pixels, not fractional texture coordinates\n\tif ( (abs(gl_FragCoord.x - uPickPoint.x) > tol) ||  (abs(gl_FragCoord.y - uPickPoint.y) > tol) ) \n\t{\n\t\t// Skip the computation if this is not the target fragment\n\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t}\n\telse\n\t{\n\t\t// Initialize some globals\n        NumMosaicsM1 = uNumTextures - 1;\t\n        NzM1 = uVolNumImages - 1.0;\n        MxInv = 1.0/uMosaicDims[0];\n        MyInv = 1.0/uMosaicDims[1];\n        MinvFirst = vec2(1.0/uMosaicDims[0], 1.0/uMosaicDims[1]);\n        MinvLast  = vec2(1.0/uMosaicDims[2], 1.0/uMosaicDims[3]);\n\t\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\n\t\t// Initialize locals\n\t\tvec3 rayStep         = uRayStepSize * rayDir;\n\t\tfloat opacityExp     = uRayStepSize * 128.0;\n\t\tvec3 maxLoc          = vec3(-1.0);\n\t\tvec3 runStart        = vec3(-1.0);\n\t\tfloat bestDelta      = -1.0; \n\n\t\t// Initialize the ray\n\t\tvec3 pos = vRayStartT;\n\t\tfloat tTot = 1.0;\n\t\tfloat tBase = -1.0;\n\t\t\n\t\t// Initialize slab variables\n\t\t#ifdef CLIP_TO_SLAB\n\t\tfloat slabOffset;\n\t\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\t\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t\t#endif\n\n\t\t// Walk along the ray\n\t\tfor (int i = 0; i < 32768; i++)\n\t\t{\t\t\n\t\t\t// Honor any slab constraints\n\t\t\t#ifdef CLIP_TO_SLAB\n\t\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\t\tpos += rayStep;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t#endif\n\n\t\t\t// Update the accumulated transparency\n\t\t\tfloat opac = (uMaskEnabled && isMasked(pos)) ? 0.0 : texture2D(uLutSampler, vec2(getNormalizedPixVal(pos), LUT_TX_YOFFSET)).a;\n\t\t\tfloat t = pow( max(0.0, 1.0-opac), opacityExp);\n\t\t\ttTot *= t;\n\n\t\t\t// Check whether the transparency is strictly decreasing\n\t\t\tif ( (t < 0.99) && (runStart.x < 0.0) )  \n\t\t\t{ \n\t\t\t\trunStart = pos; // The voxel has some opacity, so we are starting a new run\n\t\t\t\ttBase = tTot;\n\t\t\t}\n\n\t\t\tvec3 nextPos = pos + rayStep;\n\t\t\tbool terminateRay = (tTot < TransparencySat) || any(lessThan(nextPos, BboxMin)) || any(greaterThan(nextPos, BboxMax));\n\t\t\tif ( (runStart.x >= 0.0) && ((t >= 0.99) || terminateRay) ) // We are ending a run\n\t\t\t{\n\t\t\t\tfloat delta = tBase - tTot; \n\t\t\t\tfloat improved = float(delta > bestDelta);\n\t\t\t\tbestDelta = mix(bestDelta, delta, improved);\n\t\t\t\tmaxLoc = mix(maxLoc, runStart, improved);\n\t\t\t\trunStart = vec3(-1.0); \t\n\t\t\t\tterminateRay = terminateRay || (bestDelta >= tTot);  \t\t\t\n\t\t\t}\n\t\t\tif (terminateRay) { break; }\t\t\n\n\t\t\tpos = nextPos;\n\t\t}\n\t\t\n\t\t// Encode the max location in the output color\t\n\t\tgl_FragColor = encodeVec3(maxLoc);\n\t}\n\treturn true;\n}\n\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tSlabAxes[0] = normalize(p1 - p0);\n\tSlabAxes[1] = normalize(p2 - p0);\n\tSlabAxes[2] = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*SlabAxes[0].x,  VolAspect.x*SlabAxes[1].x,  VolAspect.x*SlabAxes[2].x,  0.0,\n\t\tVolAspect.y*SlabAxes[0].y,  VolAspect.y*SlabAxes[1].y,  VolAspect.y*SlabAxes[2].y,  0.0,\n\t\tVolAspect.z*SlabAxes[0].z,  VolAspect.z*SlabAxes[1].z,  VolAspect.z*SlabAxes[2].z,  0.0,\n       -dot(slabCtr, SlabAxes[0]), -dot(slabCtr, SlabAxes[1]), -dot(slabCtr, SlabAxes[2]),  1.0\n\t);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the distance to the nearest border, and the normal vector of\n//   that border.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid getBorderInfo(vec3 pos, vec3 rayDir, vec3 pos_s, float borderThresh, vec3 gradDelta)\n{\n\t// Check the volume borders\n\tfloat minDist = borderThresh + 1.0;\n\tbool isSlabBorder = false;\n\t\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tfloat p = abs(pos[i]);\n\t\tif (p < minDist) { minDist = p;  BorderNormal = UnitVectors[i]; }\t\n\n\t\tp = abs(1.0 - pos[i]);\n\t\tif (p < minDist) { minDist = p;  BorderNormal = -1.0*UnitVectors[i]; }\t\n\n        #ifdef CLIP_TO_SLAB\t\n\t\tp = abs( SlabRadii[i] + pos_s[i] );\n\t\tif ( p < minDist ) { minDist = p;  BorderNormal = SlabAxes[i];  isSlabBorder = true; }\n\n\t\tp = abs( SlabRadii[i] - pos_s[i] );\n\t\tif ( p < minDist ) { minDist = p;  BorderNormal = -1.0*SlabAxes[i]; isSlabBorder = true; }\t\n        #endif\t\t\t\t\t\t\t\n\t}\t\n\n\tbool doBorderMod    = (minDist < borderThresh);\n\tfloat cosFactor     = max( 0.0, dot(normalize(BorderNormal),rayDir) );\n\tBorderNormalWeight  = doBorderMod ? (1.0 - minDist/borderThresh)*pow(cosFactor,0.25) : 0.0;\n\tBorderReflectanceWeight = doBorderMod ? 1.0 - 0.75*pow(cosFactor,4.0) : 1.0;\n\tGradOffset          = (doBorderMod && !isSlabBorder ) ? BorderNormal*gradDelta : Zeros;\n}\n\n\n#ifdef RENDER_SHADOWS\n///////////////////////////////////////////////////////////////////////////////\n//\n// Implements percentage-closer filtering for soft shadow edges.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat calcShadowWeight(vec3 pos, int lightIndex)\n{\n\t// Initialize constants\n\tfloat step = (lightIndex == 0) ? 0.0054*uLights[0].shadowSoftness : 0.0054*uLights[1].shadowSoftness;\n\tfloat dx = step / max(1.0, uOutBufferSize.x/uOutBufferSize.y);\n\tfloat dy = step / max(1.0, uOutBufferSize.y/uOutBufferSize.x);\n\n\t// Get the shadow-map coordinates of the input point\n\tmat4 shadowMvp = (lightIndex == 0) ? uLights[0].shadowMvp : uLights[1].shadowMvp;\n\tvec4 pt = 0.5*(shadowMvp * vec4(pos-0.5, 1.0) + 1.0);\n\n\t// Apply a random offset to reduce banding artifacts\n\tfloat px0 = pt.x + dx * 0.8*(rand(pos.xz) - 0.5);\n\tfloat py0 = pt.y + dy * 0.8*(rand(pos.yz) - 0.5);\n\n\t// Apply a small z-offset to prevent self-shadowing\t\n\tfloat pzd = pt.z - 1.0/uVolShape[0];\n\n\tpx0 *= uShadowTxScale;\n\tpy0 *= uShadowTxScale;\n\tdx *= uShadowTxScale;\n\tdy *= uShadowTxScale;\n\n\t// Tabulate sampling points\n\tfloat pxp1 = px0 + dx;\n\tfloat pxm1 = px0 - dx;\n\tfloat pxp2 = pxp1 + dx;\n\tfloat pxm2 = pxm1 - dx;\n\tfloat pxp3 = pxp2 + dx;\n\tfloat pxm3 = pxm2 - dx;\n\tfloat pxp4 = pxp3 + dx;\n\tfloat pxm4 = pxm3 - dx;\n\n\tfloat pyp1 = py0 + dy;\n\tfloat pym1 = py0 - dy;\n\tfloat pyp2 = pyp1 + dy;\n\tfloat pym2 = pym1 - dy;\n\tfloat pyp3 = pyp2 + dy;\n\tfloat pym3 = pym2 - dy;\n\tfloat pyp4 = pyp3 + dy;\n\tfloat pym4 = pym3 - dy;\n\n\tfloat fL = float(lightIndex);\n\tpy0  = 0.5*(py0 + fL);\n\tpyp1 = 0.5*(pyp1 + fL);\n\tpym1 = 0.5*(pym1 + fL);\n\tpyp2 = 0.5*(pyp2 + fL);\n\tpym2 = 0.5*(pym2 + fL);\n\tpyp3 = 0.5*(pyp3 + fL);\n\tpym3 = 0.5*(pym3 + fL);\n\tpyp4 = 0.5*(pyp4 + fL);\n\tpym4 = 0.5*(pym4 + fL);\n\t \n\t// Unrolled loop for better performance:\n\tvec4 smTexVal = texture2D(uShadowSampler, vec2(px0, py0));\n\tfloat smDepth = dot(smTexVal.rg, ToFloat16);\n\tfloat wt = float(pzd > smDepth);\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pym4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pym4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pym4)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm3, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm2, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp2, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp3, pym3)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm3, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm2, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp2, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp3, pym2)).rg, ToFloat16 ));\t\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm4, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm3, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm2, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp2, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp3, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp4, pym1)).rg, ToFloat16 ));\n\t\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm4, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm3, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm2, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, py0)).rg, ToFloat16 ));\n\t//-------------------------------------------------------------------------------\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp2, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp3, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp4, py0)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm4, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm3, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm2, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp2, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp3, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp4, pyp1)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm3, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm2, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp2, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp3, pyp2)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm3, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm2, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp2, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp3, pyp3)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pyp4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pyp4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pyp4)).rg, ToFloat16 ));\n\n\treturn wt/61.0;\t\t\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets a random number given a 2-component seed.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat rand(vec2 xy)\n{\n    return fract(sin(dot(xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Encodes the components of a vec3 in an rgba color.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 encodeVec3(vec3 loc)\n{\n\tif ( any(lessThan(loc,Zeros)) || any(greaterThan(loc,Ones)) ) \n\t{\n\t\t// We indicate an invalid value by setting the rightmost bit\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t}\t\n\n\t// Use 10 bits for each coordinate\n\thighp int xi = int( min(1023.0, (loc.x*1023.0 + 0.5)) );\n\thighp int yi = int( min(1023.0, (loc.y*1023.0 + 0.5)) );\n\thighp int zi = int( min(1023.0, (loc.z*1023.0 + 0.5)) );\n\n\tint zLo = zi - (zi/128) * 128;\n\tint zHi = (zi - zLo)/128;\n\n\tint yLo = yi - (yi/32) * 32;\n\tint yHi = (yi - yLo)/32;\n\n\tint xLo = xi - (xi/8) * 8;\n\tint xHi = (xi - xLo)/8;\n\n\tfloat a = float(zLo*2)/255.0;\n\tfloat b = float(zHi + 8*yLo)/255.0;\n\tfloat g = float(yHi + 32*xLo)/255.0;\n\tfloat r = float(xHi)/255.0;\n\n\treturn vec4(r, g, b, a);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Samples a given texture at a given texture coordinate.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 sampleTexture(vec2 tc, int textureIndex)\n{\n\t// Performance seems to be better if we unroll the first few terms:\n\tif (textureIndex == 0) {\n\t\treturn texture2D(uSamplers[0], tc);\n\t}\n\t#if NUM_IMAGE_TEXTURES >= 2\n\telse if (textureIndex == 1) {\n\t\treturn texture2D(uSamplers[1], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 3\n\telse if (textureIndex == 2) {\n\t\treturn texture2D(uSamplers[2], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 4\n\telse if (textureIndex == 3) {\n\t\treturn texture2D(uSamplers[3], tc);\n\t} \n\t#endif\n\t#endif\n\t#endif\n\telse \n\t{\n\t\tfor (int i=4; i<NUM_IMAGE_TEXTURES; i++) \n\t\t{\n\t\t\tif (i == textureIndex) { return texture2D(uSamplers[i], tc);}\n\t\t}\n\t}\n} \n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point. \n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.5) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0 );\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.5) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel values\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif ( sliceBelowIsEven ) \n\t{\n\t\tpixValB = dot(sampB.rg, ByteMask);\n\t\tpixValA = dot(sampB.ba, ByteMask);\n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.5) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\t\t\n\t\tpixValB = dot(sampB.ba, ByteMask);\n\t\tpixValA = dot(sampA.rg, ByteMask); \n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.25) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.25) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.25) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.5) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.5) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif (sliceBelowIsEven) \n\t{\n\t\tpixValB = dot(sampB, ByteMaskRG); \n\t\tpixValA = dot(sampB, ByteMaskBA); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.5) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = dot(sampB, ByteMaskBA);\n\t\tpixValA = dot(sampA, ByteMaskRG);\n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.25) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.25) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.25) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\t\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture2D(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,h){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.winLevel_vert_1="// winLevel_vert_1\n//----------------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float;\nprecision highp int;\n\nuniform float  uWinWidth;\nuniform float  uWinLevel;\nattribute vec4 aPosition;\nvarying float  vPixScale;\nvarying float  vPixOffset;\nvarying vec2   vTexCoord;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Convert from clip space to texture coordinates\n    vTexCoord = (aPosition.xy + 1.0)*0.5;\n\n    // Compute the scale and offset factor for the window/level transform\n    float level = uWinLevel*(257.0/65535.0);\n    float width = uWinWidth*(257.0/65535.0);\n\tvPixScale = 1.0/(width + 0.001);\n\tvPixOffset = level - width/2.0;\n\n    gl_Position = aPosition;    \n}\n";b.ShaderCode.winLevel_frag_1=
"// winLevel_frag_1\n//----------------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D uWLSampler;\nuniform sampler2D uLutSampler;\nuniform int       uPassThruMode;\nuniform int       uColorMapIndex;\nuniform vec4      uMarkerColor;\nvarying float     vPixScale;\nvarying float     vPixOffset;\nvarying vec2      vTexCoord;\n\n\nvoid main()\n{\n\t// Read the output from the renderer\n\tvec4 textureVal = texture2D(uWLSampler, vTexCoord);\n\n\tif (uPassThruMode > 0) \n\t{\n\t\t// Pass-thru mode means we don't modify the pixels\n\t\tgl_FragColor = textureVal;\n\t}\n\telse\n\t{\n\t\tif (textureVal.b != 0.0) \n\t\t{\n            // Just render the marker\n\t\t\tgl_FragColor = vec4( ((textureVal.b+2.0)/3.0) * uMarkerColor.rgb, uMarkerColor.a );\n\t    }\n\t\telse\n\t\t{\n\t\t    // Get the raw pixel value\n\t\t\tfloat rawPixVal = textureVal.r + 256.0*textureVal.g;\n\t\t\tif (rawPixVal == 0.0) \n\t\t\t{\n\t\t\t    // We're in the background\n\t\t\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); \n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t    // Apply the window/level transform \n\t\t\t\tfloat wlPixVal = clamp( vPixScale*(rawPixVal - vPixOffset), 0.0, 1.0 );\n\t\t\t\tif (uColorMapIndex == 0) {\t\n\t\t\t\t\tgl_FragColor = vec4(wlPixVal, wlPixVal, wlPixVal, 1.0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t    // Apply the lookup table\n\t\t\t\t\tgl_FragColor = texture2D(uLutSampler, vec2(LUT_TX_XSCALE*wlPixVal, LUT_TX_YOFFSET + float(uColorMapIndex)*LUT_TX_YSCALE));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,h){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.xray_vert_1="// xray_vert_1\n//-----------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nuniform mat4   uMvpTransform;\nuniform mat4   uMvpInvTransform;\nuniform float  uPersp;\nattribute vec4 aPosition;\nvarying vec3   vRayStartT;\nvarying vec3   vRayDirT;\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition;\n    float w = gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0); \n\n\t// Pass the ray's starting point and direction to the fragment shader (in texture coordinates).\n\t// Note that scaling of vRayDirT by w is necessary for perspective-correct interpolation.\n\tvRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = w * (uMvpInvTransform * vec4(gl_Position.xy*(uPersp/w), 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.xray_frag_1=
"// xray_frag_1\n//-----------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\n// Uniforms and varyings\nuniform sampler2D  uSampler;                      // For volumes that fit in a single texture\nuniform sampler2D  uSamplers[NUM_IMAGE_TEXTURES]; // For volumes that span multiple textures\nuniform sampler2D  uMaskSampler;\nuniform sampler2D  uLutSampler;\nuniform bool   uUseLut;\nuniform bool   uMaskEnabled;\nuniform float  uOpacityRange[2];\nuniform float  uRayStepSize;\nuniform vec3   uVolShape;\nuniform float  uVolNumImages;\nuniform vec4   uMosaicDims;\nuniform int    uNumTextures;\nuniform float  uSlabInfo[24];\nvarying vec3   vRayStartT;\nvarying vec3   vRayDirT;\n\n// Constants\nconst float BBoxTol   = 0.002; \nconst vec3 BboxMin    = vec3(-BBoxTol);\nconst vec3 BboxMax    = vec3(1.0 + BBoxTol);\nconst vec3 Zeros      = vec3(0.0);\nconst vec3 Ones       = vec3(1.0);\nconst vec4 ByteMaskRG = vec4(1.0, 256.0, 0.0, 0.0);\nconst vec4 ByteMaskBA = vec4(0.0, 0.0, 1.0, 256.0);\nconst vec2 ByteMask   = vec2(1.0, 256.0);\nconst vec2 ToFloat16  = vec2(256.0, 1.0)/257.0; // For converting a pair of bytes to a float \n\n// Globals\nfloat PixScale, PixOffset;\nfloat NzM1, MxInv, MyInv;\nint NumMosaicsM1;\nvec2 MinvFirst, MinvLast;\nvec3 VolAspect;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii;\nmat4 SlabXfrm;\n#endif\n\n// Function prototypes\nvoid calcXrayValue(vec3);\nfloat getPixVal(vec3);\nvec4 sampleTexture(vec2, int);\nvec4 encodeVec3(vec3);\nbool isMasked(vec3 pos);\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n\t// Initialize globals\n\tPixScale  = 255.0 * uOpacityRange[1];\n\tPixOffset = uOpacityRange[0] * uOpacityRange[1];\n\n    // Perform ray casting\n\tvec3 rayDir = normalize(vRayDirT);\t\n\tcalcXrayValue(rayDir);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the attenuated x-ray value for a given ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid calcXrayValue(vec3 rayDir)\n{\n\t// Initialize some globals needed by the getPixVal() routines\n\tNumMosaicsM1 = uNumTextures - 1;\t\n\tNzM1 = uVolNumImages - 1.0;\n\tMxInv = 1.0/uMosaicDims[0];\n\tMyInv = 1.0/uMosaicDims[1];    \n\tMinvFirst = vec2(1.0/uMosaicDims[0], 1.0/uMosaicDims[1]);\n\tMinvLast  = vec2(1.0/uMosaicDims[2], 1.0/uMosaicDims[3]);\n\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\t\n\t// Initialize the ray\n\tvec3 pos = vRayStartT;\n\tvec3 rayStep = rayDir*uRayStepSize;\n\tbool enteredSlab = false;\n\t\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\t\n\n\t// Walk along the ray\n\tfloat totalAtten = 0.0;\n\tfor (int i = 0; i < 32768; i++)\n\t{\t\t\n\t\t// Check whether the ray has exited the volume\n\t\tif ( any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\t\t\n\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tpos += rayStep;\n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\n\t\t// Add the current pixel value to the total\n\t\tif (!uMaskEnabled || !isMasked(pos)) {\n\t\t\tfloat pixVal = getPixVal(pos);\n\t\t\tif (uUseLut) {\n\t\t\t\tfloat lutArg = clamp(PixScale*pixVal - PixOffset, 0.0, 1.0);\t\n\t\t\t\tpixVal = 257.0 * texture2D(uLutSampler, vec2(lutArg, LUT_TX_YOFFSET)).a; \n\t\t\t}\n\t\t\ttotalAtten = min(255.0, totalAtten + uRayStepSize*pixVal);\n\t\t}\t\n\n\t\tpos += rayStep;\n\t}\n\n\t// Encode the 16-bit pixel value in two 8-bit color channels\t\n\ttotalAtten *= 255.0;\n\ttotalAtten = max(totalAtten, 1.0); // Do't allow zero, as we use zero to indicate background\n\tfloat highByte = floor(totalAtten/256.0);\n\tfloat lowByte = totalAtten - 256.0*highByte;\n    gl_FragColor = vec4(lowByte/255.0, highByte/255.0, 0.0, 1.0);\n}\n\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tvec3 slabAxis0 = normalize(p1 - p0);\n\tvec3 slabAxis1 = normalize(p2 - p0);\n\tvec3 slabAxis2 = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*slabAxis0.x,  VolAspect.x*slabAxis1.x,  VolAspect.x*slabAxis2.x,  0.0,\n\t\tVolAspect.y*slabAxis0.y,  VolAspect.y*slabAxis1.y,  VolAspect.y*slabAxis2.y,  0.0,\n\t\tVolAspect.z*slabAxis0.z,  VolAspect.z*slabAxis1.z,  VolAspect.z*slabAxis2.z,  0.0,\n       -dot(slabCtr, slabAxis0), -dot(slabCtr, slabAxis1), -dot(slabCtr, slabAxis2),  1.0\n\t);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Encodes the components of a vec3 in an rgba color.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 encodeVec3(vec3 loc)\n{\n\tif ( any(lessThan(loc,Zeros)) || any(greaterThan(loc,Ones)) ) \n\t{\n\t\t// We indicate an invalid value by setting the rightmost bit\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t}\t\n\n\t// Use 10 bits for each coordinate\n\thighp int xi = int( min(1023.0, (loc.x*1023.0 + 0.5)) );\n\thighp int yi = int( min(1023.0, (loc.y*1023.0 + 0.5)) );\n\thighp int zi = int( min(1023.0, (loc.z*1023.0 + 0.5)) );\n\n\tint zLo = zi - (zi/128) * 128;\n\tint zHi = (zi - zLo)/128;\n\n\tint yLo = yi - (yi/32) * 32;\n\tint yHi = (yi - yLo)/32;\n\n\tint xLo = xi - (xi/8) * 8;\n\tint xHi = (xi - xLo)/8;\n\n\tfloat a = float(zLo*2)/255.0;\n\tfloat b = float(zHi + 8*yLo)/255.0;\n\tfloat g = float(yHi + 32*xLo)/255.0;\n\tfloat r = float(xHi)/255.0;\n\n\treturn vec4(r, g, b, a);\n}\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point. \n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.5) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.5) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel values\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif ( sliceBelowIsEven ) \n\t{\n\t\tpixValB = dot(sampB.rg, ByteMask);\n\t\tpixValA = dot(sampB.ba, ByteMask);\n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.5) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\t\t\n\t\tpixValB = dot(sampB.ba, ByteMask);\n\t\tpixValA = dot(sampA.rg, ByteMask); \n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.25) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.25) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.25) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n \n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.5) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.5) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif (sliceBelowIsEven) \n\t{\n\t\tpixValB = dot(sampB, ByteMaskRG); \n\t\tpixValA = dot(sampB, ByteMaskBA); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.5) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = dot(sampB, ByteMaskBA);\n\t\tpixValA = dot(sampA, ByteMaskRG);\n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.25) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.25) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) components\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.25) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Samples a given texture at a given texture coordinate.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 sampleTexture(vec2 tc, int textureIndex)\n{\n\t// Performance seems to be better if we unroll the first few terms:\n\tif (textureIndex == 0) {\n\t\treturn texture2D(uSamplers[0], tc);\n\t}\n\t#if NUM_IMAGE_TEXTURES >= 2\n\telse if (textureIndex == 1) {\n\t\treturn texture2D(uSamplers[1], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 3\n\telse if (textureIndex == 2) {\n\t\treturn texture2D(uSamplers[2], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 4\n\telse if (textureIndex == 3) {\n\t\treturn texture2D(uSamplers[3], tc);\n\t} \n\t#endif\n\t#endif\n\t#endif\n\telse \n\t{\n\t\tfor (int i=4; i<NUM_IMAGE_TEXTURES; i++) \n\t\t{\n\t\t\tif (i == textureIndex) { return texture2D(uSamplers[i], tc);}\n\t\t}\n\t}\n} \n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture2D(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,h){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.gfx_vert_2="#version 300 es\n// gfx_vert_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; \nprecision highp int;\n\nin vec4 aPosition;\nin vec3 aNormal;\nin vec4 aColor;\nin vec4 aMaterial;\n\nuniform mat4 uMvpTransform;\nuniform mat4 uRotMatrix;\nuniform float uPersp;\n\nout vec4 vPosition;\nout vec3 vNormal;\nout vec4 vColor;\nout vec4 vMaterial;\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition;\n    gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0); \n\n    // Transform the normal as well\n    vNormal = mat3(uRotMatrix) * aNormal; \n\n    // Set varying values\n    vPosition = gl_Position;\n    vMaterial = aMaterial;\n    vColor = aColor;\n}\n";b.ShaderCode.gfx_frag_2=
"#version 300 es\n// gfx_frag_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; \nprecision highp int;\n\n// Uniforms and varyings\nuniform bool  uRenderDepthMap;\nin vec4       vPosition;\nin vec3       vNormal;\nin vec4       vColor;\nin vec4       vMaterial;\nout vec4      outColor;\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    if (uRenderDepthMap) \n    {\n        // Encode the depth in the b and a channels of the output color\n        float depth = 65535.0*clamp((vPosition.z+1.0)/2.0, 0.0, 1.0);\n        float dHigh = floor(depth/256.0);\n        float dLo = (depth - dHigh*256.0);\n        outColor = vec4(0.0, 0.0, dHigh/255.0, dLo/255.0);\n    }\n    else\n    {\n        // Apply lighting to the fragment color\n        float mAmbient      = vMaterial.r * 2.0;\n        float mDiffuse      = vMaterial.g * 2.0;\n        float mSpecStrength = vMaterial.b * 2.0;\n        float mSpecPower    = vMaterial.a * 255.0;\n\n        vec3 lightDir = vec3(0.0, 0.0, 1.0);\n        float cdot = clamp(-dot(normalize(vNormal), lightDir), 0.0, 1.0);\n        float diffuse = mDiffuse*(cdot - 0.6);\n        float specular = (mSpecStrength == 0.0) ? 0.0 : mSpecStrength * pow(cdot,mSpecPower);\n        \n        float light = max(0.0, mAmbient + diffuse + specular );   \n        outColor = vec4(vColor.rgb*light, vColor.a);\n    }\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,h){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.mip_vert_2="#version 300 es\n// mip_vert_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nuniform mat4  uMvpTransform;\nuniform mat4  uMvpInvTransform;\nuniform float uPersp;\nin vec4       aPosition;\nout vec3      vRayStartT;\nout vec3      vRayDirT;\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition;\n    float w = gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0); \n\n\t// Pass the ray's starting point and direction to the fragment shader (in texture coordinates).\n\t// Note that scaling of vRayDirT by w is necessary for perspective-correct interpolation.\n\tvRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = w * (uMvpInvTransform * vec4(gl_Position.xy*(uPersp/w), 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.mip_frag_2=
"#version 300 es\n// mip_frag_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\nprecision highp sampler3D;\n\n// Uniforms and varyings\nuniform sampler3D  uVolumeSampler;\nuniform sampler2D  uMaskSampler;\nuniform bool       uMaskEnabled;\nuniform int    uBitsPerPixel;\nuniform float  uRayStepSize;\nuniform vec3   uVolShape;\nuniform float  uSlabInfo[24];\nuniform bool   uPickMode;\nuniform vec2   uPickPoint;\nuniform bool   uShowMarker;\nuniform vec3   uMarkerLoc;\nuniform float  uMarkerSize;\nin  vec3 vRayStartT;\nin  vec3 vRayDirT;\nout vec4 outColor;\n\n// Constants\nconst float BBoxTol = 0.002; \nconst vec3 BboxMin  = vec3(-BBoxTol);\nconst vec3 BboxMax  = vec3(1.0 + BBoxTol);\nconst vec3 Zeros    = vec3(0.0);\nconst vec3 Ones     = vec3(1.0);\n\n// Globals\nvec2 PixConvert;\nvec3 VolAspect;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii;\nmat4 SlabXfrm;\n#endif\n\n// Function prototypes\nbool calcMipValue(vec3);\nbool calcPickLocation(vec3);\nvec4 encodeVec3(vec3);\nbool isMasked(vec3);\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n\t// Initialize globals\n\tPixConvert = vec2(1.0, 256.0*float(uBitsPerPixel > 8));\n\t\t\n    // Perform ray casting\n\tvec3 rayDir = normalize(vRayDirT);\t\n\tbool stat = calcPickLocation(rayDir) || calcMipValue(rayDir);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the maximum intensity along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcMipValue(vec3 rayDir)\n{\n\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\n\t// Initialize the ray\n\tvec3 pos = vRayStartT;\n\tvec3 rayStep = rayDir*uRayStepSize;\n\tfloat rayToMarkerDist = 10.0;\n\tbool enteredSlab = false;\n\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\t\n\n\t// Walk along the ray\n\tfloat maxPixVal = 0.0;\n\tint NumSteps = int(sqrt(3.0)/uRayStepSize + 0.5);\n\tfor (int i = 0; i < NumSteps; i++)\n\t{\t\t\n\t\t// Check whether the ray has exited the volume\n\t\tif ( any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\t\t\n\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tpos += rayStep;\n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\t\t\n\t\t// Get the current pixel value and compare it with the maximum\n\t\tif (!uMaskEnabled || !isMasked(pos)) { \n\t\t\tvec4 samp = texture(uVolumeSampler, pos);\n\t\t\tfloat pixVal = dot(samp.rg, PixConvert);\t\t\t\n\t\t\tmaxPixVal = max( maxPixVal, pixVal );\n\t\t}\t\n\t\t\t\n\t\t// Check whether to display a marker\n\t\trayToMarkerDist = min(rayToMarkerDist, length((pos-uMarkerLoc)*VolAspect));\t\n\n\t\tpos += rayStep;\n\t}\n\n\t// Encode the 16-bit pixel value in two 8-bit color channels\t\n\tmaxPixVal *= 255.0;\n\tmaxPixVal = max(maxPixVal, 1.0); // Don't allow zero, as we use zero to indicate background\n\tfloat highByte = floor(maxPixVal/256.0);\n\tfloat lowByte = maxPixVal - 256.0*highByte;\n\tfloat b = float(uShowMarker) * max(0.0, 1.0-rayToMarkerDist/uMarkerSize);\n\toutColor = vec4(lowByte/255.0, highByte/255.0, b, 1.0);\n\treturn true;\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the location of the maximum intensity point along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcPickLocation(vec3 rayDir)\n{\n    if (!uPickMode) { return false; }\n\n\tfloat tol = 1.0; // NB: Units here are pixels, not fractional texture coordinates\n\tif ( (abs(gl_FragCoord.x - uPickPoint.x) > tol) ||  (abs(gl_FragCoord.y - uPickPoint.y) > tol) ) \n\t{\n\t\t// Skip the computation if this is not the target fragment\n\t\toutColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t}\n\telse\n\t{\t\n\t\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\n\t\t// Initialize the ray\n\t\tvec3 pos = vRayStartT;\n\t\tvec3 rayStep = rayDir*uRayStepSize;\n\t\tbool enteredSlab = false;\n\n\t\t// Initialize slab variables\n\t\t#ifdef CLIP_TO_SLAB\n\t\tfloat slabOffset;\n\t\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\t\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t\t#endif\t\n\n\t\t// Initialize max info\n\t\tfloat maxPixVal = 0.0;\n\t\tvec3 maxLoc = vec3(-1.0);\n\n\t\t// Walk along the ray\n\t\tint NumSteps = int(sqrt(3.0)/uRayStepSize + 0.5);\n\t\tfor (int i = 0; i < NumSteps; i++)\n\t\t{\t\t\n\t\t\t// Check whether the ray has exited the volume\n\t\t\tif ( any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\t\t\n\n\t\t\t// Honor any slab constraints\n\t\t\t#ifdef CLIP_TO_SLAB\n\t\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\t\tif ( enteredSlab ) { break; }\n\t\t\t\tpos += rayStep;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tenteredSlab = true;\n\t\t\t#endif\n\t\t\t\n\t\t\t// Get the current pixel value and compare it with the maximum\n\t\t\tif (!uMaskEnabled || !isMasked(pos)) { \n\t\t\t\tvec4 samp = texture(uVolumeSampler, pos);\n\t\t\t\tfloat pixVal = dot(samp.rg, PixConvert);\t\t\t\n\t\t\t\tif (pixVal > maxPixVal) {\n\t\t\t\t\tmaxPixVal = pixVal;\n\t\t\t\t\tmaxLoc = pos;\t\n\t\t\t\t}\n\t\t\t}\t\n\t\t\tpos += rayStep;\n\t\t}\n\n\t\t// Encode the max location in the output color\t\n\t\toutColor = encodeVec3(maxLoc);\n\t}\n\treturn true;\n}\n\t\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tvec3 slabAxis0 = normalize(p1 - p0);\n\tvec3 slabAxis1 = normalize(p2 - p0);\n\tvec3 slabAxis2 = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*slabAxis0.x,  VolAspect.x*slabAxis1.x,  VolAspect.x*slabAxis2.x,  0.0,\n\t\tVolAspect.y*slabAxis0.y,  VolAspect.y*slabAxis1.y,  VolAspect.y*slabAxis2.y,  0.0,\n\t\tVolAspect.z*slabAxis0.z,  VolAspect.z*slabAxis1.z,  VolAspect.z*slabAxis2.z,  0.0,\n       -dot(slabCtr, slabAxis0), -dot(slabCtr, slabAxis1), -dot(slabCtr, slabAxis2),  1.0\n\t);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Encodes the components of a vec3 in an rgba color.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 encodeVec3(vec3 loc)\n{\n\tif ( any(lessThan(loc,Zeros)) || any(greaterThan(loc,Ones)) ) \n\t{\n\t\t// We indicate an invalid value by setting the rightmost bit\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t}\t\n\n\t// Use 10 bits for each coordinate\n\tint xi = min(1023, int(loc.x*1023.0 + 0.5));\n\tint yi = min(1023, int(loc.y*1023.0 + 0.5));\n\tint zi = min(1023, int(loc.z*1023.0 + 0.5));\n\n\tint zLo = zi - (zi/128) * 128;\n\tint zHi = (zi - zLo)/128;\n\n\tint yLo = yi - (yi/32) * 32;\n\tint yHi = (yi - yLo)/32;\n\n\tint xLo = xi - (xi/8) * 8;\n\tint xHi = (xi - xLo)/8;\n\n\tfloat a = float(zLo*2)/255.0;\n\tfloat b = float(zHi + 8*yLo)/255.0;\n\tfloat g = float(yHi + 32*xLo)/255.0;\n\tfloat r = float(xHi)/255.0;\n\n\treturn vec4(r, g, b, a);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,h){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.shadows_vert_2="#version 300 es\n// shadows_vert_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nuniform mat4 uShadowMvpTransform;\nuniform mat4 uShadowMvpInvTransform;\nin vec4      aPosition;\nout vec3     vRayStartT;\nout vec3     vRayDirT;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space\n    gl_Position = uShadowMvpTransform * aPosition; \n\n    // Pass the ray's starting point and direction, in texture coordinates, to the fragment shader\n\tvRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = (uShadowMvpInvTransform * vec4(0.0, 0.0, 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.shadows_frag_2=
"#version 300 es\n// shadows_frag_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\nprecision highp sampler3D;\n\n// Uniforms and varyings\nuniform sampler3D  uVolumeSampler;\nuniform sampler2D  uLutSampler;\nuniform sampler2D  uMaskSampler;\nuniform bool       uMaskEnabled;\nuniform vec3       uVolShape;\nuniform int        uBitsPerPixel;\nuniform float      uRayStepSize;\nuniform float      uOpacityRange[2];\nuniform float      uSlabInfo[24];\nuniform mat4       uShadowMvpTransform;\n\nin  vec3 vRayStartT;\nin  vec3 vRayDirT;\nout vec4 outColor;\n\n// Constants\nconst vec3 Ones             = vec3(1.0);\nconst vec3 Zeros            = vec3(0.0);\nconst float BBoxTol         = 0.002; \nconst vec3 BboxMin          = vec3(-BBoxTol);\nconst vec3 BboxMax          = vec3(1.0+BBoxTol);\nconst float TransparencySat = 0.02; // Saturation value\n\n// Globals\nvec3 VolAspect;\nvec2 PixConvert;\nfloat PixScale, PixOffset;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii, SlabAxes[3];\nmat4 SlabXfrm;\n#endif\n\n// Function prototypes\nvec4 renderShadowMap(vec3);\nfloat getNormalizedPixVal(vec3);\nvec4  encodeFloat(float);\nbool isMasked(vec3);\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n\t// Initialize globals\n\tPixConvert = vec2(1.0, 256.0*float(uBitsPerPixel > 8));\n\tPixScale   = 255.0 * uOpacityRange[1];\n\tPixOffset  = uOpacityRange[0] * uOpacityRange[1];\n\n\t// Compute the shadow map\n    outColor = renderShadowMap( normalize(vRayDirT) );\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the shadow map.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 renderShadowMap(vec3 rayDir)\n{\n\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\n\t// Initialize locals\n\tfloat stepSize   = uRayStepSize;\n\tvec3  rayStep    = stepSize * rayDir;\n\tfloat opacityExp = stepSize * 128.0;\n\tfloat bestDelta  = -1.0; \n\tfloat bestDepth  =  1.0;\n\tvec4 shadowMvp   = vec4(uShadowMvpTransform[0][2], uShadowMvpTransform[1][2], uShadowMvpTransform[2][2], uShadowMvpTransform[3][2]);\n\n\t// Initialize the ray\n\tvec3 pos        = vRayStartT;\n\tfloat tTot      = 1.0;\n\tfloat tBase     = 1.0;\n\tbool climbing   = false;\n\tbool enteredSlab = false;\n\t\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\n\n\t// Walk along the ray, looking for the largest jump in opacity\n\tint NumSteps = int(4.0/uRayStepSize); // We'll break out of the loop before hitting NumSteps\n\tfor (int i = 0; i < NumSteps; i++)\n\t{\t\t\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\t\t\t\n\t\t\tpos += rayStep; \n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\n\t\tif (uMaskEnabled && isMasked(pos)) { \n\t\t\tpos += rayStep; \n\t\t\tcontinue; \n\t\t}\n\n\t\t// Get the current voxel's opacity \n\t\tfloat opac = texture( uLutSampler, vec2(getNormalizedPixVal(pos), LUT_TX_YOFFSET)).a;\n\t\tif (opac == 0.0)\n\t\t{\n\t\t\t// We have entered an empty-space region, so increase the stepsize\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\n\t\t}\n\t\telse if (stepSize > 1.5*uRayStepSize) \n\t\t{\n\t\t\t// Revert to normal-size steps, and back-up a bit\n\t\t\tstepSize = uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\n\t\t\tpos -= rayStep;\n\t\t\topac = texture( uLutSampler, vec2(getNormalizedPixVal(pos), LUT_TX_YOFFSET)).a;\n\t\t}\n\n\t\t// Update the accumulated transparency\n\t\tfloat t = pow(max(0.0, 1.0-opac), opacityExp);\n\t\ttBase = mix(tBase, tTot, float(!climbing));\n\t\ttTot *= t;\n\t\tclimbing = climbing || (t < 0.99);\n\n\t\t// Check whether we are ending a climb, or maybe even the whole ray\n\t\tvec3 nextPos = pos + rayStep;\n\t\tbool terminateRay = (tTot < TransparencySat) || any(lessThan(nextPos, BboxMin)) || any(greaterThan(nextPos, BboxMax));\n\t\tif ( climbing && ((t >= 0.99) || terminateRay) ) // We are ending a climb\n\t\t{\n\t\t\tclimbing = false;\n\t\t\tfloat delta = tBase - tTot; \n\t\t\tfloat improved = float(delta > bestDelta);\n\t\t\tbestDelta = mix(bestDelta, delta, improved);\n\t\t\tbestDepth = mix(bestDepth, dot(shadowMvp, vec4(pos-0.5, 1.0)), improved);\n\t\t\tterminateRay = terminateRay || (bestDelta >= tTot);  \t\t\t\t\n\t\t}\n\t\tif (terminateRay) { break; }\n\n\t\tpos = nextPos;\n\t}\n\t\n\t// Return the best depth estimate\n\tfloat d = (bestDepth + 1.0)/2.0; // Ranges between 0.0 and 1.0\n\treturn encodeFloat(d);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point, normalized to the\n//   range [0,1].\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\t\n\t// Sample the volume\n\tvec4 samp = texture(uVolumeSampler, pos);\n\n\t// Combine color channels to decode the pixel value\n\tbool inBounds = all(lessThanEqual(pos,Ones)) && all(greaterThanEqual(pos,Zeros));\n\tfloat pixVal = dot(samp.rg, PixConvert) * float(inBounds);\t\n\n\t// Normalize\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\n}\n\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tSlabAxes[0] = normalize(p1 - p0);\n\tSlabAxes[1] = normalize(p2 - p0);\n\tSlabAxes[2] = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*SlabAxes[0].x,  VolAspect.x*SlabAxes[1].x,  VolAspect.x*SlabAxes[2].x,  0.0,\n\t\tVolAspect.y*SlabAxes[0].y,  VolAspect.y*SlabAxes[1].y,  VolAspect.y*SlabAxes[2].y,  0.0,\n\t\tVolAspect.z*SlabAxes[0].z,  VolAspect.z*SlabAxes[1].z,  VolAspect.z*SlabAxes[2].z,  0.0,\n       -dot(slabCtr, SlabAxes[0]), -dot(slabCtr, SlabAxes[1]), -dot(slabCtr, SlabAxes[2]),  1.0\n\t);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Encodes a float value in the first two components of a vec4.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 encodeFloat(float val)\n{\n\tfloat cVal = 65535.0 * clamp(val, 0.0, 1.0);\n\tfloat dHi = floor(cVal/256.0);\n\tfloat dLo = cVal - dHi*256.0;\n\treturn vec4(dHi/255.0, dLo/255.0, 0.0, 1.0);\n}\n\t\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,h){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.slab_vert_2="#version 300 es\n// slab_vert_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float;\nprecision highp int;\n\nin vec4       aPosition;\nin vec4       aColor;\nout vec4      vColor;\nuniform mat4  uMvpTransform;\nuniform float uPersp;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    gl_Position = uMvpTransform * aPosition;\n    gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0);\n    vColor = aColor;\n}\n";b.ShaderCode.slab_frag_2=
"#version 300 es\n// slab_frag_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; \nprecision highp int;\nin vec4 vColor;\nout vec4 outColor;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    outColor = vColor;\n}\n"})(window.BigLime=window.BigLime||{});
(function(b,h){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.vr_vert_2="#version 300 es\n// vr_vert_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nin vec4       aPosition;\nuniform mat4  uMvpTransform;\nuniform mat4  uMvpInvTransform;\nuniform float uPersp;\nout vec3      vRayStartT;\nout vec3      vRayDirT;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition;\n    float w = gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0); \n\n\t// Pass the ray's starting point and direction to the fragment shader (in texture coordinates).\n\t// Note that scaling of vRayDirT by w is necessary for perspective-correct interpolation.\n\tvRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = w * (uMvpInvTransform * vec4(gl_Position.xy*(uPersp/w), 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.vr_frag_2=
"#version 300 es\n// vr_frag_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\nprecision highp sampler3D;\n\n// Uniforms and varyings\nuniform sampler3D  uVolumeSampler;\nuniform sampler2D  uLutSampler;\nuniform sampler2D  uMaskSampler;\nuniform bool       uMaskEnabled;\nuniform vec3   uVrBackColor;\nuniform vec3   uVolShape;\nuniform int    uBitsPerPixel;\nuniform float  uRayStepSize;\nuniform vec2   uOutBufferSize;\nuniform float  uOpacityRange[2];\nuniform int    uAntiAlias;\nuniform float  uSlabInfo[24];\nuniform bool   uSealBorders;\nuniform bool   uPickMode;\nuniform vec2   uPickPoint;\nuniform bool   uShowMarker;\nuniform vec3   uMarkerLoc;\nuniform float  uMarkerSize;\nuniform vec4   uMarkerColor;\nuniform mat4   uModelTransform;\nuniform mat4   uViewTransform;\nuniform float  uAmbientLight;\nstruct Light {\n\tfloat diffuse;\n\tfloat specStrength;\n\tfloat specExp;\n\tfloat shadowDarkness;\n\tfloat shadowSoftness;\n\tvec3  dir;\n\tmat4  shadowMvp;\n};\nuniform Light uLights[2];\n\n#ifdef RENDER_GRAPHICS\nuniform sampler2D uGfxSampler;\nuniform float uGfxBlendWeight;\n#endif\n#ifdef RENDER_SHADOWS\nuniform sampler2D uShadowSampler;\nuniform float uShadowTxScale;\n#endif\n\nin  vec3 vRayStartT;\nin  vec3 vRayDirT;\nout vec4 outColor;\n\n \n// Constants\nconst vec3 UnitVectors[3]   = vec3[3]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0) );\nconst vec3 Ones             = vec3(1.0);\nconst vec3 Zeros            = vec3(0.0);\nconst float BBoxTol         = 0.002; \nconst vec3 BboxMin          = vec3(-BBoxTol);\nconst vec3 BboxMax          = vec3(1.0 + BBoxTol);\nconst float TransparencySat = 0.02; // Saturation value\nconst vec2 ToFloat16        = vec2(256.0, 1.0)/257.0; // For converting a pair of bytes to a float \n\n\n// Globals\nvec3 VolAspect, BorderNormal, GradOffset;\nfloat BorderNormalWeight, BorderReflectanceWt;\nvec2 PixConvert;\nfloat PixScale, PixOffset;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii, SlabAxes[3];\nmat4 SlabXfrm;\n#endif\n\n\n// Function prototypes\nbool  calcVrValue(vec3);\nbool  calcPickLocation(vec3);\nfloat getNormalizedPixVal(vec3);\nvoid  getBorderInfo(vec3, vec3, vec3, float, vec3);\nfloat rand(vec2);\nvec4  encodeVec3(vec3);\nbool isMasked(vec3);\n\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n#ifdef RENDER_SHADOWS\nfloat calcShadowWeight(vec3, int);\n#endif\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n\t// Initialize globals\n\tPixConvert = vec2(1.0, 256.0*float(uBitsPerPixel > 8));\n\tPixScale   = 255.0 * uOpacityRange[1];\n\tPixOffset  = uOpacityRange[0] * uOpacityRange[1];\n\t\t\n\t// Perform ray casting\n\tvec3 rayDir = normalize(vRayDirT);\n    bool stat = calcPickLocation(rayDir) || calcVrValue(rayDir);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the integrated color and opacity along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcVrValue(vec3 rayDir)\n{\n\t// Initializations\n\tVolAspect           = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\tvec3 gdx            = vec3(1.0/uVolShape[0], 0.0, 0.0);      // Offset for computing grad.x\n\tvec3 gdy            = vec3(0.0, 1.0/uVolShape[1], 0.0);      // Offset for computing grad.y\n\tvec3 gdz            = vec3(0.0, 0.0, 1.0/uVolShape[2]);      // Offset for computing grad.z\n\tvec3 gradDelta      = 1.5 * vec3(gdx.x, gdy.y, gdz.z);       // Offsets for computing gradients near borders\n\tfloat stepSize      = uRayStepSize;                          // The step-size for raycasting\n\tvec3 rayStep        = uRayStepSize * rayDir;                 // The ray increment\n\tfloat opacityExp    = uRayStepSize * 128.0;                  // For scaling the opacity to the ray step size\n\tfloat borderThresh  = uRayStepSize * 5.0;                    // Distance threshold for shading border surfaces \n\tfloat random        = rand(gl_FragCoord.xy);                 // For antialiasing\n\tint randIndex       = int(10.0*random + 1.0);\n\tfloat randRayOffset = float(uAntiAlias) * uRayStepSize * (random - 0.5); \n\n\t// Default border values\n\tBorderNormal = vec3(1.0, 0.0, 0.0);\n\tBorderNormalWeight = 0.0;\n\tBorderReflectanceWt = 1.0;\n\tGradOffset = vec3(0.0);\n\n\t// Initialize the ray\n\tfloat tTot            = 1.0;                                 // Accumulated transparency\n\tvec3 cTot             = vec3(0.0);                           // Accumulated color\n\tvec3 pos              = vRayStartT;                          // Current ray position\n\tvec3 pos_s            = vec3(0.0);                           // Current ray position in slab coordinates\n\tfloat currPixVal      = getNormalizedPixVal(pos);\n\tfloat prevPixVal      = 0.0;\n\tfloat nextPixVal      = 0.0;\n\tvec3 prevGrad         = vec3(0.0);\t\n\tfloat perpMarkerDist  = length( cross( (pos-uMarkerLoc)*VolAspect, normalize(rayDir*VolAspect) ) );\n\tbool omitMarkerTest   = !uShowMarker || (perpMarkerDist > uMarkerSize);\n\tbool enteredSlab      = false;\n\n\t\n\t#ifdef RENDER_GRAPHICS\n\tvec2 fragCoord = 0.5*gl_FragCoord.xy/uOutBufferSize;\n\tvec4 gfxColor0 = texture(uGfxSampler, vec2(fragCoord.x,       fragCoord.y      ));\n\tvec4 gfxDepth0 = texture(uGfxSampler, vec2(fragCoord.x + 0.5, fragCoord.y      ));\n\tvec4 gfxColor1 = texture(uGfxSampler, vec2(fragCoord.x,       fragCoord.y + 0.5));\n\tvec4 gfxDepth1 = texture(uGfxSampler, vec2(fragCoord.x + 0.5, fragCoord.y + 0.5));\n\tfloat depth0 = 2.0* dot(gfxDepth0.ba, ToFloat16) - 1.0;\n\tfloat depth1 = 2.0* dot(gfxDepth1.ba, ToFloat16) - 1.0;\n\tbool omitG0Test = (depth0 > 0.999);\n\tbool omitG1Test = (depth1 > 0.999);\n\tmat4 mvTransform = uViewTransform * uModelTransform;\n\tvec4 mvTransformZ = vec4(mvTransform[0][2], mvTransform[1][2], mvTransform[2][2], mvTransform[3][2]);\n\t#endif\n\n\tfloat prevShadowWeight0 = -1.0;\n\tfloat prevShadowWeight1 = -1.0;\n\tfloat sh0 = uLights[0].shadowDarkness;\n\tfloat sh1 = uLights[1].shadowDarkness;\n\tfloat drel0 = (uLights[0].diffuse == uLights[1].diffuse) ? 0.5 : uLights[0].diffuse/(uLights[0].diffuse + uLights[1].diffuse + 0.0001);\n\tfloat drel1 = 1.0 - drel0;\n\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\n\n\t// Walk along the ray\n\tint NumSteps = int(4.0/uRayStepSize); // We'll break out of the loop before hitting NumSteps\n\tfor (int i = 0; i < NumSteps; i++)\n\t{\t\t\n\t\t// We're done if the ray has exited the volume, or if the opacity threshold is exceeded\n\t\tif ( (tTot < TransparencySat) || any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\n\n\t\t// Does the current ray position intersect the marker?\n\t\tif (!omitMarkerTest)\n\t\t{\t\n\t\t\tvec3 pmVec = (pos - uMarkerLoc)*VolAspect;\t\n\t\t\tif ( length(pmVec) <= uMarkerSize ) {\n\t\t\t\tfloat pmPerpDist = length( cross(pmVec, normalize(rayDir*VolAspect)) );\n\t\t\t\tfloat shade = mix(1.0 - pmPerpDist/uMarkerSize, 1.0, 0.4);\n\t\t\t\tcTot += shade * uMarkerColor.rgb * uMarkerColor.a * tTot;\n\t\t\t\ttTot *= 1.0 - uMarkerColor.a;\n\t\t\t\tomitMarkerTest = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t\t\t\t\n\t\t// Apply random ray offset for antialiasing\n\t\tpos += (float(i == randIndex) * randRayOffset) * rayDir;\n\n\t\t#ifdef RENDER_GRAPHICS\t\t\n\t\tif ( !omitG0Test || !omitG1Test )\n\t\t{\t\n\t\t\tfloat gPosZ = dot(mvTransformZ, vec4(pos-0.5, 1.0));\n\t\t\tif ((!omitG1Test) && (gPosZ > depth1)) {\n\t\t\t\tcTot += gfxColor1.rgb * gfxColor1.a * tTot;\n\t\t\t\tcTot = mix(cTot, gfxColor1.rgb, uGfxBlendWeight);\n\t\t\t\ttTot *= 1.0 - gfxColor1.a;\n\t\t\t\tomitG1Test = true;\n\t\t\t\tcontinue;\t\t\t\n\t\t\t}\n\t\t\tif ((!omitG0Test) && (gPosZ > depth0)) {\n\t\t\t\tcTot += gfxColor0.rgb * gfxColor0.a * tTot;\n\t\t\t\tcTot = mix(cTot, gfxColor0.rgb, uGfxBlendWeight);\n\t\t\t\ttTot *= 1.0 - gfxColor0.a;\n\t\t\t\tomitG0Test = true;\n\t\t\t\tcontinue;\t\t\t\n\t\t\t}\n\t\t}\n\t\t#endif\t\t\n\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tpos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tprevPixVal = 0.0;  currPixVal = 0.0;\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\t\t\t\n\t\t\tpos += rayStep;  \n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\n\t\t// Get the pixel value. Use 3-point averaging along the ray\n\t\tnextPixVal = getNormalizedPixVal(pos + rayStep);\n\t\tfloat pixVal = 0.25*( prevPixVal + 2.0*currPixVal + nextPixVal );\n\t\tprevPixVal = currPixVal;  currPixVal = nextPixVal;\n\n\t\t// Check the opacity value\n\t\tvec4 lutVal = (uMaskEnabled && isMasked(pos)) ? vec4(0.0) : texture(uLutSampler, vec2(pixVal, LUT_TX_YOFFSET)); \n\t\tif (lutVal.a == 0.0)\n\t\t{\n\t\t\t// We have entered an empty-space region, so increase the stepsize\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (stepSize > 1.5*uRayStepSize) {\n\t\t\t\t// Revert to normal-size steps, and back-up\n\t\t\t\tstepSize    = uRayStepSize;\n\t\t\t\trayStep     = stepSize*rayDir;\n\t\t\t\tpos        -= rayStep;\n\t\t\t\tcurrPixVal  = getNormalizedPixVal(pos);\n\t\t\t\tprevPixVal  = getNormalizedPixVal(pos - rayStep);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check whether we are near a border\n\t\t\tif (uSealBorders) {\n\t\t\t\tgetBorderInfo(pos, rayDir, pos_s, borderThresh, gradDelta);\n\t\t\t}\n\n\t\t\t// Compute the intensity gradient\n\t\t\tvec3 gpos = pos + GradOffset;\n\t\t\tvec3 grad = vec3( \n\t\t\t\tgetNormalizedPixVal(gpos + gdx) - getNormalizedPixVal(gpos - gdx),\n\t\t\t\tgetNormalizedPixVal(gpos + gdy) - getNormalizedPixVal(gpos - gdy),\n\t\t\t\tgetNormalizedPixVal(gpos + gdz) - getNormalizedPixVal(gpos - gdz) );\t\n\n\t\t\t// Modify the gradient near borders\n\t\t\tgrad = mix(grad, BorderNormal, BorderNormalWeight);\n\t\t\tgrad = mix(grad, prevGrad, 0.5);\n\t\t\tprevGrad = grad;\n\t\t\tfloat gradMag = length(grad);\n\n\t\t\t// Compute the lighting factors\n\t\t\tvec3 N = grad/gradMag;\n\t\t\tvec3 L0 = uLights[0].dir;\n\t\t\tvec3 L1 = uLights[1].dir;\n\t\t\tvec3 R0 = reflect(-1.0*L0, N); // Assumes that L0, L1 are normalized\n\t\t\tvec3 R1 = reflect(-1.0*L1, N);\n\n\t\t\tfloat diffuse0 = 2.0 * uLights[0].diffuse * max(0.0, dot(N,L0));\n\t\t\tfloat diffuse1 = 2.0 * uLights[1].diffuse * max(0.0, dot(N,L1));\n\n\t\t\tfloat sdot0 = max(0.0, dot(R0, rayDir));\n\t\t\tfloat sdot1 = max(0.0, dot(R1, rayDir));\n\t\t\tfloat specular0 = 2.0 * uLights[0].specStrength * pow(sdot0, uLights[0].specExp);\n\t\t\tfloat specular1 = 2.0 * uLights[1].specStrength * pow(sdot1, uLights[1].specExp);\n\n\t\t\tfloat dsFactor = float(gradMag > 0.001)*BorderReflectanceWt;\n\t\t\tfloat light0 = uAmbientLight*drel0 + (diffuse0 + specular0)*dsFactor; \n\t\t\tfloat light1 = uAmbientLight*drel1 + (diffuse1 + specular1)*dsFactor; \n\n\t\t\t// Maybe draw shadows\n\t\t\t#ifdef RENDER_SHADOWS\n\t\t\tif (sh0 > 0.0) { \n\t\t\t\tfloat shadowWeight0 = ((prevShadowWeight0 < 0.0) || (tTot > 0.10)) ? calcShadowWeight(pos,0) : prevShadowWeight0;\n\t\t\t\tlight0 *= max(0.0, 1.0-sh0*shadowWeight0);\n\t\t\t\tprevShadowWeight0 = shadowWeight0;\n\t\t\t}\n\t\t\tif (sh1 > 0.0) {\n\t\t\t\tfloat shadowWeight1 = ((prevShadowWeight1 < 0.0) || (tTot > 0.10)) ? calcShadowWeight(pos,1) : prevShadowWeight1;\n\t\t\t\tlight1 *= max(0.0, 1.0-sh1*shadowWeight1); \n\t\t\t\tprevShadowWeight1 = shadowWeight1;\n\t\t\t}\n\t\t\t#endif // RENDER_SHADOWS\n\n\t\t\t// Update the total color\n\t\t\tfloat light = light0 + light1;\n\n\t\t\tfloat t = pow(max(0.0, 1.0-lutVal.a), opacityExp);\n\t\t\tvec3 c = lutVal.rgb * (1.0 - t) * light;\n\t\t\tcTot += c*tTot;\n\t\t\ttTot *= t;\n\t\t}\n\t\t\t\n\t\tpos += rayStep;\n\t}\n\t\n\tcTot += uVrBackColor*tTot;\n\toutColor = vec4(cTot, 1.0);\n\treturn true;\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the location of the most salient point along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcPickLocation(vec3 rayDir)\n{\n    if (!uPickMode) { return false; }\n\n\tfloat tol = 1.0; // NB: Units here are pixels, not fractional texture coordinates\n\tif ( (abs(gl_FragCoord.x - uPickPoint.x) > tol) ||  (abs(gl_FragCoord.y - uPickPoint.y) > tol) ) \n\t{\n\t\t// Skip the computation if this is not the target fragment\n\t\toutColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t}\n\telse\n\t{\n\t\t// Initializations\n\t\tVolAspect            = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\t\tvec3 rayStep         = uRayStepSize * rayDir;\n\t\tfloat opacityExp     = uRayStepSize * 128.0;\n\t\tvec3 maxLoc          = vec3(-1.0);\n\t\tvec3 runStart        = vec3(-1.0);\n\t\tfloat bestDelta      = -1.0; \n\n\t\t// Initialize the ray\n\t\tvec3 pos = vRayStartT;\n\t\tfloat tTot = 1.0;\n\t\tfloat tBase = -1.0;\n\t\t\n\t\t// Initialize slab variables\n\t\t#ifdef CLIP_TO_SLAB\n\t\tfloat slabOffset;\n\t\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\t\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t\t#endif\n\n\t\t// Walk along the ray\n\t\tint NumSteps = int(4.0/uRayStepSize); // We'll break out of the loop before hitting NumSteps\n\t\tfor (int i = 0; i < NumSteps; i++)\n\t\t{\t\t\n\t\t\t// Honor any slab constraints\n\t\t\t#ifdef CLIP_TO_SLAB\n\t\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\t\tpos += rayStep;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t#endif\n\n\t\t\t// Update the accumulated transparency\n\t\t\tfloat opac = (uMaskEnabled && isMasked(pos)) ? 0.0 : texture(uLutSampler, vec2(getNormalizedPixVal(pos), LUT_TX_YOFFSET)).a;\n\t\t\tfloat t = pow( max(0.0, 1.0-opac), opacityExp);\n\t\t\ttTot *= t;\n\n\t\t\t// Check whether the transparency is strictly decreasing\n\t\t\tif ( (t < 0.99) && (runStart.x < 0.0) )  \n\t\t\t{ \n\t\t\t\trunStart = pos; // The voxel has some opacity, so we are starting a new run\n\t\t\t\ttBase = tTot;\n\t\t\t}\n\n\t\t\tvec3 nextPos = pos + rayStep;\n\t\t\tbool terminateRay = (tTot < TransparencySat) || any(lessThan(nextPos, BboxMin)) || any(greaterThan(nextPos, BboxMax));\n\t\t\tif ( (runStart.x >= 0.0) && ((t >= 0.99) || terminateRay) ) // We are ending a run\n\t\t\t{\n\t\t\t\tfloat delta = tBase - tTot; \n\t\t\t\tfloat improved = float(delta > bestDelta);\n\t\t\t\tbestDelta = mix(bestDelta, delta, improved);\n\t\t\t\tmaxLoc = mix(maxLoc, runStart, improved);\n\t\t\t\trunStart = vec3(-1.0); \t\n\t\t\t\tterminateRay = terminateRay || (bestDelta >= tTot);  \t\t\t\n\t\t\t}\n\t\t\tif (terminateRay) { break; }\t\t\n\n\t\t\tpos = nextPos;\n\t\t}\n\t\t\n\t\t// Encode the max location in the output color\t\n\t\toutColor = encodeVec3(maxLoc);\n\t}\n\treturn true;\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point, normalized to the\n//   range [0,1].\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Sample the volume\n\tvec4 samp = texture(uVolumeSampler, pos);\n\n\t// Combine color channels to decode the pixel value\n\tbool inBounds = all(lessThanEqual(pos,Ones)) && all(greaterThanEqual(pos,Zeros));\n\tfloat pixVal = dot(samp.rg, PixConvert) * float(inBounds);\t\n\n\t// Normalize\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\n}\n\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tSlabAxes[0] = normalize(p1 - p0);\n\tSlabAxes[1] = normalize(p2 - p0);\n\tSlabAxes[2] = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*SlabAxes[0].x,  VolAspect.x*SlabAxes[1].x,  VolAspect.x*SlabAxes[2].x,  0.0,\n\t\tVolAspect.y*SlabAxes[0].y,  VolAspect.y*SlabAxes[1].y,  VolAspect.y*SlabAxes[2].y,  0.0,\n\t\tVolAspect.z*SlabAxes[0].z,  VolAspect.z*SlabAxes[1].z,  VolAspect.z*SlabAxes[2].z,  0.0,\n       -dot(slabCtr, SlabAxes[0]), -dot(slabCtr, SlabAxes[1]), -dot(slabCtr, SlabAxes[2]),  1.0\n\t);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the distance to the nearest border, and the normal vector of\n//   that border.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid getBorderInfo(vec3 pos, vec3 rayDir, vec3 pos_s, float borderThresh, vec3 gradDelta)\n{\n\t// Check the volume borders\n\tfloat minDist = borderThresh + 1.0;\n\tbool isSlabBorder = false;\n\t\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tfloat p = abs(pos[i]);\n\t\tif (p < minDist) { minDist = p;  BorderNormal = UnitVectors[i]; }\t\n\n\t\tp = abs(1.0 - pos[i]);\n\t\tif (p < minDist) { minDist = p;  BorderNormal = -1.0*UnitVectors[i]; }\t\n\n        #ifdef CLIP_TO_SLAB\t\n\t\tp = abs( SlabRadii[i] + pos_s[i] );\n\t\tif ( p < minDist ) { minDist = p;  BorderNormal = SlabAxes[i];  isSlabBorder = true; }\n\n\t\tp = abs( SlabRadii[i] - pos_s[i] );\n\t\tif ( p < minDist ) { minDist = p;  BorderNormal = -1.0*SlabAxes[i]; isSlabBorder = true; }\t\n        #endif\t\t\t\t\t\t\t\n\t}\t\n\n\tbool doBorderMod    = (minDist < borderThresh);\n\tfloat cosFactor     = max( 0.0, dot(normalize(BorderNormal),rayDir) );\n\tBorderNormalWeight  = doBorderMod ? (1.0 - minDist/borderThresh)*pow(cosFactor,0.25) : 0.0;\n\tBorderReflectanceWt = doBorderMod ? 1.0 - 0.75*pow(cosFactor,4.0) : 1.0;\n\tGradOffset          = (doBorderMod && !isSlabBorder ) ? BorderNormal*gradDelta : Zeros;\n}\n\n\n#ifdef RENDER_SHADOWS\n///////////////////////////////////////////////////////////////////////////////\n//\n// Implements percentage-closer filtering for soft shadow edges.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat calcShadowWeight(vec3 pos, int lightIndex)\n{\n\t// Initialize constants\n\tfloat step = uLights[lightIndex].shadowSoftness * 0.0054;\n\tfloat dx = step / max(1.0, uOutBufferSize.x/uOutBufferSize.y);\n\tfloat dy = step / max(1.0, uOutBufferSize.y/uOutBufferSize.x);\n\n\t// Get the shadow-map coordinates of the input point\n\tvec4 pt = 0.5*(uLights[lightIndex].shadowMvp * vec4(pos-0.5, 1.0) + 1.0);\n\n\t// Apply a random offset to reduce banding artifacts\n\tfloat px0 = pt.x + dx * 0.8*(rand(pos.xz) - 0.5); \n\tfloat py0 = pt.y + dy * 0.8*(rand(pos.yz) - 0.5);\n\t\t\n\t// Apply a small z-offset to prevent self-shadowing\t\n\tfloat pzd = pt.z - 1.0/uVolShape[0]; \n\n\tpx0 *= uShadowTxScale;\n\tpy0 *= uShadowTxScale;\n\tdx *= uShadowTxScale;\n\tdy *= uShadowTxScale;\n\n\t// Tabulate sampling points\n\tfloat pxp1 = px0  + dx;\n\tfloat pxm1 = px0  - dx;\n\tfloat pxp2 = pxp1 + dx;\n\tfloat pxm2 = pxm1 - dx;\n\tfloat pxp3 = pxp2 + dx;\n\tfloat pxm3 = pxm2 - dx;\n\tfloat pxp4 = pxp3 + dx;\n\tfloat pxm4 = pxm3 - dx;\n\n\tfloat pyp1 = py0  + dy;\n\tfloat pym1 = py0  - dy;\n\tfloat pyp2 = pyp1 + dy;\n\tfloat pym2 = pym1 - dy;\n\tfloat pyp3 = pyp2 + dy;\n\tfloat pym3 = pym2 - dy;\n\tfloat pyp4 = pyp3 + dy;\n\tfloat pym4 = pym3 - dy;\n\n\tfloat fL = float(lightIndex);\n\tpy0  = 0.5*(py0 + fL);\n\tpyp1 = 0.5*(pyp1 + fL);\n\tpym1 = 0.5*(pym1 + fL);\n\tpyp2 = 0.5*(pyp2 + fL);\n\tpym2 = 0.5*(pym2 + fL);\n\tpyp3 = 0.5*(pyp3 + fL);\n\tpym3 = 0.5*(pym3 + fL);\n\tpyp4 = 0.5*(pyp4 + fL);\n\tpym4 = 0.5*(pym4 + fL);\n\t \n\t// Unrolled loop for better performance:\n\tvec4 smTexVal = texture(uShadowSampler, vec2(px0, py0));\n\tfloat smDepth = dot(smTexVal.rg, ToFloat16);\n\tfloat wt = float(pzd > smDepth);\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pym4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pym4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pym4)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm3, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm2, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp2, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp3, pym3)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm3, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm2, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp2, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp3, pym2)).rg, ToFloat16 ));\t\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm4, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm3, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm2, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp2, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp3, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp4, pym1)).rg, ToFloat16 ));\n\t\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm4, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm3, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm2, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, py0)).rg, ToFloat16 ));\n\t//-------------------------------------------------------------------------------\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp2, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp3, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp4, py0)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm4, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm3, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm2, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp2, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp3, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp4, pyp1)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm3, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm2, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp2, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp3, pyp2)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm3, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm2, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp2, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp3, pyp3)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pyp4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pyp4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pyp4)).rg, ToFloat16 ));\n\n\treturn wt/61.0;\t\t\n}\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets a random number given a 2-component seed.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat rand(vec2 xy)\n{\n    return fract(sin(dot(xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Encodes the components of a vec3 in an rgba color.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 encodeVec3(vec3 loc)\n{\n\tif ( any(lessThan(loc,Zeros)) || any(greaterThan(loc,Ones)) ) \n\t{\n\t\t// We indicate an invalid value by setting the rightmost bit\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t}\t\n\n\t// Use 10 bits for each coordinate\n\tint xi = min(1023, int(loc.x*1023.0 + 0.5));\n\tint yi = min(1023, int(loc.y*1023.0 + 0.5));\n\tint zi = min(1023, int(loc.z*1023.0 + 0.5));\n\n\tint zLo = zi - (zi/128) * 128;\n\tint zHi = (zi - zLo)/128;\n\n\tint yLo = yi - (yi/32) * 32;\n\tint yHi = (yi - yLo)/32;\n\n\tint xLo = xi - (xi/8) * 8;\n\tint xHi = (xi - xLo)/8;\n\n\tfloat a = float(zLo*2)/255.0;\n\tfloat b = float(zHi + 8*yLo)/255.0;\n\tfloat g = float(yHi + 32*xLo)/255.0;\n\tfloat r = float(xHi)/255.0;\n\n\treturn vec4(r, g, b, a);\n}\n\t\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,h){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.winLevel_vert_2="#version 300 es\n// winLevel_vert_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float;\nprecision highp int;\n\nuniform float uWinWidth;\nuniform float uWinLevel;\nin vec4       aPosition;\nout float     vPixScale;\nout float     vPixOffset;\nout vec2      vTexCoord;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Convert from clip space to texture coordinates\n    vTexCoord = (aPosition.xy + 1.0)*0.5;\n\n    // Compute the scale and offset factor for the window/level transform\n    float level = uWinLevel*(257.0/65535.0);\n    float width = uWinWidth*(257.0/65535.0);\n\tvPixScale = 1.0/(width + 0.001);\n\tvPixOffset = level - width/2.0;\n\n    gl_Position = aPosition;    \n}\n";b.ShaderCode.winLevel_frag_2=
"#version 300 es\n// winLevel_frag_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D uWLSampler;\nuniform sampler2D uLutSampler;\nuniform int       uPassThruMode;\nuniform int       uColorMapIndex;\nuniform vec4      uMarkerColor;\nin float          vPixScale;\nin float          vPixOffset;\nin vec2           vTexCoord;\nout vec4          outColor;\n\nvoid main()\n{\n\t// Read the output from the renderer\n\tvec4 textureVal = texture(uWLSampler, vTexCoord);\n\n\tif (uPassThruMode > 0) \n\t{\n\t\t// Pass-thru mode means we don't modify the pixels\n\t\toutColor = textureVal;\n\t}\n\telse\n\t{\n\t\tif (textureVal.b != 0.0) \n\t\t{\n            // Just render the marker\n\t\t\toutColor = vec4( ((textureVal.b+2.0)/3.0) * uMarkerColor.rgb, uMarkerColor.a );\n\t    }\n\t\telse\n\t\t{\n\t\t    // Get the raw pixel value\n\t\t\tfloat rawPixVal = textureVal.r + 256.0*textureVal.g;\n\t\t\tif (rawPixVal == 0.0) \n\t\t\t{\n\t\t\t    // We're in the background\n\t\t\t\toutColor = vec4(0.0, 0.0, 0.0, 1.0); \n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t    // Apply the window/level transform \n\t\t\t\tfloat wlPixVal = clamp( vPixScale*(rawPixVal - vPixOffset), 0.0, 1.0 );\n\t\t\t\tif (uColorMapIndex == 0) {\t\n\t\t\t\t\toutColor = vec4(wlPixVal, wlPixVal, wlPixVal, 1.0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t    // Apply the lookup table\n\t\t\t\t\toutColor = texture(uLutSampler, vec2(LUT_TX_XSCALE*wlPixVal, LUT_TX_YOFFSET + float(uColorMapIndex)*LUT_TX_YSCALE));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\n\t\t// Recombine the R and G color channels into a 16-bit pixel value\n\t\tfloat rawPixVal = textureVal.r + 256.0*textureVal.g;\n\n\t\tif (textureVal.b == 0.0) {\n\t\t    // Apply the window/level transform\n\t\t\tif (uColorMapIndex == 0) {\n\t\t\t\tfloat wlPixVal = (rawPixVal == 0.0) ? 0.0 : clamp( vPixScale*(rawPixVal - vPixOffset), 0.0, 1.0 );\n\t\t\t\toutColor = vec4(wlPixVal, wlPixVal, wlPixVal, 1.0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfloat wlPixVal = (rawPixVal == 0.0) ? 0.0 : clamp( vPixScale*(rawPixVal - vPixOffset), 0.0, 1.0 );\n\t\t\t\toutColor = texture(uLutSampler, vec2(LUT_TX_XSCALE*wlPixVal, LUT_TX_YOFFSET + float(uColorMapIndex)*LUT_TX_YSCALE));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Render the marker\n\t\t\toutColor = vec4( ((textureVal.b+2.0)/3.0) * uMarkerColor.rgb, uMarkerColor.a );\n\t\t}\n\t}\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,h){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.xray_vert_2="#version 300 es\n// xray_vert_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nuniform mat4  uMvpTransform;\nuniform mat4  uMvpInvTransform;\nuniform float uPersp;\nin vec4       aPosition;\nout vec3      vRayStartT;\nout vec3      vRayDirT;\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition;\n    float w = gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0); \n\n\t// Pass the ray's starting point and direction to the fragment shader (in texture coordinates).\n\t// Note that scaling of vRayDirT by w is necessary for perspective-correct interpolation.\n\tvRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = w * (uMvpInvTransform * vec4(gl_Position.xy*(uPersp/w), 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.xray_frag_2=
"#version 300 es\n// xray_frag_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\nprecision highp sampler3D;\n\n// Uniforms and varyings\nuniform sampler3D  uVolumeSampler;\nuniform sampler2D  uMaskSampler;\nuniform sampler2D  uLutSampler;\nuniform bool   uUseLut;\nuniform bool   uMaskEnabled;\nuniform float  uOpacityRange[2];\nuniform int    uBitsPerPixel;\nuniform float  uRayStepSize;\nuniform vec3   uVolShape;\nuniform float  uSlabInfo[24];\nin  vec3 vRayStartT;\nin  vec3 vRayDirT;\nout vec4 outColor;\n\n// Constants\nconst float BBoxTol = 0.002; \nconst vec3 BboxMin  = vec3(-BBoxTol);\nconst vec3 BboxMax  = vec3(1.0 + BBoxTol);\nconst vec3 Zeros    = vec3(0.0);\nconst vec3 Ones     = vec3(1.0);\n\n// Globals\nvec2 PixConvert;\nfloat PixScale, PixOffset;\nvec3 VolAspect;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii;\nmat4 SlabXfrm;\n#endif\n\n// Function prototypes\nvoid calcXrayValue(vec3);\nbool isMasked(vec3);\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n\t// Initialize globals\n\tPixConvert = vec2(1.0, 256.0*float(uBitsPerPixel > 8));\n\tPixScale   = 255.0 * uOpacityRange[1];\n\tPixOffset  = uOpacityRange[0] * uOpacityRange[1];\n\t\t\n    // Perform ray casting\n\tvec3 rayDir = normalize(vRayDirT);\t\n    calcXrayValue(rayDir);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the attenuated x-ray value along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid calcXrayValue(vec3 rayDir)\n{\n\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\n\t// Initialize the ray\n\tvec3 pos = vRayStartT;\n\tvec3 rayStep = rayDir*uRayStepSize;\n\tbool enteredSlab = false;\n\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\t\n\n\t// Walk along the ray\n\tfloat totalAtten = 0.0;\n\tint NumSteps = int(sqrt(3.0)/uRayStepSize + 0.5);\n\tfor (int i = 0; i < NumSteps; i++)\n\t{\t\t\n\t\t// Check whether the ray has exited the volume\n\t\tif ( any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\t\t\n\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tpos += rayStep;\n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\t\t\n\t\t// Add the current pixel value to the total\n\t\tif (!uMaskEnabled || !isMasked(pos)) {\n\t\t\tvec4 samp = texture(uVolumeSampler, pos);\n\t\t\tfloat pixVal = dot(samp.rg, PixConvert);\t\n\t\t\tif (uUseLut) {\n\t\t\t\tfloat lutArg = clamp(PixScale*pixVal - PixOffset, 0.0, 1.0);\t\n\t\t\t\tpixVal = 257.0 * texture(uLutSampler, vec2(lutArg, LUT_TX_YOFFSET)).a; \n\t\t\t}\n\t\t\ttotalAtten = min(255.0, totalAtten + uRayStepSize*pixVal );\t\n\t\t}\n\n\t\tpos += rayStep;\n\t}\n\n\t// Encode the 16-bit pixel value in two 8-bit color channels\t\n\ttotalAtten *= 255.0;\n\ttotalAtten = max(totalAtten, 1.0); // Do't allow zero, as we use zero to indicate background\n\tfloat highByte = floor(totalAtten/256.0);\n\tfloat lowByte = totalAtten - 256.0*highByte;\n\toutColor = vec4(lowByte/255.0, highByte/255.0, 0.0, 1.0);\n}\n\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tvec3 slabAxis0 = normalize(p1 - p0);\n\tvec3 slabAxis1 = normalize(p2 - p0);\n\tvec3 slabAxis2 = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*slabAxis0.x,  VolAspect.x*slabAxis1.x,  VolAspect.x*slabAxis2.x,  0.0,\n\t\tVolAspect.y*slabAxis0.y,  VolAspect.y*slabAxis1.y,  VolAspect.y*slabAxis2.y,  0.0,\n\t\tVolAspect.z*slabAxis0.z,  VolAspect.z*slabAxis1.z,  VolAspect.z*slabAxis2.z,  0.0,\n       -dot(slabCtr, slabAxis0), -dot(slabCtr, slabAxis1), -dot(slabCtr, slabAxis2),  1.0\n\t);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
