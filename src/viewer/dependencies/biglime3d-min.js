var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.arrayIteratorImpl=function(b){var k=0;return function(){return k<b.length?{done:!1,value:b[k++]}:{done:!0}}};$jscomp.arrayIterator=function(b){return{next:$jscomp.arrayIteratorImpl(b)}};$jscomp.makeIterator=function(b){var k="undefined"!=typeof Symbol&&Symbol.iterator&&b[Symbol.iterator];return k?k.call(b):$jscomp.arrayIterator(b)};$jscomp.arrayFromIterator=function(b){for(var k,c=[];!(k=b.next()).done;)c.push(k.value);return c};
$jscomp.arrayFromIterable=function(b){return b instanceof Array?b:$jscomp.arrayFromIterator($jscomp.makeIterator(b))};$jscomp.getGlobal=function(b){return"undefined"!=typeof window&&window===b?b:"undefined"!=typeof global&&null!=global?global:b};$jscomp.global=$jscomp.getGlobal(this);$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;
$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(b,k,c){b!=Array.prototype&&b!=Object.prototype&&(b[k]=c.value)};$jscomp.polyfill=function(b,k,c,a){if(k){c=$jscomp.global;b=b.split(".");for(a=0;a<b.length-1;a++){var f=b[a];f in c||(c[f]={});c=c[f]}b=b[b.length-1];a=c[b];k=k(a);k!=a&&null!=k&&$jscomp.defineProperty(c,b,{configurable:!0,writable:!0,value:k})}};$jscomp.FORCE_POLYFILL_PROMISE=!1;
$jscomp.polyfill("Promise",function(b){function k(){this.batch_=null}function c(a){return a instanceof f?a:new f(function(b,e){b(a)})}if(b&&!$jscomp.FORCE_POLYFILL_PROMISE)return b;k.prototype.asyncExecute=function(a){null==this.batch_&&(this.batch_=[],this.asyncExecuteBatch_());this.batch_.push(a);return this};k.prototype.asyncExecuteBatch_=function(){var a=this;this.asyncExecuteFunction(function(){a.executeBatch_()})};var a=$jscomp.global.setTimeout;k.prototype.asyncExecuteFunction=function(b){a(b,
0)};k.prototype.executeBatch_=function(){for(;this.batch_&&this.batch_.length;){var a=this.batch_;this.batch_=[];for(var b=0;b<a.length;++b){var d=a[b];a[b]=null;try{d()}catch(l){this.asyncThrow_(l)}}}this.batch_=null};k.prototype.asyncThrow_=function(a){this.asyncExecuteFunction(function(){throw a;})};var f=function(a){this.state_=0;this.result_=void 0;this.onSettledCallbacks_=[];var b=this.createResolveAndReject_();try{a(b.resolve,b.reject)}catch(g){b.reject(g)}};f.prototype.createResolveAndReject_=
function(){function a(a){return function(e){d||(d=!0,a.call(b,e))}}var b=this,d=!1;return{resolve:a(this.resolveTo_),reject:a(this.reject_)}};f.prototype.resolveTo_=function(a){if(a===this)this.reject_(new TypeError("A Promise cannot resolve to itself"));else if(a instanceof f)this.settleSameAsPromise_(a);else{a:switch(typeof a){case "object":var b=null!=a;break a;case "function":b=!0;break a;default:b=!1}b?this.resolveToNonPromiseObj_(a):this.fulfill_(a)}};f.prototype.resolveToNonPromiseObj_=function(a){var b=
void 0;try{b=a.then}catch(g){this.reject_(g);return}"function"==typeof b?this.settleSameAsThenable_(b,a):this.fulfill_(a)};f.prototype.reject_=function(a){this.settle_(2,a)};f.prototype.fulfill_=function(a){this.settle_(1,a)};f.prototype.settle_=function(a,b){if(0!=this.state_)throw Error("Cannot settle("+a+", "+b+"): Promise already settled in state"+this.state_);this.state_=a;this.result_=b;this.executeOnSettledCallbacks_()};f.prototype.executeOnSettledCallbacks_=function(){if(null!=this.onSettledCallbacks_){for(var a=
0;a<this.onSettledCallbacks_.length;++a)d.asyncExecute(this.onSettledCallbacks_[a]);this.onSettledCallbacks_=null}};var d=new k;f.prototype.settleSameAsPromise_=function(a){var b=this.createResolveAndReject_();a.callWhenSettled_(b.resolve,b.reject)};f.prototype.settleSameAsThenable_=function(a,b){var d=this.createResolveAndReject_();try{a.call(b,d.resolve,d.reject)}catch(l){d.reject(l)}};f.prototype.then=function(a,b){function d(a,b){return"function"==typeof a?function(b){try{e(a(b))}catch(t){c(t)}}:
b}var e,c,h=new f(function(a,b){e=a;c=b});this.callWhenSettled_(d(a,e),d(b,c));return h};f.prototype.catch=function(a){return this.then(void 0,a)};f.prototype.callWhenSettled_=function(a,b){function f(){switch(e.state_){case 1:a(e.result_);break;case 2:b(e.result_);break;default:throw Error("Unexpected state: "+e.state_);}}var e=this;null==this.onSettledCallbacks_?d.asyncExecute(f):this.onSettledCallbacks_.push(f)};f.resolve=c;f.reject=function(a){return new f(function(b,d){d(a)})};f.race=function(a){return new f(function(b,
d){for(var f=$jscomp.makeIterator(a),e=f.next();!e.done;e=f.next())c(e.value).callWhenSettled_(b,d)})};f.all=function(a){var b=$jscomp.makeIterator(a),d=b.next();return d.done?c([]):new f(function(a,f){function e(b){return function(d){h[b]=d;g--;0==g&&a(h)}}var h=[],g=0;do h.push(void 0),g++,c(d.value).callWhenSettled_(e(h.length-1),f),d=b.next();while(!d.done)})};return f},"es6","es3");$jscomp.SYMBOL_PREFIX="jscomp_symbol_";
$jscomp.initSymbol=function(){$jscomp.initSymbol=function(){};$jscomp.global.Symbol||($jscomp.global.Symbol=$jscomp.Symbol)};$jscomp.Symbol=function(){var b=0;return function(k){return $jscomp.SYMBOL_PREFIX+(k||"")+b++}}();
$jscomp.initSymbolIterator=function(){$jscomp.initSymbol();var b=$jscomp.global.Symbol.iterator;b||(b=$jscomp.global.Symbol.iterator=$jscomp.global.Symbol("iterator"));"function"!=typeof Array.prototype[b]&&$jscomp.defineProperty(Array.prototype,b,{configurable:!0,writable:!0,value:function(){return $jscomp.iteratorPrototype($jscomp.arrayIteratorImpl(this))}});$jscomp.initSymbolIterator=function(){}};
$jscomp.initSymbolAsyncIterator=function(){$jscomp.initSymbol();var b=$jscomp.global.Symbol.asyncIterator;b||(b=$jscomp.global.Symbol.asyncIterator=$jscomp.global.Symbol("asyncIterator"));$jscomp.initSymbolAsyncIterator=function(){}};$jscomp.iteratorPrototype=function(b){$jscomp.initSymbolIterator();b={next:b};b[$jscomp.global.Symbol.iterator]=function(){return this};return b};$jscomp.underscoreProtoCanBeSet=function(){var b={a:!0},k={};try{return k.__proto__=b,k.a}catch(c){}return!1};
$jscomp.setPrototypeOf="function"==typeof Object.setPrototypeOf?Object.setPrototypeOf:$jscomp.underscoreProtoCanBeSet()?function(b,k){b.__proto__=k;if(b.__proto__!==k)throw new TypeError(b+" is not extensible");return b}:null;$jscomp.generator={};$jscomp.generator.ensureIteratorResultIsObject_=function(b){if(!(b instanceof Object))throw new TypeError("Iterator result "+b+" is not an object");};
$jscomp.generator.Context=function(){this.isRunning_=!1;this.yieldAllIterator_=null;this.yieldResult=void 0;this.nextAddress=1;this.finallyAddress_=this.catchAddress_=0;this.finallyContexts_=this.abruptCompletion_=null};$jscomp.generator.Context.prototype.start_=function(){if(this.isRunning_)throw new TypeError("Generator is already running");this.isRunning_=!0};$jscomp.generator.Context.prototype.stop_=function(){this.isRunning_=!1};
$jscomp.generator.Context.prototype.jumpToErrorHandler_=function(){this.nextAddress=this.catchAddress_||this.finallyAddress_};$jscomp.generator.Context.prototype.next_=function(b){this.yieldResult=b};$jscomp.generator.Context.prototype.throw_=function(b){this.abruptCompletion_={exception:b,isException:!0};this.jumpToErrorHandler_()};$jscomp.generator.Context.prototype.return=function(b){this.abruptCompletion_={return:b};this.nextAddress=this.finallyAddress_};
$jscomp.generator.Context.prototype.jumpThroughFinallyBlocks=function(b){this.abruptCompletion_={jumpTo:b};this.nextAddress=this.finallyAddress_};$jscomp.generator.Context.prototype.yield=function(b,k){this.nextAddress=k;return{value:b}};$jscomp.generator.Context.prototype.yieldAll=function(b,k){b=$jscomp.makeIterator(b);var c=b.next();$jscomp.generator.ensureIteratorResultIsObject_(c);if(c.done)this.yieldResult=c.value,this.nextAddress=k;else return this.yieldAllIterator_=b,this.yield(c.value,k)};
$jscomp.generator.Context.prototype.jumpTo=function(b){this.nextAddress=b};$jscomp.generator.Context.prototype.jumpToEnd=function(){this.nextAddress=0};$jscomp.generator.Context.prototype.setCatchFinallyBlocks=function(b,k){this.catchAddress_=b;void 0!=k&&(this.finallyAddress_=k)};$jscomp.generator.Context.prototype.setFinallyBlock=function(b){this.catchAddress_=0;this.finallyAddress_=b||0};$jscomp.generator.Context.prototype.leaveTryBlock=function(b,k){this.nextAddress=b;this.catchAddress_=k||0};
$jscomp.generator.Context.prototype.enterCatchBlock=function(b){this.catchAddress_=b||0;b=this.abruptCompletion_.exception;this.abruptCompletion_=null;return b};$jscomp.generator.Context.prototype.enterFinallyBlock=function(b,k,c){c?this.finallyContexts_[c]=this.abruptCompletion_:this.finallyContexts_=[this.abruptCompletion_];this.catchAddress_=b||0;this.finallyAddress_=k||0};
$jscomp.generator.Context.prototype.leaveFinallyBlock=function(b,k){k=this.finallyContexts_.splice(k||0)[0];if(k=this.abruptCompletion_=this.abruptCompletion_||k){if(k.isException)return this.jumpToErrorHandler_();void 0!=k.jumpTo&&this.finallyAddress_<k.jumpTo?(this.nextAddress=k.jumpTo,this.abruptCompletion_=null):this.nextAddress=this.finallyAddress_}else this.nextAddress=b};$jscomp.generator.Context.prototype.forIn=function(b){return new $jscomp.generator.Context.PropertyIterator(b)};
$jscomp.generator.Context.PropertyIterator=function(b){this.object_=b;this.properties_=[];for(var k in b)this.properties_.push(k);this.properties_.reverse()};$jscomp.generator.Context.PropertyIterator.prototype.getNext=function(){for(;0<this.properties_.length;){var b=this.properties_.pop();if(b in this.object_)return b}return null};$jscomp.generator.Engine_=function(b){this.context_=new $jscomp.generator.Context;this.program_=b};
$jscomp.generator.Engine_.prototype.next_=function(b){this.context_.start_();if(this.context_.yieldAllIterator_)return this.yieldAllStep_(this.context_.yieldAllIterator_.next,b,this.context_.next_);this.context_.next_(b);return this.nextStep_()};
$jscomp.generator.Engine_.prototype.return_=function(b){this.context_.start_();var k=this.context_.yieldAllIterator_;if(k)return this.yieldAllStep_("return"in k?k["return"]:function(b){return{value:b,done:!0}},b,this.context_.return);this.context_.return(b);return this.nextStep_()};
$jscomp.generator.Engine_.prototype.throw_=function(b){this.context_.start_();if(this.context_.yieldAllIterator_)return this.yieldAllStep_(this.context_.yieldAllIterator_["throw"],b,this.context_.next_);this.context_.throw_(b);return this.nextStep_()};
$jscomp.generator.Engine_.prototype.yieldAllStep_=function(b,k,c){try{var a=b.call(this.context_.yieldAllIterator_,k);$jscomp.generator.ensureIteratorResultIsObject_(a);if(!a.done)return this.context_.stop_(),a;var f=a.value}catch(d){return this.context_.yieldAllIterator_=null,this.context_.throw_(d),this.nextStep_()}this.context_.yieldAllIterator_=null;c.call(this.context_,f);return this.nextStep_()};
$jscomp.generator.Engine_.prototype.nextStep_=function(){for(;this.context_.nextAddress;)try{var b=this.program_(this.context_);if(b)return this.context_.stop_(),{value:b.value,done:!1}}catch(k){this.context_.yieldResult=void 0,this.context_.throw_(k)}this.context_.stop_();if(this.context_.abruptCompletion_){b=this.context_.abruptCompletion_;this.context_.abruptCompletion_=null;if(b.isException)throw b.exception;return{value:b.return,done:!0}}return{value:void 0,done:!0}};
$jscomp.generator.Generator_=function(b){this.next=function(k){return b.next_(k)};this.throw=function(k){return b.throw_(k)};this.return=function(k){return b.return_(k)};$jscomp.initSymbolIterator();this[Symbol.iterator]=function(){return this}};$jscomp.generator.createGenerator=function(b,k){k=new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(k));$jscomp.setPrototypeOf&&$jscomp.setPrototypeOf(k,b.prototype);return k};
$jscomp.asyncExecutePromiseGenerator=function(b){function k(a){return b.next(a)}function c(a){return b.throw(a)}return new Promise(function(a,f){function d(b){b.done?a(b.value):Promise.resolve(b.value).then(k,c).then(d,f)}d(b.next())})};$jscomp.asyncExecutePromiseGeneratorFunction=function(b){return $jscomp.asyncExecutePromiseGenerator(b())};$jscomp.asyncExecutePromiseGeneratorProgram=function(b){return $jscomp.asyncExecutePromiseGenerator(new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(b)))};
$jscomp.iteratorFromArray=function(b,k){$jscomp.initSymbolIterator();b instanceof String&&(b+="");var c=0,a={next:function(){if(c<b.length){var f=c++;return{value:k(f,b[f]),done:!1}}a.next=function(){return{done:!0,value:void 0}};return a.next()}};a[Symbol.iterator]=function(){return a};return a};$jscomp.polyfill("Array.prototype.keys",function(b){return b?b:function(){return $jscomp.iteratorFromArray(this,function(b){return b})}},"es6","es3");
$jscomp.polyfill("Array.prototype.fill",function(b){return b?b:function(b,c,a){var f=this.length||0;0>c&&(c=Math.max(0,f+c));if(null==a||a>f)a=f;a=Number(a);0>a&&(a=Math.max(0,f+a));for(c=Number(c||0);c<a;c++)this[c]=b;return this}},"es6","es3");$jscomp.polyfill("Object.is",function(b){return b?b:function(b,c){return b===c?0!==b||1/b===1/c:b!==b&&c!==c}},"es6","es3");
$jscomp.polyfill("Array.prototype.includes",function(b){return b?b:function(b,c){var a=this;a instanceof String&&(a=String(a));var f=a.length;c=c||0;for(0>c&&(c=Math.max(c+f,0));c<f;c++){var d=a[c];if(d===b||Object.is(d,b))return!0}return!1}},"es7","es3");
$jscomp.checkStringArgs=function(b,k,c){if(null==b)throw new TypeError("The 'this' value for String.prototype."+c+" must not be null or undefined");if(k instanceof RegExp)throw new TypeError("First argument to String.prototype."+c+" must not be a regular expression");return b+""};$jscomp.polyfill("String.prototype.includes",function(b){return b?b:function(b,c){return-1!==$jscomp.checkStringArgs(this,b,"includes").indexOf(b,c||0)}},"es6","es3");
$jscomp.owns=function(b,k){return Object.prototype.hasOwnProperty.call(b,k)};$jscomp.assign="function"==typeof Object.assign?Object.assign:function(b,k){for(var c=1;c<arguments.length;c++){var a=arguments[c];if(a)for(var f in a)$jscomp.owns(a,f)&&(b[f]=a[f])}return b};$jscomp.polyfill("Object.assign",function(b){return b||$jscomp.assign},"es6","es3");$jscomp.polyfill("Number.MAX_SAFE_INTEGER",function(){return 9007199254740991},"es6","es3");
$jscomp.polyfill("Object.values",function(b){return b?b:function(b){var c=[],a;for(a in b)$jscomp.owns(b,a)&&c.push(b[a]);return c}},"es8","es3");$jscomp.polyfill("Math.log2",function(b){return b?b:function(b){return Math.log(b)/Math.LN2}},"es6","es3");
$jscomp.polyfill("Array.from",function(b){return b?b:function(b,c,a){c=null!=c?c:function(a){return a};var f=[],d="undefined"!=typeof Symbol&&Symbol.iterator&&b[Symbol.iterator];if("function"==typeof d){b=d.call(b);for(var e=0;!(d=b.next()).done;)f.push(c.call(a,d.value,e++))}else for(d=b.length,e=0;e<d;e++)f.push(c.call(a,b[e],e));return f}},"es6","es3");
$jscomp.findInternal=function(b,k,c){b instanceof String&&(b=String(b));for(var a=b.length,f=0;f<a;f++){var d=b[f];if(k.call(c,d,f,b))return{i:f,v:d}}return{i:-1,v:void 0}};$jscomp.polyfill("Array.prototype.find",function(b){return b?b:function(b,c){return $jscomp.findInternal(this,b,c).v}},"es6","es3");
$jscomp.polyfill("String.prototype.startsWith",function(b){return b?b:function(b,c){var a=$jscomp.checkStringArgs(this,b,"startsWith");b+="";var f=a.length,d=b.length;c=Math.max(0,Math.min(c|0,a.length));for(var e=0;e<d&&c<f;)if(a[c++]!=b[e++])return!1;return e>=d}},"es6","es3");$jscomp.polyfill("Math.sign",function(b){return b?b:function(b){b=Number(b);return 0===b||isNaN(b)?b:0<b?1:-1}},"es6","es3");
(function(b,k){b.Logger=function(){};b.Logger.Severity={Debug:0,Info:1,Client:2,Warning:3,Warn:3,Error:4};Object.freeze(b.Logger.Severity);b.Logger.ConsoleThresh=b.Logger.Severity.Info;b.Logger._MaxIncidents=1E3;b.Logger._IncidentList=[];b.Logger._NumErrors=0;b.Logger._NumWarnings=0;b.Logger.Report=function(c,a,f,d){var e=b.Logger.Severity;c=c||"";a>=e.Debug&&a<=e.Error||(a=e.Error);for(;b.Logger._IncidentList.length>=b.Logger._MaxIncidents;)b.Logger._IncidentList.shift();b.Logger._IncidentList.push({msg:c,
severity:a});a===e.Error&&b.Logger._NumErrors++;a===e.Warn&&b.Logger._NumWarnings++;a>=b.Logger.ConsoleThresh&&window.console&&(a=(a=a<=e.Debug?window.console.debug:a==e.Info||a==e.Client?window.console.info:a==e.Warn?window.console.warn:window.console.error)||window.console.log)&&a(c);if(d)throw Error(c);!0===f&&alert(c)};b.Logger.Clear=function(){b.Logger._IncidentList=[];b.Logger._NumErrors=0;b.Logger._NumWarnings=0};b.Logger.NumIncidents=function(){return b.Logger._IncidentList.length};b.Logger.NumErrors=
function(){return b.Logger._NumErrors};b.Logger.NumWarnings=function(){return b.Logger._NumWarnings};b.Logger.LastIncident=function(){var c=b.Logger._IncidentList.length;return 0<c?b.Logger._IncidentList[c-1]:null};b.Logger.LastErrorMsg=function(){for(var c=b.Logger._IncidentList.length-1;0<=c;c--){var a=b.Logger._IncidentList[c];if(a.severity===b.Logger.Severity.Error)return a.msg}return""};b.Logger.LastWarningMsg=function(){for(var c=b.Logger._IncidentList.length-1;0<=c;c--){var a=b.Logger._IncidentList[c];
if(a.severity===b.Logger.Severity.Warn)return a.msg}return""};b.Logger.LastDebugMsg=function(){for(var c=b.Logger._IncidentList.length-1;0<=c;c--){var a=b.Logger._IncidentList[c];if(a.severity===b.Logger.Severity.Debug)return a.msg}return""};b.Logger.LastInfoMsg=function(){for(var c=b.Logger._IncidentList.length-1;0<=c;c--){var a=b.Logger._IncidentList[c];if(a.severity===b.Logger.Severity.Info)return a.msg}return""}})(window.BigLime=window.BigLime||{});
(function(b,k){b.Loader3D=function(){this.vol=null;this.done=this.cancelled=!1;this.loadProgressCb=this.loadCompleteCb=this.rgbaBuf=null;this.warnings=this.errors=""};b.Loader3D.prototype.cancelLoading=function(){this.cancelled=!0};b.Loader3D.prototype._copyImagesToTexture=function(c){var a="";this.vol instanceof b.VolumeT3?this._copyImagesToTexture3D(c):this.vol instanceof b.VolumeT2?this._copyImagesToTexture2D(c):a="Loader3D: Invalid volume type.";return a};b.Loader3D.prototype._copyImagesToTexture3D=
function(c){var a=this.vol,f=a.context.gl,d=a.dims[0],e=a.dims[1],h=8==a.bpp?f.RED:f.RG,g=f.createBuffer();f.bindBuffer(f.PIXEL_UNPACK_BUFFER,g);for(var l=c.startIndex;l<c.endIndex;l++){var m=c.imgBuffers[l-c.startIndex];m.buffer&&(m=m.buffer);16==a.bpp&&a.bigEndian&&b.Loader3D._SwapByteOrder(m);f.bufferData(f.PIXEL_UNPACK_BUFFER,m,f.DYNAMIC_COPY);a.texture.bind();f.texSubImage3D(f.TEXTURE_3D,0,0,0,l,d,e,1,h,f.UNSIGNED_BYTE,0);a.histogram.addImage(m,a.bpp/8,!1)}f.bindBuffer(f.PIXEL_UNPACK_BUFFER,
null);f.deleteBuffer(g)};b.Loader3D.prototype._copyImagesToTexture2D=function(b){var a=this.vol,f=a.dims[0],d=a.dims[1],e=a.txInfo;this.rgbaBuf&&this.rgbaBuf.length==4*f*d||(this.rgbaBuf=new Uint8Array(4*f*d));16==a.bpp?this._populateRgbaBuffer_From16bitImages(b):this._populateRgbaBuffer_From8bitImages(b);var c=b.startIndex/e.imgsPerTile;b=Math.floor(c/(e.NTx*e.NTy));var g=c-b*e.tilesPerTexture;c=Math.floor(g/e.NTx);e=g-c*e.NTx;g=a.context.gl;a.textures[b].bind();g.texSubImage2D(g.TEXTURE_2D,0,e*
f,c*d,f,d,g.RGBA,g.UNSIGNED_BYTE,this.rgbaBuf)};b.Loader3D.prototype._populateRgbaBuffer_From16bitImages=function(b){var a=this.vol,f=a.dims[0],d=a.dims[1],e=f*d,c=b.endIndex-b.startIndex,g,l=[];for(g=0;g<c;g++)l.push(b.imgBuffers[g].buffer||b.imgBuffers[g]);b=(d-1)*f;for(g=0;g<c;g++){for(var m=new Uint16Array(l[g]),n=0;n<d;n++){var p=n*f;m[p]=m[p+f-1]=0}for(n=0;n<f;n++)m[n]=m[b+n]=0}f=[];f.push(0<c?new Uint8Array(l[0]):null);f.push(1<c?new Uint8Array(l[1]):null);d=0;b=2*e;for(g=0;g<b;g+=2)for(e=
0;2>e;e++)f[e]?(this.rgbaBuf[d++]=a.bigEndian?f[e][g+1]:f[e][g],this.rgbaBuf[d++]=a.bigEndian?f[e][g]:f[e][g+1]):(this.rgbaBuf[d++]=0,this.rgbaBuf[d++]=0);for(g=0;2>g;g++)g<c&&a.histogram.addImage(l[g],a.bpp/8,a.bigEndian)};b.Loader3D.prototype._populateRgbaBuffer_From8bitImages=function(b){var a=this.vol,f=a.dims[0],d=a.dims[1],e=f*d,c=b.imgBuffers.length,g,l=[];for(g=0;g<c;g++)l.push(b.imgBuffers[g].buffer||b.imgBuffers[g]);b=(d-1)*f;for(g=0;g<c;g++){for(var m=new Uint8Array(l[g]),n=0;n<d;n++){var p=
n*f;m[p]=m[p+f-1]=0}for(n=0;n<f;n++)m[n]=m[b+n]=0}f=[];f.push(0<c?new Uint8Array(l[0]):null);f.push(1<c?new Uint8Array(l[1]):null);f.push(2<c?new Uint8Array(l[2]):null);f.push(3<c?new Uint8Array(l[3]):null);for(g=d=0;g<e;g++)for(b=0;4>b;b++)this.rgbaBuf[d++]=f[b]?f[b][g]:0;for(g=0;4>g;g++)g<c&&a.histogram.addImage(l[g],a.bpp/8,a.bigEndian)};b.Loader3D._SwapByteOrder=function(b){b=new Uint8Array(b.buffer||b);for(var a=b.length,f=0;f<a;f+=2){var d=b[f];b[f]=b[f+1];b[f+1]=d}}})(window.BigLime=window.BigLime||
{});
(function(b,k){var c=glMatrix.vec2;b.Interactor=function(a,f,d){var e=this;this.eventSources=Array.isArray(a)?a:[a];this.name=f||"";this.eventTypes=d||{btns:0,shift:!1,ctrl:!1,alt:!1};this.isTouchDevice=b.Utils.isTouchDevice();this.enabled=!0;this.pinching=this.active=!1;this.currNumTouches=0;this.currentEventSource=null;this.prevPoint=c.create();this.currPoint=c.create();this.startPoint=c.create();this.deltaPrev=c.create();this.deltaStart=c.create();this.prevPinch={sep:1,ctr:c.create(),ang:0};this.currPinch=
{sep:1,ctr:c.create(),ang:0};this.startPinch={sep:1,ctr:c.create(),ang:0};this.deltaPrevPinch={sep:0,ctr:c.create(),ang:0};this.deltaStartPinch={sep:0,ctr:c.create(),ang:0};this.isTouchDevice?(this.touchStartListener=this._onStartBase.bind(this),this.touchMoveListener=this._onMoveBase.bind(this),this.touchEndListener=this._onEndBase.bind(this),this.eventSources.forEach(function(a){return a.addEventListener("touchstart",e.touchStartListener)}),this.eventSources.forEach(function(a){return a.addEventListener("touchmove",
e.touchMoveListener)}),this.eventSources.forEach(function(a){return a.addEventListener("touchend",e.touchEndListener)})):(this.mouseDownListener=this._onStartBase.bind(this),this.mouseMoveListener=this._onMoveBase.bind(this),this.mouseUpListener=this._onEndBase.bind(this),this.eventSources.forEach(function(a){return a.addEventListener("mousedown",e.mouseDownListener)}),document.addEventListener("mousemove",this.mouseMoveListener),document.addEventListener("mouseup",this.mouseUpListener))};b.Interactor.prototype.stopListening=
function(){var a=this;this.touchStartListener&&this.eventSources.forEach(function(b){return b.removeEventListener("touchstart",a.touchStartListener)});this.touchMoveListener&&this.eventSources.forEach(function(b){return b.removeEventListener("touchmove",a.touchMoveListener)});this.touchEndListener&&this.eventSources.forEach(function(b){return b.removeEventListener("touchend",a.touchEndListener)});this.mouseDownListener&&this.eventSources.forEach(function(b){return b.removeEventListener("mousedown",
a.mouseDownListener)});this.mouseMoveListener&&document.removeEventListener("mousemove",this.mouseMoveListener);this.mouseUpListener&&document.removeEventListener("mouseup",this.mouseUpListener)};b.Interactor.prototype._onStartBase=function(a){this.enabled&&!this.active&&b.Interactor.MouseEventMatches(a,this.eventTypes)&&(this.currentEventSource=a.currentTarget,this._updateStateFromEvent(a),1<=this.currNumTouches?(this.active=!0,c.copy(this.startPoint,this.currPoint),c.copy(this.prevPoint,this.currPoint),
c.set(this.deltaPrev,0,0),c.set(this.deltaStart,0,0),2<=this.currNumTouches&&(this.pinching=!0,b.Interactor._copyPinchInfo(this.startPinch,this.currPinch),b.Interactor._copyPinchInfo(this.prevPinch,this.currPinch),b.Interactor._zeroPinchInfo(this.deltaPrevPinch),b.Interactor._zeroPinchInfo(this.deltaStartPinch)),this._onStart?this._onStart(a):this.trigger("start",{origEvent:a})):this.currentEventSource=null,a.preventDefault())};b.Interactor.prototype._onMoveBase=function(a){this.enabled&&this.active&&
this.currentEventSource&&(this._updateStateFromEvent(a),this._onMove?this._onMove(a):this.trigger("move",{origEvent:a}),c.copy(this.prevPoint,this.currPoint),2<=this.currNumTouches&&b.Interactor._copyPinchInfo(this.prevPinch,this.currPinch),a.preventDefault())};b.Interactor.prototype._onEndBase=function(a){this.enabled&&this.active&&this.currentEventSource&&(this._updateStateFromEvent(a),this._onEnd?this._onEnd(a):this.trigger("end",{origEvent:a}),this.pinching=this.active=!1,this.currentEventSource=
null,a.preventDefault())};b.Interactor.MouseEventMatches=function(a,b){if(!b)return!1;Array.isArray(b)||(b=[b]);b=$jscomp.makeIterator(b);for(var d=b.next();!d.done;d=b.next())if(d=d.value,!d.btns||(Array.isArray(d.btns)?d.btns:[d.btns]).some(function(b){return b===a.button}))if(alert("mask: "+d.shift.toString()+" "+d.ctrl.toString()+" "+d.alt.toString()),alert("evnt: "+a.shiftKey.toString()+" "+a.ctrlKey.toString()+" "+a.altKey.toString()+" "+a.metaKey.toString()),!(d.shift!==k&&d.shift!==a.shiftKey||
d.ctrl!==k&&d.ctrl!==(a.ctrlKey||a.metaKey)||d.alt!==k&&d.alt!==a.altKey))return!0;return!1};b.Interactor.prototype._updateStateFromEvent=function(a){a=b.Interactor._getEventCoordinates(a);if(null===a[0]||null===a[1])this.currNumTouches=0;else{this.currNumTouches=1;var f=this.currentEventSource.getBoundingClientRect();c.set(this.currPoint,a[0]-f.left,a[1]-f.top);c.subtract(this.deltaPrev,this.currPoint,this.prevPoint);c.subtract(this.deltaStart,this.currPoint,this.startPoint);if(null!==a[2]&&null!==
a[3]){this.currNumTouches=2;f=a[0];var d=a[1],e=a[2];a=a[3];c.set(this.currPinch.ctr,(f+e)/2,(d+a)/2);this.currPinch.sep=Math.sqrt((e-f)*(e-f)+(a-d)*(a-d));this.currPinch.ang=Math.atan2(d-a,e-f);c.subtract(this.deltaPrevPinch.ctr,this.currPinch.ctr,this.prevPinch.ctr);c.subtract(this.deltaStartPinch.ctr,this.currPinch.ctr,this.startPinch.ctr);this.deltaPrevPinch.sep=this.currPinch.sep-this.prevPinch.sep;this.deltaStartPinch.sep=this.currPinch.sep-this.startPinch.sep;this.deltaPrevPinch.ang=this.currPinch.ang-
this.prevPinch.ang;this.deltaStartPinch.ang=this.currPinch.ang-this.startPinch.ang}}};b.Interactor._getEventCoordinates=function(a){var b=a.clientX,d=a.clientY,e=null,c=null;("undefined"==typeof b||"undefined"==typeof d||null===b||null===d)&&(a=a.targetTouches&&a.targetTouches.length?a:a.originalEvent)&&a.targetTouches&&a.targetTouches.length&&(b=a.targetTouches[0].clientX,d=a.targetTouches[0].clientY,1<a.targetTouches.length&&(e=a.targetTouches[1].clientX,c=a.targetTouches[1].clientY));if("undefined"==
typeof b||"undefined"==typeof d)b=d=e=c=null;return[b,d,e,c]};b.Interactor._copyPinchInfo=function(a,b){a.sep=b.sep;a.ang=b.ang;c.copy(a.ctr,b.ctr)};b.Interactor._zeroPinchInfo=function(a){a.sep=0;a.ang=0;c.set(a.ctr,0,0)};b.Interactor.prototype.addEventListener=function(a,f){b.Notifier.prototype.addEventListener.call(this,a,f)};b.Interactor.prototype.removeEventListener=function(a,f){b.Notifier.prototype.removeEventListener.call(this,a,f)};b.Interactor.prototype.trigger=function(a,f){b.Notifier.prototype.trigger.call(this,
a,f)}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=glMatrix.vec3;b.Mesh=function(a,f,d,e,c){this.vertices=a||[];this.material=d||new b.Material;this.normals=f||b.Mesh.calcNormals(a,this.material.flatShade);this.name=e||"";this.layer=c||0;this.visible=!0;this.updateVertexBuffers()};b.Mesh.prototype.updateVertexBuffers=function(){var a,b=this.vertices.length;this.vBuffer=new Float32Array(3*b);for(a=0;a<b;a++){var d=3*a;var e=this.vertices[a];this.vBuffer[d]=e[0];this.vBuffer[d+1]=e[1];this.vBuffer[d+2]=e[2]}this.nBuffer=new Float32Array(3*
b);for(a=0;a<b;a++)d=3*a,e=this.normals[a],this.nBuffer[d]=e[0],this.nBuffer[d+1]=e[1],this.nBuffer[d+2]=e[2];this.updateAttributeBuffers()};b.Mesh.prototype.updateAttributeBuffers=function(){var a,b=this.vertices.length;this.cBuffer=new Float32Array(4*b);var d=this.material.color.slice();for(a=0;4>a;a++)d[a]/=255;for(a=0;a<b;a++){var e=4*a;this.cBuffer[e]=d[0];this.cBuffer[e+1]=d[1];this.cBuffer[e+2]=d[2];this.cBuffer[e+3]=d[3]}this.mBuffer=new Float32Array(4*b);d=Math.max(0,Math.min(1,this.material.ambient));
var c=Math.max(0,Math.min(1,this.material.diffuse)),g=Math.max(0,Math.min(1,this.material.specStrength)),l=Math.max(0,Math.min(1,this.material.specPower/255));for(a=0;a<b;a++)e=4*a,this.mBuffer[e]=d,this.mBuffer[e+1]=c,this.mBuffer[e+2]=g,this.mBuffer[e+3]=l};b.Mesh.calcNormals=function(a,f,d){var e=a?a.length:0,h=e/3,g=[],l=c.create(),m=c.create(),n;for(n=0;n<h;n++){var p=3*n;c.subtract(l,a[p+1],a[p]);c.subtract(m,a[p+2],a[p]);p=c.create();c.cross(p,l,m);c.normalize(p,p);.99>c.squaredLength(p)&&
b.Logger.Report("Invalid triangle supplied to Mesh.calcNormals.",b.Logger.Severity.Warning);g.push(p,p,p)}if(!f){f={};for(n=0;n<e;n++){var u=a[n];u=[u[0].toFixed(5),u[1].toFixed(5),u[2].toFixed(5)];f[u]===k?f[u]=[n]:f[u].push(n)}a=d||0===d?d:.5;for(u in f)for(d=f[u].slice();1<d.length;){e=[d[0]];d.splice(0,1);h=g[e[0]];for(n=0;n<d.length;n++)c.dot(h,g[d[n]])>=a&&(e.push(d[n]),d.splice(n,1),n--);if(1<e.length){h=[];for(n=0;n<e.length;n++){m=g[e[n]];p=!1;for(l=0;l<h.length;l++)if(.9999<c.dot(m,h[l])){p=
!0;break}p||h.push(m)}l=c.create();for(n=0;n<h.length;n++)c.add(l,l,h[n]);c.normalize(l,l);if(.5<c.squaredLength(l))for(n=0;n<e.length;n++)g[e[n]]=l}}}return g};b.Mesh.prototype.setMaterial=function(a){a||(a=[255,0,0]);a instanceof b.Color&&(a=a.toArray());$.isArray(a)&&(a=new b.Material(a,!1,.4,.25,0,0));this.material=a.clone();this.updateAttributeBuffers()};b.Mesh.prototype.numVertices=function(){return this.vertices.length};b.Mesh.Box=function(a,f,d,e,h,g){d||(d=[[1,0,0],[0,1,0],[0,0,1]]);for(var l=
[c.create(),c.create(),c.create()],m=0;3>m;m++)c.scale(l[m],d[m],.5*f[m]/c.length(d[m]));f=c.create();d=c.create();m=c.create();var n=c.create(),p=c.create(),k=c.create(),q=c.create(),t=c.create();c.scaleAndAdd(f,a,l[0],-1);c.scaleAndAdd(f,f,l[1],1);c.scaleAndAdd(f,f,l[2],-1);c.scaleAndAdd(d,a,l[0],1);c.scaleAndAdd(d,d,l[1],1);c.scaleAndAdd(d,d,l[2],-1);c.scaleAndAdd(m,a,l[0],1);c.scaleAndAdd(m,m,l[1],-1);c.scaleAndAdd(m,m,l[2],-1);c.scaleAndAdd(n,a,l[0],-1);c.scaleAndAdd(n,n,l[1],-1);c.scaleAndAdd(n,
n,l[2],-1);c.scaleAndAdd(p,a,l[0],-1);c.scaleAndAdd(p,p,l[1],1);c.scaleAndAdd(p,p,l[2],1);c.scaleAndAdd(k,a,l[0],1);c.scaleAndAdd(k,k,l[1],1);c.scaleAndAdd(k,k,l[2],1);c.scaleAndAdd(q,a,l[0],1);c.scaleAndAdd(q,q,l[1],-1);c.scaleAndAdd(q,q,l[2],1);c.scaleAndAdd(t,a,l[0],-1);c.scaleAndAdd(t,t,l[1],-1);c.scaleAndAdd(t,t,l[2],1);return new b.Mesh([f,d,m,f,m,n,k,p,t,k,t,q,p,f,t,f,n,t,d,q,m,d,k,q,q,t,n,q,n,m,p,k,f,k,d,f],null,e,h,g)};b.Mesh.Cylinder=function(a,f,d,e,h,g,l,m){g=g||new b.Material;e=c.clone(e);
c.normalize(e,e);var n=.5<Math.abs(e[0])?c.fromValues(-e[2],0,e[0]):.5<Math.abs(e[1])?c.fromValues(-e[1],e[0],0):c.fromValues(0,-e[2],e[1]);c.normalize(n,n);var p=c.create();c.cross(p,e,n);var k=[],q=[],t=[];h=Math.max(3,h||24);var z=2*Math.PI/h,v=c.create(),r=c.create();c.scaleAndAdd(v,a,e,d/2);c.scaleAndAdd(r,a,e,-d/2);d=[];e=[];for(a=0;a<h;a++){var y=a*z,J=Math.cos(y);y=Math.sin(y);var I=c.clone(v);c.scaleAndAdd(I,I,n,f*J);c.scaleAndAdd(I,I,p,f*y);d.push(I);I=c.clone(r);c.scaleAndAdd(I,I,n,f*J);
c.scaleAndAdd(I,I,p,f*y);e.push(I)}for(a=0;a<h;a++)f=(a+1)%h,k.push(d[a],e[f],d[f]),k.push(d[a],e[a],e[f]),t.push(v,d[a],d[f]),t.push(r,e[f],e[a]);h=b.Mesh.calcNormals(k,g.flatShade);v=b.Mesh.calcNormals(q,!0);r=b.Mesh.calcNormals(t,!0);k=k.concat(q).concat(t);q=h.concat(v).concat(r);return new b.Mesh(k,q,g,l,m)};b.Mesh.Cone=function(a,f,d,e,h,g,l,m,n){a=c.clone(a);e=c.clone(e);c.normalize(e,e);l=l||new b.Material;var p=.5<Math.abs(e[0])?c.fromValues(-e[2],0,e[0]):.5<Math.abs(e[1])?c.fromValues(-e[1],
e[0],0):c.fromValues(0,-e[2],e[1]);c.normalize(p,p);var k=c.create();c.cross(k,e,p);var q=[],t=[];h=Math.max(3,h);g=Math.max(1,g);var z=2*Math.PI/h;d/=g;for(var v,r=0;r<g;r++){var y=c.create(),J=c.create();c.scaleAndAdd(y,a,e,-r*d);c.scaleAndAdd(J,a,e,-(r+1)*d);var I=0===r?.01:r*f/g,Q=(r+1)*f/g,L=[],A=[];for(v=0;v<h;v++){var K=v*z,V=Math.cos(K);K=Math.sin(K);var N=c.clone(y);c.scaleAndAdd(N,N,p,I*V);c.scaleAndAdd(N,N,k,I*K);L.push(N);N=c.clone(J);c.scaleAndAdd(N,N,p,Q*V);c.scaleAndAdd(N,N,k,Q*K);
A.push(N)}for(v=0;v<h;v++)y=(v+1)%h,q.push(L[v],A[y],L[y]),q.push(L[v],A[v],A[y]),r==g-1&&t.push(J,A[y],A[v])}a=b.Mesh.calcNormals(q,l.flatShade);f=b.Mesh.calcNormals(t,!0);q=q.concat(t);t=a.concat(f);return new b.Mesh(q,t,l,m,n)};b.Mesh.Sphere=function(a,f,d,e,c,g,l){var h=[],n;d=Math.max(3,d);e=Math.max(3,e);var p=2*Math.PI/d,k=Math.PI/(e-1);for(n=0;n<e;n++){var q=n*k;var t=a[2]+f*Math.cos(q),z=f*Math.sin(q);for(q=0;q<d;q++){var v=q*p;h.push([z*Math.cos(v)+a[0],z*Math.sin(v)+a[1],t])}}f=[];for(n=
0;n<e-1;n++)if(p=n*d,k=(n+1)*d,0===n)for(q=0;q<d;q++)a=(q+1)%d,f.push(h[q+p],h[q+k],h[a+k]);else if(n===e-2)for(q=0;q<d;q++)a=(q+1)%d,f.push(h[q+p],h[q+k],h[a+p]);else for(q=0;q<d;q++)a=(q+1)%d,f.push(h[q+p],h[q+k],h[a+p]),f.push(h[a+p],h[q+k],h[a+k]);return new b.Mesh(f,null,c,g,l)}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=b.Logger.Severity;b.AttributeBuffer=function(a,f,d,e){e=e||{};d=d||3;var h=a.gl;this.context=a;this.attrDim=d;this.drawMode=e.drawMode||h.STATIC_DRAW;this.dataType=e.dataType||h.FLOAT;this.normalizeValues=!!e.normalizeValues;this.bytesPerVertex=d*this.context.sizeOf(this.dataType);this.numBytes=0;this.glBuffer=null;1!==d&&2!==d&&3!==d&&4!==d?b.Logger.Report("AttributeBuffer.ctor: Invalid attribute dimension.",c.Error):(a=this._coerceData(f))?(this.numBytes=a.buffer?a.buffer.byteLength:
a.byteLength,this.glBuffer=h.createBuffer(),h.bindBuffer(h.ARRAY_BUFFER,this.glBuffer),h.bufferData(h.ARRAY_BUFFER,a,this.drawMode),h.bindBuffer(h.ARRAY_BUFFER,null)):b.Logger.Report("AttributeBuffer.ctor: Invalid data array.",c.Error)};b.AttributeBuffer.prototype.destroy=function(){if(this.context){if(this.glBuffer){var a=this.context.gl;a.bindBuffer(a.ARRAY_BUFFER,this.glBuffer);a.bufferData(a.ARRAY_BUFFER,1,a.STATIC_DRAW);a.bindBuffer(a.ARRAY_BUFFER,null);a.deleteBuffer(this.glBuffer);this.glBuffer=
null}this.context=null}};b.AttributeBuffer.prototype._coerceData=function(a){var b=this.context.gl;try{if(this.dataType===b.FLOAT)return a instanceof Float32Array?a:new Float32Array(a);if(this.dataType===b.UNSIGNED_SHORT)return a instanceof Uint16Array?a:new Uint16Array(a);if(this.dataType===b.UNSIGNED_BYTE)return a instanceof Uint8Array?a:new Uint8Array(a);if(this.dataType===b.SHORT)return a instanceof Int16Array?a:new Int16Array(a);if(this.dataType===b.BYTE)return a instanceof Int8Array?a:new Int8Array(a);
if(1<this.context.glVersion&&this.dataType===b.HALF_FLOAT)return a}catch(d){}return null};b.AttributeBuffer.prototype.setData=function(a){if(a=this._coerceData(a)){this.numBytes=a.buffer?a.buffer.byteLength:a.byteLength;var f=this.context.gl;f.bindBuffer(f.ARRAY_BUFFER,this.glBuffer);f.bufferData(f.ARRAY_BUFFER,a,this.drawMode);f.bindBuffer(f.ARRAY_BUFFER,null)}else b.Logger.Report("AttributeBuffer.setData: Invalid data array.",c.Error)};b.AttributeBuffer.prototype.subData=function(a,f){if(a=this._coerceData(a)){var d=
this.context.gl;d.bindBuffer(d.ARRAY_BUFFER,this.glBuffer);d.bufferSubData(d.ARRAY_BUFFER,f||0,a);d.bindBuffer(d.ARRAY_BUFFER,null)}else b.Logger.Report("AttributeBuffer.subData: Invalid data array.",c.Error)}})(window.BigLime=window.BigLime||{});(function(b,k){b.Interp3D={NN:1,BiLinear:2,TriLinear:3};Object.freeze(b.Interp3D);b.RenderType={MIP:1,VR:2,XRAY:3};Object.freeze(b.RenderType)})(window.BigLime=window.BigLime||{});
(function(b,k){b.DebugUtils=function(){function b(a){if(null===m){m={};n={};for(var b in a)"number"==typeof a[b]&&(m[a[b]]=b,n[b]=a[b])}}function a(){if(null===m)throw"WebGLDebugUtils.init(ctx) not called";}function f(b){a();var d=m[b];return d!==k?"gl."+d:"/*UNKNOWN WebGL ENUM*/ 0x"+b.toString(16)}function d(a,b,d,e){a=l[a];if(a!==k&&(a=a[b],a!==k&&a[d])){if("object"===typeof a[d]&&a[d].enumBitwiseOr!==k){b=a[d].enumBitwiseOr;d=0;a=[];for(var c=0;c<b.length;++c){var h=n[b[c]];0!==(e&h)&&(d|=h,a.push(f(h)))}return d===
e?a.join(" | "):f(e)}return f(e)}return null===e?"null":e===k?"undefined":e.toString()}function e(a,b,d){a.__defineGetter__(d,function(){return b[d]});a.__defineSetter__(d,function(a){b[d]=a})}function h(a,c,g,l){function p(a,b){return function(){g&&g(b,arguments);var d=a[b].apply(a,arguments),e=l.getError();0!==e&&(m[e]=!0,c(e,b,arguments));return d}}l=l||a;b(a);c=c||function(a,b,e){for(var c="",h=e.length,g=0;g<h;++g)c+=(0===g?"":", ")+d(b,h,g,e[g]);a="WebGL error "+f(a)+" in "+b+"("+c+")";window.console&&
window.console.error?window.console.error(a):window.console&&window.console.log&&window.console.log(a)};var m={},n={},k;for(k in a)if("function"==typeof a[k])if("getExtension"!=k)n[k]=p(a,k);else{var q=p(a,k);n[k]=function(){var b=q.apply(a,arguments);return b?h(b,c,g,l):null}}else e(n,a,k);n.getError=function(){for(var b in m)if(m.hasOwnProperty(b)&&m[b])return m[b]=!1,b;return a.NO_ERROR};return n}function g(a){var b=!!a.createTransformFeedback;b&&a.bindVertexArray(null);var d=a.getParameter(a.MAX_VERTEX_ATTRIBS),
e=a.createBuffer(),c;a.bindBuffer(a.ARRAY_BUFFER,e);for(c=0;c<d;++c)a.disableVertexAttribArray(c),a.vertexAttribPointer(c,4,a.FLOAT,!1,0,0),a.vertexAttrib1f(c,0),b&&a.vertexAttribDivisor(c,0);a.deleteBuffer(e);d=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);for(c=0;c<d;++c)a.activeTexture(a.TEXTURE0+c),a.bindTexture(a.TEXTURE_CUBE_MAP,null),a.bindTexture(a.TEXTURE_2D,null),b&&(a.bindTexture(a.TEXTURE_2D_ARRAY,null),a.bindTexture(a.TEXTURE_3D,null),a.bindSampler(c,null));a.activeTexture(a.TEXTURE0);a.useProgram(null);
a.bindBuffer(a.ARRAY_BUFFER,null);a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,null);a.bindFramebuffer(a.FRAMEBUFFER,null);a.bindRenderbuffer(a.RENDERBUFFER,null);a.disable(a.BLEND);a.disable(a.CULL_FACE);a.disable(a.DEPTH_TEST);a.disable(a.DITHER);a.disable(a.SCISSOR_TEST);a.blendColor(0,0,0,0);a.blendEquation(a.FUNC_ADD);a.blendFunc(a.ONE,a.ZERO);a.clearColor(0,0,0,0);a.clearDepth(1);a.clearStencil(-1);a.colorMask(!0,!0,!0,!0);a.cullFace(a.BACK);a.depthFunc(a.LESS);a.depthMask(!0);a.depthRange(0,1);a.frontFace(a.CCW);
a.hint(a.GENERATE_MIPMAP_HINT,a.DONT_CARE);a.lineWidth(1);a.pixelStorei(a.PACK_ALIGNMENT,4);a.pixelStorei(a.UNPACK_ALIGNMENT,4);a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,!1);a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1);a.UNPACK_COLORSPACE_CONVERSION_WEBGL&&a.pixelStorei(a.UNPACK_COLORSPACE_CONVERSION_WEBGL,a.BROWSER_DEFAULT_WEBGL);a.polygonOffset(0,0);a.sampleCoverage(1,!1);a.scissor(0,0,a.canvas.width,a.canvas.height);a.stencilFunc(a.ALWAYS,0,4294967295);a.stencilMask(4294967295);a.stencilOp(a.KEEP,
a.KEEP,a.KEEP);a.viewport(0,0,a.canvas.width,a.canvas.height);a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT|a.STENCIL_BUFFER_BIT);if(b){a.drawBuffers([a.BACK]);a.readBuffer(a.BACK);a.bindBuffer(a.COPY_READ_BUFFER,null);a.bindBuffer(a.COPY_WRITE_BUFFER,null);a.bindBuffer(a.PIXEL_PACK_BUFFER,null);a.bindBuffer(a.PIXEL_UNPACK_BUFFER,null);b=a.getParameter(a.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS);for(c=0;c<b;++c)a.bindBufferBase(a.TRANSFORM_FEEDBACK_BUFFER,c,null);b=a.getParameter(a.MAX_UNIFORM_BUFFER_BINDINGS);
for(c=0;c<b;++c)a.bindBufferBase(a.UNIFORM_BUFFER,c,null);a.disable(a.RASTERIZER_DISCARD);a.pixelStorei(a.UNPACK_IMAGE_HEIGHT,0);a.pixelStorei(a.UNPACK_SKIP_IMAGES,0);a.pixelStorei(a.UNPACK_ROW_LENGTH,0);a.pixelStorei(a.UNPACK_SKIP_ROWS,0);a.pixelStorei(a.UNPACK_SKIP_PIXELS,0);a.pixelStorei(a.PACK_ROW_LENGTH,0);a.pixelStorei(a.PACK_SKIP_ROWS,0);a.pixelStorei(a.PACK_SKIP_PIXELS,0);a.hint(a.FRAGMENT_SHADER_DERIVATIVE_HINT,a.DONT_CARE)}for(;a.getError(););}var l={enable:{1:{0:!0}},disable:{1:{0:!0}},
getParameter:{1:{0:!0}},drawArrays:{3:{0:!0}},drawElements:{4:{0:!0,2:!0}},createShader:{1:{0:!0}},getShaderParameter:{2:{1:!0}},getProgramParameter:{2:{1:!0}},getShaderPrecisionFormat:{2:{0:!0,1:!0}},getVertexAttrib:{2:{1:!0}},vertexAttribPointer:{6:{2:!0}},bindTexture:{2:{0:!0}},activeTexture:{1:{0:!0}},getTexParameter:{2:{0:!0,1:!0}},texParameterf:{3:{0:!0,1:!0}},texParameteri:{3:{0:!0,1:!0,2:!0}},copyTexImage2D:{8:{0:!0,2:!0}},copyTexSubImage2D:{8:{0:!0}},generateMipmap:{1:{0:!0}},bindBuffer:{2:{0:!0}},
getBufferParameter:{2:{0:!0,1:!0}},pixelStorei:{2:{0:!0,1:!0}},bindRenderbuffer:{2:{0:!0}},bindFramebuffer:{2:{0:!0}},checkFramebufferStatus:{1:{0:!0}},framebufferRenderbuffer:{4:{0:!0,1:!0,2:!0}},framebufferTexture2D:{5:{0:!0,1:!0,2:!0}},getFramebufferAttachmentParameter:{3:{0:!0,1:!0,2:!0}},getRenderbufferParameter:{2:{0:!0,1:!0}},renderbufferStorage:{4:{0:!0,1:!0}},clear:{1:{0:{enumBitwiseOr:["COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT"]}}},depthFunc:{1:{0:!0}},blendFunc:{2:{0:!0,
1:!0}},blendFuncSeparate:{4:{0:!0,1:!0,2:!0,3:!0}},blendEquation:{1:{0:!0}},blendEquationSeparate:{2:{0:!0,1:!0}},stencilFunc:{3:{0:!0}},stencilFuncSeparate:{4:{0:!0,1:!0}},stencilMaskSeparate:{2:{0:!0}},stencilOp:{3:{0:!0,1:!0,2:!0}},stencilOpSeparate:{4:{0:!0,1:!0,2:!0,3:!0}},cullFace:{1:{0:!0}},frontFace:{1:{0:!0}},drawArraysInstancedANGLE:{4:{0:!0}},drawElementsInstancedANGLE:{5:{0:!0,2:!0}},blendEquationEXT:{1:{0:!0}},bufferData:{3:{0:!0,2:!0},4:{0:!0,2:!0},5:{0:!0,2:!0}},bufferSubData:{3:{0:!0},
4:{0:!0},5:{0:!0}},copyBufferSubData:{5:{0:!0,1:!0}},getBufferSubData:{3:{0:!0},4:{0:!0},5:{0:!0}},blitFramebuffer:{10:{8:{enumBitwiseOr:["COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT"]},9:!0}},framebufferTextureLayer:{5:{0:!0,1:!0}},invalidateFramebuffer:{2:{0:!0}},invalidateSubFramebuffer:{6:{0:!0}},readBuffer:{1:{0:!0}},getInternalformatParameter:{3:{0:!0,1:!0,2:!0}},renderbufferStorageMultisample:{5:{0:!0,2:!0}},texStorage2D:{5:{0:!0,2:!0}},texStorage3D:{6:{0:!0,2:!0}},texImage2D:{9:{0:!0,
2:!0,6:!0,7:!0},6:{0:!0,2:!0,3:!0,4:!0},10:{0:!0,2:!0,6:!0,7:!0}},texImage3D:{10:{0:!0,2:!0,7:!0,8:!0},11:{0:!0,2:!0,7:!0,8:!0}},texSubImage2D:{9:{0:!0,6:!0,7:!0},7:{0:!0,4:!0,5:!0},10:{0:!0,6:!0,7:!0}},texSubImage3D:{11:{0:!0,8:!0,9:!0},12:{0:!0,8:!0,9:!0}},copyTexSubImage3D:{9:{0:!0}},compressedTexImage2D:{7:{0:!0,2:!0},8:{0:!0,2:!0},9:{0:!0,2:!0}},compressedTexImage3D:{8:{0:!0,2:!0},9:{0:!0,2:!0},10:{0:!0,2:!0}},compressedTexSubImage2D:{8:{0:!0,6:!0},9:{0:!0,6:!0},10:{0:!0,6:!0}},compressedTexSubImage3D:{10:{0:!0,
8:!0},11:{0:!0,8:!0},12:{0:!0,8:!0}},vertexAttribIPointer:{5:{2:!0}},drawArraysInstanced:{4:{0:!0}},drawElementsInstanced:{5:{0:!0,2:!0}},drawRangeElements:{6:{0:!0,4:!0}},readPixels:{7:{4:!0,5:!0},8:{4:!0,5:!0}},clearBufferfv:{3:{0:!0},4:{0:!0}},clearBufferiv:{3:{0:!0},4:{0:!0}},clearBufferuiv:{3:{0:!0},4:{0:!0}},clearBufferfi:{4:{0:!0}},beginQuery:{2:{0:!0}},endQuery:{1:{0:!0}},getQuery:{2:{0:!0,1:!0}},getQueryParameter:{2:{1:!0}},samplerParameteri:{3:{1:!0,2:!0}},samplerParameterf:{3:{1:!0}},getSamplerParameter:{2:{1:!0}},
fenceSync:{2:{0:!0,1:{enumBitwiseOr:[]}}},clientWaitSync:{3:{1:{enumBitwiseOr:["SYNC_FLUSH_COMMANDS_BIT"]}}},waitSync:{3:{1:{enumBitwiseOr:[]}}},getSyncParameter:{2:{1:!0}},bindTransformFeedback:{2:{0:!0}},beginTransformFeedback:{1:{0:!0}},transformFeedbackVaryings:{3:{2:!0}},bindBufferBase:{3:{0:!0}},bindBufferRange:{5:{0:!0}},getIndexedParameter:{2:{0:!0}},getActiveUniforms:{3:{2:!0}},getActiveUniformBlockParameter:{3:{2:!0}}},m=null,n=null;return{copyright:'/*\n** Copyright (c) 2012 The Khronos Group Inc.\n**\n** Permission is hereby granted, free of charge, to any person obtaining a\n** copy of this software and/or associated documentation files (the\n** "Materials"), to deal in the Materials without restriction, including\n** without limitation the rights to use, copy, modify, merge, publish,\n** distribute, sublicense, and/or sell copies of the Materials, and to\n** permit persons to whom the Materials are furnished to do so, subject to\n** the following conditions:\n**\n** The above copyright notice and this permission notice shall be included\n** in all copies or substantial portions of the Materials.\n**\n** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.\n*/',
init:b,mightBeEnum:function(b){a();return m[b]!==k},glEnumToString:f,glFunctionArgToString:d,glFunctionArgsToString:function(a,b){for(var c="",e=b.length,f=0;f<e;++f)c+=(0===f?"":", ")+d(a,e,f,b[f]);return c},makeDebugContext:h,makeLostContextSimulatingCanvas:function(a){function b(a){return"function"==typeof a?a:function(b){a.handleEvent(b)}}function d(){for(var a=Object.keys(P),b=0;b<a.length;++b)delete P[a[b]]}function c(){++N;A||V==N&&a.loseContext()}function f(a,b){var d=a[b];return function(){c();
if(!A)return d.apply(a,arguments)}}function h(a){return{statusMessage:a,preventDefault:function(){ha=!0}}}function l(a){for(var b in a)"function"==typeof a[b]?p[b]=f(a,b):e(p,a,b);var d;p.getError=function(){c();if(!A)for(;d=m.getError();)P[d]=!0;for(d in P)if(P[d])return delete P[d],d;return p.NO_ERROR};var h="createBuffer createFramebuffer createProgram createRenderbuffer createShader createTexture".split(" ");X&&h.push("createQuery","createSampler","fenceSync","createTransformFeedback","createVertexArray");
for(var g=0;g<h.length;++g)b=h[g],p[b]=function(b){return function(){c();if(A)return null;var d=b.apply(a,arguments);d.__webglDebugContextLostId__=L;K.push(d);return d}}(a[b]);h="getActiveAttrib getActiveUniform getBufferParameter getContextAttributes getAttachedShaders getFramebufferAttachmentParameter getParameter getProgramParameter getProgramInfoLog getRenderbufferParameter getShaderParameter getShaderInfoLog getShaderSource getTexParameter getUniform getUniformLocation getVertexAttrib".split(" ");
X&&h.push("getInternalformatParameter","getQuery","getQueryParameter","getSamplerParameter","getSyncParameter","getTransformFeedbackVarying","getIndexedParameter","getUniformIndices","getActiveUniforms","getActiveUniformBlockParameter","getActiveUniformBlockName");for(g=0;g<h.length;++g)b=h[g],p[b]=function(b){return function(){c();return A?null:b.apply(a,arguments)}}(p[b]);h="isBuffer isEnabled isFramebuffer isProgram isRenderbuffer isShader isTexture".split(" ");X&&h.push("isQuery","isSampler",
"isSync","isTransformFeedback","isVertexArray");for(g=0;g<h.length;++g)b=h[g],p[b]=function(b){return function(){c();return A?!1:b.apply(a,arguments)}}(p[b]);p.checkFramebufferStatus=function(b){return function(){c();return A?p.FRAMEBUFFER_UNSUPPORTED:b.apply(a,arguments)}}(p.checkFramebufferStatus);p.getAttribLocation=function(b){return function(){c();return A?-1:b.apply(a,arguments)}}(p.getAttribLocation);p.getVertexAttribOffset=function(b){return function(){c();return A?0:b.apply(a,arguments)}}(p.getVertexAttribOffset);
p.isContextLost=function(){return A};X&&(p.getFragDataLocation=function(b){return function(){c();return A?-1:b.apply(a,arguments)}}(p.getFragDataLocation),p.clientWaitSync=function(b){return function(){c();return A?p.WAIT_FAILED:b.apply(a,arguments)}}(p.clientWaitSync),p.getUniformBlockIndex=function(b){return function(){c();return A?p.INVALID_INDEX:b.apply(a,arguments)}}(p.getUniformBlockIndex));return p}var m,n=[],k=[],p={},L=1,A=!1,K=[],V=0,N=0,ha=!1,ea=0,X,P={};a.getContext=function(b){return function(){var d=
b.apply(a,arguments);if(d instanceof WebGLRenderingContext||window.WebGL2RenderingContext&&d instanceof WebGL2RenderingContext){if(d!=m){if(m)throw"got different context";X=window.WebGL2RenderingContext&&d instanceof WebGL2RenderingContext;m=d;p=l(m)}return p}return d}}(a.getContext);(function(a){var d=a.addEventListener;a.addEventListener=function(c,e,f){switch(c){case "webglcontextlost":n.push(b(e));break;case "webglcontextrestored":k.push(b(e));break;default:d.apply(a,arguments)}}})(a);a.loseContext=
function(){if(!A){A=!0;V=0;for(++L;m.getError(););d();P[m.CONTEXT_LOST_WEBGL]=!0;var b=h("context lost"),c=n.slice();setTimeout(function(){for(var d=0;d<c.length;++d)c[d](b);0<=ea&&setTimeout(function(){a.restoreContext()},ea)},0)}};a.restoreContext=function(){A&&k.length&&setTimeout(function(){if(!ha)throw"can not restore. webglcontestlost listener did not call event.preventDefault";for(var a=0;a<K.length;++a){var b=K[a];b instanceof WebGLBuffer?m.deleteBuffer(b):b instanceof WebGLFramebuffer?m.deleteFramebuffer(b):
b instanceof WebGLProgram?m.deleteProgram(b):b instanceof WebGLRenderbuffer?m.deleteRenderbuffer(b):b instanceof WebGLShader?m.deleteShader(b):b instanceof WebGLTexture?m.deleteTexture(b):X&&(b instanceof WebGLQuery?m.deleteQuery(b):b instanceof WebGLSampler?m.deleteSampler(b):b instanceof WebGLSync?m.deleteSync(b):b instanceof WebGLTransformFeedback?m.deleteTransformFeedback(b):b instanceof WebGLVertexArrayObject&&m.deleteVertexArray(b))}g(m);A=!1;N=0;ha=!1;a=k.slice();b=h("context restored");for(var d=
0;d<a.length;++d)a[d](b)},0)};a.loseContextInNCalls=function(a){if(A)throw"You can not ask a lost contet to be lost";V=N+a};a.getNumCalls=function(){return N};a.setRestoreTimeout=function(a){ea=a};return a},resetToInitialState:g}}()})(window.BigLime=window.BigLime||{});
(function(b,k){b.DicomLoader3D=function(){b.Loader3D.call(this);this.daikonImgs=[];this.fileList=[]};b.DicomLoader3D.prototype=Object.create(b.Loader3D.prototype);b.DicomLoader3D.prototype.constructor=b.DicomLoader3D;b.DicomLoader3D.prototype.loadImagesIntoVolume=function(b,a,f,d){this.fileList=[];Array.prototype.push.apply(this.fileList,b);this.vol=a;this.warnings=this.errors=null;this.done=!1;this.loadCompleteCb=f;this.loadProgressCb=d;this.fileList&&this.fileList.length?this.fileList.some(function(a){return!(a instanceof
FileSystemFileHandle)&&!(a instanceof File)})?(this.done=!0,this.errors="DicomLoader3D: Invalid item in file list.",this.loadCompleteCb&&this.loadCompleteCb(this)):(this.loadProgressCb&&this.loadProgressCb(0,this.fileList.length),this._readImageFile(0)):(this.done=!0,this.warnings="DicomLoader3D: No files were loaded, because the supplied file list was empty.",this.loadCompleteCb&&this.loadCompleteCb(this))};b.DicomLoader3D.prototype._readImageFile=function(b){var a=new FileReader;a.onload=function(){this._onImageFileRead(a,
null)}.bind(this);a.onerror=function(){this._onReadError(a,null)}.bind(this);a.imgIndex=b;b=this.fileList[b];b instanceof FileSystemFileHandle?b.getFile().then(function(b){a.readAsArrayBuffer(b)}).catch(function(b){this._onReadError(a)}.bind(this)):a.readAsArrayBuffer(b)};b.DicomLoader3D.prototype._onReadError=function(b){this.cancelled||this.done||(this.done=!0,this.errors="DicomLoader3D: Error reading file "+this.fileList[b.imgIndex].name,this.loadCompleteCb&&this.loadCompleteCb(this))};b.DicomLoader3D.prototype._onImageFileRead=
function(b){if(!this.done&&!this.cancelled){var a=b.result;b=b.imgIndex;try{var c=new DataView(a);if(!daikon.Parser.isMagicCookieFound(c)){this.done=!0;this.errors="DicomLoader3D: Invalid dicom file.";this.loadCompleteCb&&this.loadCompleteCb(this);return}var d=daikon.Series.parseImage(c);if(!d){this.done=!0;this.errors=daikon.Series.parserError;this.loadCompleteCb&&this.loadCompleteCb(this);return}this.daikonImgs.push(d)}catch(e){this.done=!0;this.errors="DicomLoader3D: Error parsing dicom file "+
this.fileList[b].name+"\n"+e.message;this.loadCompleteCb&&this.loadCompleteCb(this);return}this.loadProgressCb&&this.loadProgressCb(b+1,this.fileList.length);b+1<this.fileList.length?this._readImageFile(b+1):this._onAllImagesRead()}};b.DicomLoader3D.prototype._onAllImagesRead=function(){var c,a=this.daikonImgs[0],f=a.getSeriesInstanceUID(),d=[];for(c=0;c<this.daikonImgs.length;c++){var e=this.daikonImgs[c];e.getSeriesInstanceUID()==f&&b.DicomLoader3D._sameGeometry(e,a)&&d.push(e)}d.length!==this.daikonImgs.length&&
(this.warnings+="Multiple series found. (Loaded the first one.)\n");this.daikonImgs=d;f=this.daikonImgs.length;c=a.getBitsAllocated();d=a.getCols();e=a.getRows();if(c=this.vol.loadBegin([d,e,f],c,"little"))this.done=!0,this.errors=c;else{this.vol.setAttr("modality",a.getModality());this.vol.setAttr("rescaleSlope",a.getDataScaleSlope()||1);this.vol.setAttr("rescaleIntercept",a.getDataScaleIntercept()||0);this.vol.setAttr("dataOffset",0);(c=a.getImageDirections())&&Array.isArray(c)&&6==c.length&&(this.vol.setAttr("rowDir",
[c[0],c[1],c[2]]),this.vol.setAttr("colDir",[c[3],c[4],c[5]]));this.vol.calcNearLphAxes();c=this._sortImagesByZ(this.daikonImgs);this.vol.setAttr("sliceGap",c.gap);c.uniform||(this.warnings+="Non-uniform slice spacing detected.\n");c.warnings&&(this.warnings+=c.warnings);a=8==this.vol.bpp?4:2;d=Array(a);for(e=0;e<f;){var h={startIndex:e,endIndex:Math.min(e+a,f),imgBuffers:d};for(c=0;c<h.endIndex-h.startIndex;c++){var g=b.DicomLoader3D._getPixelValueArray(this.daikonImgs[e++]);if(!g.array){this.done=
!0;this.errors="DicomLoader3D: Unsupported pixel type.";this.loadCompleteCb&&this.loadCompleteCb(this);return}h.imgBuffers[c]=g.array.buffer;1===e&&this.vol.setAttr("dataOffset",g.offset)}if(c=this._copyImagesToTexture(h)){this.done=!0;this.errors=c;this.loadCompleteCb&&this.loadCompleteCb(this);return}}this.vol.loadEnd();this.done=!0}this.loadCompleteCb&&this.loadCompleteCb(this)};b.DicomLoader3D._getPixelValueArray=function(b){var a=b.getDataType(),c=b.getBitsAllocated()/8,d=b.getRawData(),e=new DataView(d);
d=d.byteLength/c;var h=b.littleEndian;b=daikon.Utils.createBitMask(b.getBitsAllocated()/8,b.getBitsStored(),b.getDataType()===daikon.Image.BYTE_TYPE_INTEGER_UNSIGNED);var g,l=0;if(a===daikon.Image.BYTE_TYPE_INTEGER_UNSIGNED&&2===c)for(a=new Uint16Array(d),g=0;g<d;g++)c=e.getUint16(2*g,h),a[g]=c&b;else if(a===daikon.Image.BYTE_TYPE_INTEGER_UNSIGNED&&1===c)for(a=new Uint8Array(d),g=0;g<d;g++)c=e.getUint8(g),a[g]=c&b;else if(a===daikon.Image.BYTE_TYPE_RGB&&1===c)for(a=new Uint8Array(d/3),g=0;g<d;g+=
3)c=(e.getUint8(g)+e.getUint8(g+1)+e.getUint8(g+2))/3,a[g/3]=c&b;else if(a===daikon.Image.BYTE_TYPE_INTEGER&&2===c)for(l=32768,a=new Uint16Array(d),g=0;g<d;g++)c=e.getInt16(2*g,h),a[g]=(c&b)+l;else if(a===daikon.Image.BYTE_TYPE_INTEGER&&1===c)for(l=128,a=new Uint8Array(d),g=0;g<d;g++)c=e.getInt8(g),a[g]=(c&b)+l;else a=null;return{array:a,offset:-l}};b.DicomLoader3D.prototype._sortImagesByZ=function(b){var a=glMatrix.vec3,c,d=b[0],e=d.getImageDirections();if(!e||!Array.isArray(e)||6!==e.length)return{gap:1,
uniform:!0};var h=[e[0],e[1],e[2]];var g=[e[3],e[4],e[5]];e=a.create();a.cross(e,h,g);for(h=0;h<b.length;h++){g=b[h];var l=g.getImagePosition();l=[l[0],l[1],l[2]];g.zPos=a.dot(l,e)}b.sort(function(a,b){return a.zPos>b.zPos?-1:a.zPos<b.zPos?1:0});if(2>b.length)return{gap:1,uniform:!0};a=d.getPixelSpacing()[0];d=0;for(h=1;h<b.length&&!(d=Math.abs(b[h].zPos-b[h-1].zPos)/a,0<d);h++);1!==h&&(c+="Duplicate image positions found.\n");e=!0;for(h=2;h<b.length;h++)if(.01<Math.abs(Math.abs((b[h].zPos-b[h-1].zPos)/
a)-d)){e=!1;break}return{gap:d,uniform:e,warnings:c}};b.DicomLoader3D._sameGeometry=function(b,a){var c=b.getImageDirections(),d=a.getImageDirections();if(!(c&&d&&Array.isArray(c)&&Array.isArray(d))||6!==c.length||6!==d.length)return!1;for(var e=0;6>e;e++)if(.01<Math.abs(c[e]-d[e]))return!1;b=b.getPixelSpacing()[0];a=a.getPixelSpacing()[0];return.01<Math.abs(b-a)?!1:!0}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=b.Logger.Severity;b.FrameBuffer=function(a,f,d,e,h,g,l){this.context=a;this.txIndex=f;this.width=Math.round(d);this.height=Math.round(e);if(0===this.width||0===this.height)b.Logger.Report("FrameBuffer.ctor: FrameBuffer size cannot be zero; setting it to 1.",c.Warn),this.width=this.height=1;this.depthBuffer=this.glFrameBuffer=this.texture=null;d=this.context.gl;this.texture=new b.Texture2D(a,f,this.width,this.height,h,g);this.glFrameBuffer=d.createFramebuffer();d.bindFramebuffer(d.FRAMEBUFFER,
this.glFrameBuffer);d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_2D,this.texture.glTexture,0);l&&(this.depthBuffer=d.createRenderbuffer(),d.bindRenderbuffer(d.RENDERBUFFER,this.depthBuffer),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,this.width,this.height),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.DEPTH_ATTACHMENT,d.RENDERBUFFER,this.depthBuffer),d.bindRenderbuffer(d.RENDERBUFFER,null));d.bindFramebuffer(d.FRAMEBUFFER,null)};b.FrameBuffer.prototype.destroy=function(){if(this.context){this.texture.destroy();
this.texture=null;var a=this.context.gl;this.depthBuffer&&(a.deleteRenderbuffer(this.depthBuffer),this.depthBuffer=null);a.deleteFramebuffer(this.glFrameBuffer);this.context=this.glFrameBuffer=null}};b.FrameBuffer.prototype.resize=function(a,f){a=Math.round(a);f=Math.round(f);if(0===a||0===f)b.Logger.Report("FrameBuffer.resize: FrameBuffer size cannot be zero; setting it to 1.",c.Warn),a=f=1;if(a!=this.width||f!=this.height){var d=this.context.gl;this.width=a;this.height=f;this.texture.resize(a,f);
this.depthBuffer&&(d.bindRenderbuffer(d.RENDERBUFFER,this.depthBuffer),d.renderbufferStorage(d.RENDERBUFFER,d.DEPTH_COMPONENT16,a,f),d.bindRenderbuffer(d.RENDERBUFFER,null))}};b.FrameBuffer.prototype.getSize=function(){return[this.width,this.height]}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=b.Logger.Severity;b.GLContext=function(a,f){this.gl=null;this.glVersion=-1;this.canvas=null;this.uniformSetters={};this.state={currentProgram:null,boundIndexBuffer:null,boundTextures:null,activeTexture:-1};if(window.WebGLRenderingContext){var d=f&&f.glVersion?Number(f.glVersion):null;if(0===d||d&&1!==d&&2!==d)b.Logger.Report("GLContext.ctor: Unsupported WebGL version: "+f.glVersion+".",c.Error);else{if(!d||2===d)try{if(this.gl=a.getContext("webgl2"))this.glVersion=2}catch(h){}if(!(this.gl||
d&&1!=d)){d=["webgl","experimental-webgl","webkit-3d","moz-webgl"];for(var e=0;e<d.length&&!this.gl;e++)try{if(this.gl=a.getContext(d[e]))this.glVersion=1}catch(h){}}if(this.gl)for(;this.gl.getError()!=this.gl.NO_ERROR;);if(this.gl){this.canvas=this.gl.canvas;if(a=f&&(f.logErrors||f.logCalls))this.gl=b.DebugUtils.makeDebugContext(this.gl,f.logErrors?b.GLContext._logWebGLError:function(){},f.logCalls?b.GLContext._logWebGLCall:function(){}),b.Logger.ConsoleThresh=c.Debug;this._initializeConstants();
this.uniformSetters=this._tabulateUniformSetters();this.state.boundTextures=Array(this.GlMaxTextures);f=this.gl;f.enable(f.CULL_FACE);f.cullFace(f.BACK);f.pixelStorei(f.UNPACK_ALIGNMENT,1);f.pixelStorei(f.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1);this.contextLostListener=function(a){alert("WebGL context lost. \nPlease reload the page or restart the browser and try again with a smaller data set.")};this.canvas.addEventListener("webglcontextlost",this.contextLostListener);b.Logger.Report("Created WebGL"+this.glVersion.toString()+
(a?" debug":"")+" context.",c.Debug)}else b.Logger.Report("GLContext.ctor: Unable to get WebGL context from canvas.",c.Error)}}else b.Logger.Report("GLContext.ctor: The browser doesn't support WebGL.",c.Error)};b.GLContext.prototype.destroy=function(){this.gl&&(this.canvas.removeEventListener("webglcontextlost",this.contextLostListener),this.gl=null,this.glVersion=-1,this.uniformSetters=null)};b.GLContext._isWebGL2Supported=k;b.GLContext.isWebGL2Supported=function(){if(b.GLContext._isWebGL2Supported===
k){var a=null;try{a=document.createElement("canvas").getContext("webgl2")}catch(f){}b.GLContext._isWebGL2Supported=!!a}return b.GLContext._isWebGL2Supported};b.GLContext.prototype.createProgram=function(a,c,d){return new b.ShaderProgram(this,d?d.name:"",a,c,d?d.vSubs:null,d?d.fSubs:null,d&&"undefined"!==typeof d.compile?!!d.compile:!0)};b.GLContext.prototype.createAttrBuffer=function(a,c,d){return new b.AttributeBuffer(this,a,c,d)};b.GLContext.prototype.createIndexBuffer=function(a,c,d){return new b.IndexBuffer(this,
a,c,d)};b.GLContext.prototype.bindIndexBuffer=function(a){a||null===this.state.boundIndexBuffer?a&&this.state.boundIndexBuffer!=a.glBuffer&&(this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,a.glBuffer),this.state.boundIndexBuffer=a.glBuffer):(this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,null),this.state.boundIndexBuffer=null)};b.GLContext.prototype.unbindIndexBuffer=function(a){this.state.boundIndexBuffer==a.glBuffer&&(this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,null),this.state.boundIndexBuffer=
null)};b.GLContext.prototype.bindTexture=function(a){var b=this.gl;this.state.activeTexture!=a.txIndex&&(b.activeTexture(b.TEXTURE0+a.txIndex),this.state.activeTexture=a.txIndex);this.state.boundTextures[a.txIndex]!=a.glTexture&&(b.bindTexture(a.is3D?b.TEXTURE_3D:b.TEXTURE_2D,a.glTexture),this.state.boundTextures[a.txIndex]=a.glTexture)};b.GLContext.prototype.unbindTexture=function(a){var b=this.gl;this.state.boundTextures[a.txIndex]==a.glTexture&&(b.activeTexture(b.TEXTURE0+a.txIndex),b.bindTexture(a.is3D?
b.TEXTURE_3D:b.TEXTURE_2D,null),this.state.boundTextures[a.txIndex]=null,this.state.activeTexture=a.txIndex)};b.GLContext.prototype.setCurrentProgram=function(a){a?a.context!==this?b.Logger.Report("GLContext.setCurrentProgram: Invalid program.",c.Error):this.state.currentProgram!=a&&(this.gl.useProgram(a.glProgram),this.state.currentProgram=a):(this.gl.useProgram(null),this.state.currentProgram=null)};b.GLContext.prototype.isCurrentProgram=function(a){return this.state.currentProgram==a};b.GLContext.prototype.clearCanvas=
function(a){a=b.Color.ScaleTo1(a||b.Color.Black());this.gl.clearColor(a[0],a[1],a[2],a[3]);this.gl.clear(this.gl.COLOR_BUFFER_BIT)};b.GLContext._logWebGLError=function(a,f,d){for(var e="",h=d.length,g=0;g<h;++g)e+=(0===g?"":", ")+b.DebugUtils.glFunctionArgToString(f,h,g,d[g]);a="WebGL error: "+b.DebugUtils.glEnumToString(a)+" in "+f+"("+e+")";b.Logger.Report(a,c.Error)};b.GLContext._logWebGLCall=function(a,f){for(var d="",e=f.length,h=0;h<e;++h)d+=(0===h?"":", ")+b.DebugUtils.glFunctionArgToString(a,
e,h,f[h]);b.Logger.Report("3DLib WebGL trace: "+a+"("+d+")",c.Debug)};b.GLContext.prototype._tabulateUniformSetters=function(){var a=this.gl,b={},d=function(a){return Array.isArray(a)||ArrayBuffer.isView(a)&&!(a instanceof DataView)};b[a.FLOAT_VEC2]=function(b,d){return a.uniform2fv(b,d)};b[a.FLOAT_VEC3]=function(b,d){return a.uniform3fv(b,d)};b[a.FLOAT_VEC4]=function(b,d){return a.uniform4fv(b,d)};b[a.FLOAT_MAT2]=function(b,d){return a.uniformMatrix2fv(b,!1,d)};b[a.FLOAT_MAT3]=function(b,d){return a.uniformMatrix3fv(b,
!1,d)};b[a.FLOAT_MAT4]=function(b,d){return a.uniformMatrix4fv(b,!1,d)};b[a.FLOAT]=function(b,c){return d(c)?a.uniform1fv(b,c):a.uniform1f(b,c)};b[a.INT_VEC2]=function(b,d){return a.uniform2iv(b,d)};b[a.INT_VEC3]=function(b,d){return a.uniform3iv(b,d)};b[a.INT_VEC4]=function(b,d){return a.uniform4iv(b,d)};b[a.INT]=function(b,c){return d(c)?a.uniform1iv(b,c):a.uniform1i(b,c)};b[a.SAMPLER_2D]=b[a.INT];b[a.SAMPLER_CUBE]=b[a.INT];var c=function(a){return a?1:0};b[a.BOOL_VEC2]=function(b,d){return a.uniform2iv(b,
d.map(c))};b[a.BOOL_VEC3]=function(b,d){return a.uniform3iv(b,d.map(c))};b[a.BOOL_VEC4]=function(b,d){return a.uniform4iv(b,d.map(c))};b[a.BOOL]=function(b,e){return d(e)?a.uniform1iv(b,e.map(c)):a.uniform1i(b,e?1:0)};1<this.glVersion&&(b[a.SAMPLER_3D]=b[a.INT],b[a.SAMPLER_2D_SHADOW]=b[a.INT],b[a.SAMPLER_2D_ARRAY]=b[a.INT],b[a.SAMPLER_2D_ARRAY_SHADOW]=b[a.INT],b[a.SAMPLER_CUBE_SHADOW]=b[a.INT],b[a.INT_SAMPLER_2D]=b[a.INT],b[a.INT_SAMPLER_3D]=b[a.INT],b[a.INT_SAMPLER_CUBE]=b[a.INT],b[a.INT_SAMPLER_2D_ARRAY]=
b[a.INT],b[a.UNSIGNED_INT_SAMPLER_2D]=b[a.INT],b[a.UNSIGNED_INT_SAMPLER_3D]=b[a.INT],b[a.UNSIGNED_INT_SAMPLER_CUBE]=b[a.INT],b[a.UNSIGNED_INT_SAMPLER_2D_ARRAY]=b[a.INT],b[a.UNSIGNED_INT_VEC2]=function(b,d){return a.uniform2uiv(b,d)},b[a.UNSIGNED_INT_VEC3]=function(b,d){return a.uniform3uiv(b,d)},b[a.UNSIGNED_INT_VEC4]=function(b,d){return a.uniform4uiv(b,d)},b[a.UNSIGNED_INT]=function(b,c){return d(c)?a.uniform1uiv(b,c):a.uniform1ui(b,c)},b[a.FLOAT_MAT2x3]=function(b,d){return a.uniformMatrix2x3fv(b,
!1,d)},b[a.FLOAT_MAT2x4]=function(b,d){return a.uniformMatrix2x4fv(b,!1,d)},b[a.FLOAT_MAT3x2]=function(b,d){return a.uniformMatrix3x2fv(b,!1,d)},b[a.FLOAT_MAT3x4]=function(b,d){return a.uniformMatrix3x4fv(b,!1,d)},b[a.FLOAT_MAT4x2]=function(b,d){return a.uniformMatrix4x2fv(b,!1,d)},b[a.FLOAT_MAT4x3]=function(b,d){return a.uniformMatrix4x3fv(b,!1,d)});return b};b.GLContext.prototype._initializeConstants=function(){var a=this.gl;this.GlMaxTextures=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);this.GlMaxTextureSize=
a.getParameter(a.MAX_TEXTURE_SIZE);this.GlMax3DTextureSize=1<this.glVersion?a.getParameter(a.MAX_3D_TEXTURE_SIZE):0;this.GlMaxFragUniformVecs=a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS);this.GlMaxVertUniformVecs=a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS);this.GlMaxRenderBufSize=a.getParameter(a.MAX_RENDERBUFFER_SIZE);this.GlVersionInfo=a.getParameter(a.VERSION);var b=a.getExtension("WEBGL_debug_renderer_info");null!==b?(this.RendererInfo=a.getParameter(b.UNMASKED_RENDERER_WEBGL),this.VendorInfo=
a.getParameter(b.UNMASKED_VENDOR_WEBGL)):(this.RendererInfo=a.getParameter(a.RENDERER)||"Unknown",this.VendorInfo=a.getParameter(a.VENDOR)||"Unknown")};b.GLContext.prototype.sizeOf=function(a){var b=-1,d=this.gl;a===d.FLOAT||a===d.UNSIGNED_INT||a===d.INT?b=4:a===d.UNSIGNED_SHORT||a===d.SHORT?b=2:a===d.UNSIGNED_BYTE||a===d.BYTE?b=1:1<this.glVersion&&a===d.HALF_FLOAT&&(b=2);return b}})(window.BigLime=window.BigLime||{});
(function(b,k){b.Histogram3D=function(b){this.data=new Uint32Array(b);this.numBins=b;this.binWidth=65536/b;this.minVal=65535;this.threshedMaxVal=this.threshedMinVal=this.maxVal=0;this.threshPercent=null};b.Histogram3D.prototype.clear=function(){for(var b=0;b<this.numBins;b++)this.data[b]=0;this.minVal=65535;this.threshedMaxVal=this.threshedMinVal=this.maxVal=0;this.threshPercent=null};b.Histogram3D.prototype.addImage=function(b,a,f){if(b){b=new Uint8Array(b);var d=b.length;if(1==a)for(a=0;a<d;a+=
8)f=b[a],this.data[f/this.binWidth|0]++,f<this.minVal&&(this.minVal=f),f>this.maxVal&&(this.maxVal=f);else if(2==a)if(f)for(a=0;a<d;a+=16)f=256*b[a]+b[a+1],this.data[f/this.binWidth|0]++,f<this.minVal&&(this.minVal=f),f>this.maxVal&&(this.maxVal=f);else for(a=0;a<d;a+=16)f=b[a]+256*b[a+1],this.data[f/this.binWidth|0]++,f<this.minVal&&(this.minVal=f),f>this.maxVal&&(this.maxVal=f)}};b.Histogram3D.prototype.getThreshedMinMax=function(b){if(this.threshPercent===b)return[this.threshedMinVal,this.threshedMaxVal];
for(var a=0,c=1;c<this.numBins;c++)a+=this.data[c];c=Math.round(.01*b*a);for(var d=0,e=1;d<=c&&e<this.numBins;)for(d+=this.data[e],e++;e<this.numBins&&0===this.data[e];)e++;a=(e+.5)*this.binWidth;d=0;for(e=this.numBins-1;0<=e&&d<=c;)for(d+=this.data[e],e--;0<=e&&0===this.data[e];)e--;c=65535-(this.numBins-1-e+.5)*this.binWidth;c<a&&(c=a);this.threshPercent=b;this.threshedMinVal=a;this.threshedMaxVal=c;return[this.threshedMinVal,this.threshedMaxVal]}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=b.Logger.Severity;b.IndexBuffer=function(a,f,d,e){var h=a.gl;this.context=a;this.elemSize=d||2;this.dataType=1==d?h.UNSIGNED_BYTE:2==d?h.UNSIGNED_SHORT:h.UNSIGNED_INT;this.drawMode=e||h.STATIC_DRAW;this.numIndices=0;this.glBuffer=null;1!=d&&2!=d&&4!=d?b.Logger.Report("IndexBuffer ctor: Invalid elemSize",c.Error):2<d&&2>a.glVersion&&!h.getExtension("OES_element_index_uint")?b.Logger.Report("IndexBuffer ctor: Unsupported elemSize",c.Error):(a=this._coerceData(f))?(this.numIndices=
a.length,this.glBuffer=h.createBuffer(),this.bind(),h.bufferData(h.ELEMENT_ARRAY_BUFFER,a,this.drawMode)):b.Logger.Report("IndexBuffer.ctor: Invalid data array.",c.Error)};b.IndexBuffer.prototype.destroy=function(){if(this.context){var a=this.context.gl;this.bind();a.bufferData(a.ELEMENT_ARRAY_BUFFER,1,this.drawMode);this.unbind();this.glBuffer&&(a.deleteBuffer(this.glBuffer),this.glBuffer=null);this.context=null}};b.IndexBuffer.prototype.bind=function(){this.context.bindIndexBuffer(this)};b.IndexBuffer.prototype.unbind=
function(){this.context.unbindIndexBuffer(this)};b.IndexBuffer.prototype._coerceData=function(a){var b=this.context.gl;try{if(this.dataType===b.UNSIGNED_INT)return a instanceof Uint32Array?a:new Uint32Array(a);if(this.dataType===b.UNSIGNED_SHORT)return a instanceof Uint16Array?a:new Uint16Array(a);if(this.dataType===b.UNSIGNED_BYTE)return a instanceof Uint8Array?a:new Uint8Array(a)}catch(d){}return null};b.IndexBuffer.prototype.setData=function(a,f){if(a=this._coerceData(a)){var d=this.context.gl;
this.bind();d.bufferSubData(d.ELEMENT_ARRAY_BUFFER,f||0,a)}else b.Logger.Report("IndexBuffer.setData: Invalid data array.",c.Error)}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=glMatrix.vec3;b.Light=function(a){this.diffuse=a?a.diffuse:.1;this.specStrength=a?a.specStrength:0;this.specExp=a?a.specExp:32;this.shadowDarkness=a?a.shadowDarkness:0;this.shadowSoftness=a?a.shadowSoftness:.75;this.dir=a?c.clone(a.dir):c.fromValues(0,0,1)};b.Light.prototype.updateFrom=function(a){this.diffuse=a.diffuse;this.specStrength=a.specStrength;this.specExp=a.specExp;this.shadowDarkness=a.shadowDarkness;this.shadowSoftness=a.shadowSoftness;c.copy(this.dir,a.dir)};b.Light.prototype.valueEquals=
function(a){return b.Utils.floatEquals(this.diffuse,a.diffuse,1E-4)&&b.Utils.floatEquals(this.specStrength,a.specStrength,1E-4)&&b.Utils.floatEquals(this.specExp,a.specExp,1E-4)&&b.Utils.floatEquals(this.shadowDarkness,a.shadowDarkness,1E-4)&&b.Utils.floatEquals(this.shadowSoftness,a.shadowSoftness,1E-4)&&b.Utils.floatEquals(this.dir[0],a.dir[0],1E-4)&&b.Utils.floatEquals(this.dir[1],a.dir[1],1E-4)&&b.Utils.floatEquals(this.dir[2],a.dir[2],1E-4)?!0:!1}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=glMatrix.vec2,a=glMatrix.vec3;b.LightPositioner=function(a){this.mainDiv=a;this.canvas=null;this.ptRadius=10;this.lightPosW=c.create();this.active=!1;this.defaultLightDir=[.32,-.16,.93];this._buildUi();this.setLightDirection(this.defaultLightDir);this._redraw();this.interactor=new b.Interactor(this.canvas,"lightPos");this.interactor.addEventListener("start move end",this._onInteract.bind(this))};b.LightPositioner.prototype._buildUi=function(){var a=b.Ui;a.StyleElement(this.mainDiv,
{margin:"auto"});this.canvSize=Math.min(parseInt(this.mainDiv.style.width),parseInt(this.mainDiv.style.height));this.padRadius=(this.canvSize-2*this.ptRadius)/2;this.canvas=a.CreateElement("canvas","canvas",this.mainDiv,{width:this.canvSize,height:this.canvSize},{width:this.canvSize,height:this.canvSize});this.canvas.addEventListener(b.Utils.isTouchDevice()?"doubleTap":"dblclick",this._onDoubleClick.bind(this))};b.LightPositioner.prototype._redraw=function(){var a=this.canvas.getContext("2d"),b=this.canvas.width,
c=this.canvas.height;a.clearRect(0,0,b,c);a.beginPath();a.fillStyle="rgba(255, 255, 255, 0.0)";a.fillRect(0,0,b,c);b/=2;c/=2;a.beginPath();a.arc(b,c,this.padRadius,0,2*Math.PI);a.fillStyle="#D2B48C";a.fill();a.beginPath();a.arc(this.lightPosW[0],this.lightPosW[1],this.ptRadius,0,2*Math.PI);a.fillStyle="#8B4513";a.fill();a.beginPath();a.moveTo(b,c-this.ptRadius-5);a.lineTo(b,c+this.ptRadius+5);a.moveTo(b-this.ptRadius-5,c);a.lineTo(b+this.ptRadius+5,c);a.strokeStyle="black";a.stroke()};b.LightPositioner.prototype.getLightDirection=
function(){var b=-(this.lightPosW[0]-this.canvas.width/2),d=this.lightPosW[1]-this.canvas.height/2;b=a.fromValues(b,d,Math.sqrt(this.padRadius*this.padRadius-b*b-d*d));a.normalize(b,b);return b};b.LightPositioner.prototype.setLightDirection=function(b){b=a.clone(b);a.normalize(b,b);a.scale(b,b,this.padRadius);this.lightPosW[0]=-b[0]+this.canvas.width/2;this.lightPosW[1]=b[1]+this.canvas.height/2;this._redraw();this.trigger("change")};b.LightPositioner.prototype._onInteract=function(a){if("start"==
a.type)c.distance(this.interactor.currPoint,this.lightPosW)>this.ptRadius||(this.active=!0,this.trigger("changeStart"));else if("move"==a.type){if(this.active){c.add(this.lightPosW,this.lightPosW,this.interactor.deltaPrev);a=c.fromValues(this.canvas.width/2,this.canvas.height/2);var b=c.create();c.subtract(b,this.lightPosW,a);var e=c.length(b);e>.98*this.padRadius&&(c.scale(b,b,.98*this.padRadius/e),c.add(this.lightPosW,b,a));this._redraw();this.trigger("change")}}else"end"==a.type&&this.active&&
(this.active=!1,this.trigger("changeEnd"))};b.LightPositioner.prototype._onDoubleClick=function(){this.setLightDirection(this.defaultLightDir)};b.LightPositioner.prototype.addEventListener=function(a,d){b.Notifier.prototype.addEventListener.call(this,a,d)};b.LightPositioner.prototype.removeEventListener=function(a,d){b.Notifier.prototype.removeEventListener.call(this,a,d)};b.LightPositioner.prototype.trigger=function(a,d){b.Notifier.prototype.trigger.call(this,a,d)}})(window.BigLime=window.BigLime||
{});
(function(b,k){b.LightSet=function(c){c?(this.ambientLight=c.ambientLight,this.dirLights=[new b.Light(c.dirLights[0]),new b.Light(c.dirLights[1])]):(this.ambientLight=.5,this.dirLights=[new b.Light,new b.Light])};b.LightSet.prototype.updateFrom=function(b){this.ambientLight=b.ambientLight;this.dirLights[0].updateFrom(b.dirLights[0]);this.dirLights[1].updateFrom(b.dirLights[1])};b.LightSet.prototype.valueEquals=function(c){return b.Utils.floatEquals(this.ambientLight,c.ambientLight,1E-4)&&this.dirLights[0].valueEquals(c.dirLights[0])&&this.dirLights[1].valueEquals(c.dirLights[1])?
!0:!1};b.LightSet.prototype.shadowsEnabled=function(){return this.dirLights.some(function(b){return 0<b.shadowDarkness})}})(window.BigLime=window.BigLime||{});
(function(b,k){b.Material=function(c,a,f,d,e,h){this.flatShade=!!a;this.ambient=f||(0===f?0:.5);this.diffuse=d||(0===d?0:.5);this.specStrength=e||(0===e?0:.5);this.specPower=h||(0===h?0:32);this.color=c?c instanceof b.Color?c.toArray():c.slice():[255,0,0,255];3===this.color.length&&this.color.push(255)};b.Material.prototype.clone=function(){return new b.Material(this.color,this.flatShade,this.ambient,this.diffuse,this.specStrength,this.specPower)}})(window.BigLime=window.BigLime||{});
(function(b,k){b.MeshManager=function(b){this.volume=b;this.meshes=[];this.materialBuffer=this.colorBuffer=this.normalBuffer=this.vertexBuffer=null;this.bufferOffsets={vertices:0,normals:0,colors:0,materials:0};this.needToSync=!0};b.MeshManager.prototype.destroy=function(){this.volume&&(this.vertexBuffer&&(this.vertexBuffer.destroy(),this.vertexBuffer=null),this.normalBuffer&&(this.normalBuffer.destroy(),this.normalBuffer=null),this.colorBuffer&&(this.colorBuffer.destroy(),this.colorBuffer=null),
this.materialBuffer&&(this.materialBuffer.destroy(),this.materialBuffer=null),this.volume=null)};b.MeshManager.prototype.addMesh=function(c){for(var a=0;a<this.meshes.length;a++)if(this.meshes[a].name==c.name){b.Logger.Report("Warning: Duplicate mesh name ("+c.name+"), in MeshManager.addMesh.",b.Logger.Severity.Warning);break}this.meshes.push(c);this.needToSync=!0};b.MeshManager.prototype.removeMesh=function(b){var a,c=null;for(a=0;a<this.meshes.length;a++)if(this.meshes[a].name==b){c=this.meshes[a];
this.meshes.splice(a,1);this.needToSync=!0;break}return c};b.MeshManager.prototype.removeAllMeshes=function(){var b=this.meshes;this.needToSync=0<b.length;this.meshes=[];return b};b.MeshManager.prototype.contains=function(b){return this.meshes.includes(b)};b.MeshManager.prototype.numMeshes=function(b){for(var a=0,c=0;c<this.meshes.length;c++)this.meshes[c].layer!==b&&"undefined"!=typeof b||a++;return a};b.MeshManager.prototype.numVisibleMeshes=function(b){for(var a=0,c=0;c<this.meshes.length;c++){var d=
this.meshes[c];!d.visible||d.layer!==b&&"undefined"!=typeof b||a++}return a};b.MeshManager.prototype.numVisibleVertices=function(b){for(var a=0,c=0;c<this.meshes.length;c++){var d=this.meshes[c];!d.visible||d.layer!==b&&"undefined"!=typeof b||(a+=d.numVertices())}return a};b.MeshManager.prototype.activateMeshes=function(c,a){c=c||0;if(!this.vertexBuffer){var f=this.volume.context;this.vertexBuffer=new b.AttributeBuffer(f,null,3);this.normalBuffer=new b.AttributeBuffer(f,null,3);this.colorBuffer=new b.AttributeBuffer(f,
null,4);this.materialBuffer=new b.AttributeBuffer(f,null,4)}this.needToSync&&(f=this._concatDataArrays("vBuffer"),this.vertexBuffer.setData(f.data),this.bufferOffsets.vertices=f.offset,f=this._concatDataArrays("nBuffer"),this.normalBuffer.setData(f.data),this.bufferOffsets.normals=f.offset,f=this._concatDataArrays("cBuffer"),this.colorBuffer.setData(f.data),this.bufferOffsets.colors=f.offset,f=this._concatDataArrays("mBuffer"),this.materialBuffer.setData(f.data),this.bufferOffsets.materials=f.offset,
this.needToSync=!1);f=0===c?0:4*this.bufferOffsets.vertices;a.setAttribute("aPosition",this.vertexBuffer,!0,f);f=0===c?0:4*this.bufferOffsets.normals;a.setAttribute("aNormal",this.normalBuffer,!0,f);f=0===c?0:4*this.bufferOffsets.colors;a.setAttribute("aColor",this.colorBuffer,!0,f);f=0===c?0:4*this.bufferOffsets.materials;a.setAttribute("aMaterial",this.materialBuffer,!0,f)};b.MeshManager.prototype._concatDataArrays=function(b){for(var a,c=0,d=0,e=0;e<this.meshes.length;e++)a=this.meshes[e],a.visible&&
(0===a.layer?c+=a[b].length:d+=a[b].length);d=c+d;e=new Float32Array(d);for(var h=0,g=0;g<this.meshes.length;g++)a=this.meshes[g],a.visible&&0===a.layer&&(e.set(a[b],h),h+=a[b].length);for(g=0;g<this.meshes.length;g++)a=this.meshes[g],a.visible&&0!==a.layer&&(e.set(a[b],h),h+=a[b].length);if("vBuffer"==b){a=1/this.volume.dims[0];h=1/this.volume.dims[1];g=1/(this.volume.dims[2]*this.volume.sliceGap);for(var l=0;l<d;l+=3)e[l]=e[l]*a-.5,e[l+1]=e[l+1]*h-.5,e[l+2]=.5-e[l+2]*g}if("nBuffer"==b)for(b=2;b<
d;b+=3)e[b]=-e[b];return{data:e,offset:c}}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=glMatrix.vec2,a=glMatrix.vec3,f=glMatrix.mat4;b.MprViewer=function(d){d=d===k?{}:d;this.site=d.site;this.id=d.id;this.owner=d.owner;this.drawOrientLabels=!1===d.drawOrientLabels?!1:!0;if(!d.initialPlane||"string"===typeof d.initialPlane||d.initialPlane instanceof String){var c=(d.initialPlane||"axi").toLowerCase();this.rowDir="axi"==c?a.fromValues(1,0,0):"cor"==c?a.fromValues(1,0,0):a.fromValues(0,1,0);this.colDir="axi"==c?a.fromValues(0,1,0):a.fromValues(0,0,-1)}else this.rowDir=
a.clone(d.initialPlane[0]),this.colDir=a.clone(d.initialPlane[1]),a.normalize(this.rowDir,this.rowDir),a.normalize(this.colDir,this.colDir);this.initialPlane={rowDir:a.clone(this.rowDir),colDir:a.clone(this.colDir)};this.canvas=b.Ui.CreateElement("canvas","mprviewer_canvas",this.site,{width:"100%",height:"100%",backgroundColor:"#000000"});this.canvas.addEventListener("contextmenu",function(a){a.preventDefault()});this.renderEngine=d.renderEngine?d.renderEngine:new b.RenderEngine({options:d.engineOptions});
this.ownsEngine=!d.renderEngine;c=this.renderParams=new b.RenderParams;c.renderType=b.RenderType.MIP;c.slab=new b.Slab(this.renderEngine.volume);c.clipToSlab=!0;c.showSlab=!1;c.rayOversamp=2;c.showGraphics=!1;c.showMarker=!1;c.rotMatrix=b.Utils.GetRotMatrix(this.rowDir,this.colDir);this.mprThickness=1;this.mprPoint=a.fromValues(.5,.5,.5);this.fastDrawDownsamp=1;this.resizeTimerId=null;this.renderCallbacks=[];d.omitInteractor||(this.interactor=new b.MultiInteractor(this.canvas),this.interactor.addEventListener("start move end",
this._onInteractorEvent.bind(this)));!1!==d.autoResize&&(this.resizeListener=this.onResize.bind(this),window.addEventListener("resize",this.resizeListener));this.onResize()};b.MprViewer.prototype.destroy=function(){this.renderEngine&&(clearTimeout(this.resizeTimerId),this.resizeListener&&window.removeEventListener("resize",this.resizeListener),b.Utils.cancelAnimFrame(this.rafId),this.interactor&&this.interactor.stopListening(),this.ownsEngine&&this.renderEngine.destroy(),this.renderEngine=null,this.canvas.remove())};
b.MprViewer.prototype.onResize=function(a){a=a===k?!1:a;var d=this.canvas.getBoundingClientRect();this.canvas.width=Math.round(d.width);this.canvas.height=Math.round(d.height);this.rafId=b.Utils.requestAnimFrame(this.render.bind(this));a?this.resizeTimerId=null:(this.resizeTimerId&&clearTimeout(this.resizeTimerId),this.resizeTimerId=setTimeout(function(){this.onResize(!0)}.bind(this),300))};b.MprViewer.prototype.clear=function(){this.canvas.getContext("2d").clearRect(0,0,this.canvas.width,this.canvas.height)};
b.MprViewer.prototype.loadVolume=function(a,b,c,f){var d=function(a,b){if(!a)this.onNewVolumeLoaded();c&&c(a,b,this)}.bind(this);this.renderEngine.loadVolume({imgFiles:a,loader:b,completionCb:d,progressCb:f,omitRender:!0,omitResetView:!0})};b.MprViewer.prototype.cancelLoading=function(){this.renderEngine.cancelLoading()};b.MprViewer.prototype.onNewVolumeLoaded=function(){};b.MprViewer.prototype.render=function(){var a=this,b=this.renderEngine;if(b.hasImageData()){b.setRenderParams(this.renderParams);
var c=b.isAnimating()?this.fastDrawDownsamp:1;b.sizeRasterToMatch(this.canvas,c);this._updateSlab();b.render();c=this.canvas.getContext("2d");c.clearRect(0,0,this.canvas.width,this.canvas.height);c.drawImage(b.canvas,0,0,this.canvas.width,this.canvas.height);this.drawOrientLabels&&this._drawOrientLabels();this.renderCallbacks.forEach(function(b){b(a)})}};b.MprViewer.prototype._drawOrientLabels=function(d){d=this.canvas.getContext("2d");var c=this.canvas.width,f=this.canvas.height,g=["",""],l=this.renderEngine.volume,
m=l.getAttr("rowDir");l=l.getAttr("colDir");if(m&&l){var n=a.cross(a.create(),m,l),k=a.create();a.scaleAndAdd(k,k,m,this.rowDir[0]);a.scaleAndAdd(k,k,l,this.rowDir[1]);a.scaleAndAdd(k,k,n,this.rowDir[2]);g[0]=b.ImageLook.getOrientationLabel(k);k=a.create();a.scaleAndAdd(k,k,m,this.colDir[0]);a.scaleAndAdd(k,k,l,this.colDir[1]);a.scaleAndAdd(k,k,n,this.colDir[2]);a.negate(k,k);g[1]=b.ImageLook.getOrientationLabel(k)}Object.assign(d,{font:"18px Arial Narrow",textAlign:"center",textBaseline:"middle",
fillStyle:"#cfcfcf",shadowColor:"black",shadowOffsetX:2,shadowOffsetY:2});d.fillText(g[0],c-24,f/2);d.fillText(g[1],c/2,15);c=$jscomp.makeIterator([0,0]);d.shadowOffsetX=c.next().value;d.shadowOffsetY=c.next().value};b.MprViewer.prototype._updateSlab=function(){var b=this.renderParams,c=this.renderEngine.volume,h=b.slab,g=Math.max.apply(Math,$jscomp.arrayFromIterable(c.shape));a.copy(h.shape,[4*g,4*g,this.mprThickness]);f.copy(h.orient,b.rotMatrix);a.multiply(h.center,this.mprPoint,c.shape)};b.MprViewer.prototype._onInteractorEvent=
function(a){var b=this.renderEngine,d=this.renderParams,f=this.interactor;if("start"==a.type)f.setInitialValues({zoom:d.zoom,pan:d.pan,wwl:{width:d.winWidth,level:d.winLevel,levelRange:b.volume.getAutoWinLevel()[0]}}),b.animate(15,this.render.bind(this));else if("move"==a.type)switch(f.interactMode){case "zoom":case "wheelzoom":d.zoom=f.currentZoom;break;case "pan":c.copy(d.pan,f.currentPan);break;case "panzoom":d.zoom=f.currentZoom;c.copy(d.pan,f.currentPan);break;case "light":d.winWidth=f.winWidth,
d.winLevel=f.winLevel}else"end"==a.type&&(b.stopAnimation(),this.render())};b.MprViewer.prototype.setMprPoint=function(b){a.copy(this.mprPoint,b)};b.MprViewer.prototype.resetMprPoint=function(){this.setMprPoint([.5,.5,.5])};b.MprViewer.prototype.setMprThickness=function(a){this.mprThickness=Math.max(1,a)};b.MprViewer.prototype.setOrientation=function(d,c){a.normalize(this.rowDir,d);a.normalize(this.colDir,c);Math.abs(1E-4<a.dot(this.rowDir,this.colDir))&&b.Logger.Report("MprViewer.setOrient: Received non-orthogonal orientation vectors.",
b.Logger.Severity.Warn,!1,!1);b.Utils.GetRotMatrix(this.rowDir,this.colDir,this.renderParams.rotMatrix)};b.MprViewer.prototype.resetOrientation=function(){var b=this.initialPlane,c=this.renderEngine.volume.nearLphAxes,f=a.scale(a.create(),c.L,b.rowDir[0]);a.scaleAndAdd(f,a.scaleAndAdd(f,f,c.P,b.rowDir[1]),c.H,b.rowDir[2]);var g=a.scale(a.create(),c.L,b.colDir[0]);a.scaleAndAdd(g,a.scaleAndAdd(g,g,c.P,b.colDir[1]),c.H,b.colDir[2]);this.setOrientation(f,g)};b.MprViewer.prototype.resetZoom=function(){this.renderParams.zoom=
this.calcDefaultZoom()};b.MprViewer.prototype.resetPan=function(){c.copy(this.renderParams.pan,[0,0])};b.MprViewer.prototype.resetWindowWidthAndLevel=function(){var a=$jscomp.makeIterator(this.renderEngine.volume.getAutoWinLevel());this.renderParams.winWidth=a.next().value;this.renderParams.winLevel=a.next().value};b.MprViewer.prototype.calcDefaultZoom=function(){var a=1;if(this.renderEngine.hasImageData()){a=this.renderEngine.volume;var b=this.rowDir.reduce(function(a,b,d,c){return Math.abs(b)>Math.abs(c[a])?
d:a},0),c=this.colDir.reduce(function(a,b,d,c){return Math.abs(b)>Math.abs(c[a])?d:a},0),f=this.canvas.width/this.canvas.height;a=a.shape[b]/a.shape[c]>f?a.diagSize/a.shape[b]*Math.max(1,f):a.diagSize/a.shape[c]*Math.max(1,1/f)}return a};b.MprViewer.prototype.txToViewport=function(b,c){c=(c=c===k?null:c)||this.renderEngine.calcTransforms(this.renderParams,this.canvas,{omitLights:!0});b=a.subtract(a.create(),b,[.5,.5,.5]);c=a.transformMat4(a.create(),b,c.mvp);return[(1+c[0])*this.canvas.width/2,(1-
c[1])*this.canvas.height/2]};b.MprViewer.prototype.viewportToTx=function(b,c){c=(c=c===k?null:c)||this.renderEngine.calcTransforms(this.renderParams,this.canvas,{omitLights:!0});b=[2*b[0]/this.canvas.width-1,1-2*b[1]/this.canvas.height,0];c=a.transformMat4(a.create(),b,c.mvpInv);a.add(c,c,[.5,.5,.5]);b=a.cross(a.create(),this.rowDir,this.colDir);var d=a.dot(b,a.subtract(a.create(),c,this.mprPoint));a.subtract(c,c,a.scale(b,b,d));return c}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=glMatrix.vec2,a=glMatrix.vec3,f=glMatrix.mat4;b.MultiInteractor=function(a,c){var d=this;c=c||{};var e=c.pan||{btns:2,shift:!1,ctrl:!1,alt:!1},l=c.zoom||{btns:0,shift:!0,ctrl:!1,alt:!1},m=c.rot||{btns:0,shift:!1,ctrl:!1,alt:!1};c=c.wl||{btns:0,shift:!1,ctrl:!1,alt:!0};this.panEventTypes=Array.isArray(e)?e:[e];this.zoomEventTypes=Array.isArray(l)?l:[l];this.rotEventTypes=Array.isArray(m)?m:[m];this.wlEventTypes=Array.isArray(c)?c:[c];b.Interactor.call(this,a,"multi",[].concat.apply([],
[this.panEventTypes,this.zoomEventTypes,this.rotEventTypes,this.wlEventTypes]));this.wlEnabled=this.rotEnabled=this.zoomEnabled=this.panEnabled=!0;this.winLevel=this.winWidth=1;this.shadow=this.ambient=0;this.wlRateOfChange=1;this.asRateOfChange=1/1024;this.initialZoom=1;this.initialPan=[0,0];this.initialRot=f.create();this.currentZoom=1;this.currentPan=[0,0];this.currentRot=f.create();this.deltaRot=f.create();this.mouseWheelZoomEnabled=!0;this.mouseWheelListener=this._onMouseWheelChange.bind(this);
this.eventSources.forEach(function(a){return a.addEventListener("wheel",d.mouseWheelListener)});this.mouseWheelTimerId=null};b.MultiInteractor.prototype=Object.create(b.Interactor.prototype);b.MultiInteractor.prototype.constructor=b.MultiInteractor;b.MultiInteractor.prototype.stopListening=function(){var a=this;b.Interactor.prototype.stopListening.call(this);this.eventSources.forEach(function(b){return b.removeEventListener("wheel",a.mouseWheelListener)});clearTimeout(this.mouseWheelTimerId)};b.MultiInteractor.prototype.setInitialValues=
function(a){a=a===k?{}:a;a.zoom&&(this.initialZoom=this.currentZoom=a.zoom);a.pan&&(c.copy(this.initialPan,a.pan),c.copy(this.currentPan,a.pan));a.rot&&(f.copy(this.initialRot,a.rot),f.copy(this.currentRot,a.rot));a.wwl&&(this.winWidth=a.wwl.width,this.winLevel=a.wwl.level,this.wlRateOfChange=Math.max(1,a.wwl.levelRange)/1024);a.lighting&&(this.ambient=a.lighting.ambient,this.shadow=a.lighting.shadow,this.asRateOfChange=1/1024)};b.MultiInteractor.prototype._onStart=function(a){this.mouseWheelTimerId&&
(clearTimeout(this.mouseWheelTimerId),this.mouseWheelTimerId=null);if(this.pinching)this.interactMode=this.panEnabled||this.zoomEnabled?"panzoom":"none";else if("touchstart"==a.type)this.interactMode=this.rotEnabled?"rotate":"none";else{var c=b.Interactor.MouseEventMatches;this.interactMode=c(a,this.panEventTypes)&&this.panEnabled?"pan":c(a,this.zoomEventTypes)&&this.zoomEnabled?"zoom":c(a,this.rotEventTypes)&&this.rotEnabled?"rotate":c(a,this.wlEventTypes)&&this.wlEnabled?"light":"none"}"none"!=
this.interactMode&&(this.onStart?this.onStart(a):this.trigger("start",{origEvent:a}))};b.MultiInteractor.prototype._onMove=function(a){if("none"!=this.interactMode&&"wheelzoom"!=this.interactMode){var d=this.currentEventSource.getBoundingClientRect();if(this.pinching)2<=this.currNumTouches&&(d=2/Math.min(d.width,d.height),this.currentPan[0]-=d*this.deltaPrevPinch.ctr[0]/this.currentZoom,this.currentPan[1]+=d*this.deltaPrevPinch.ctr[1]/this.currentZoom,this.currentZoom=this.currPinch.sep/(this.startPinch.sep+
1E-4)*this.initialZoom);else switch(this.interactMode){case "pan":d=2/Math.min(d.width,d.height);this.currentPan[0]-=d*this.deltaPrev[0]/this.currentZoom;this.currentPan[1]+=d*this.deltaPrev[1]/this.currentZoom;break;case "zoom":this.currentZoom*=Math.pow(1.01,-this.deltaPrev[1]);break;case "panzoom":d=2/Math.min(d.width,d.height);this.currentPan[0]-=d*this.deltaPrev[0]/this.currentZoom;this.currentPan[1]+=d*this.deltaPrev[1]/this.currentZoom;this.currentZoom*=Math.pow(1.01,-this.deltaPrev[1]);break;
case "rotate":d=c.fromValues(d.width,d.height);b.MultiInteractor._CalcRotationMatrix(this.deltaRot,this.prevPoint,this.currPoint,d);f.multiply(this.currentRot,this.deltaRot,this.currentRot);break;case "light":this.winLevel+=this.wlRateOfChange*this.deltaPrev[1],this.winWidth-=this.wlRateOfChange*this.deltaPrev[0],this.winWidth=Math.max(this.winWidth,1E-4),this.ambient-=this.asRateOfChange*this.deltaPrev[1],this.ambient=Math.min(2,Math.max(0,this.ambient)),this.shadow+=this.asRateOfChange*this.deltaPrev[0],
this.shadow=Math.min(1.5,Math.max(0,this.shadow))}this.onMove?this.onMove(a):this.trigger("move",{origEvent:a})}};b.MultiInteractor.prototype._onEnd=function(a){"none"!=this.interactMode&&(this.onEnd?this.onEnd(a):this.trigger("end",{origEvent:a}),this.interactMode="none")};b.MultiInteractor.prototype._onMouseWheelChange=function(a){if(this.mouseWheelZoomEnabled){var b=a.originalEvent;if(!a.deltaMode&&0!==a.deltaMode||!a.deltaY&&0!==a.deltaY){if(!b||!b.deltaMode&&0!==b.deltaMode||!b.deltaY&&0!==b.deltaY)return;
b=a.originalEvent.deltaMode;var c=a.originalEvent.deltaY}else b=a.deltaMode,c=a.deltaY;b=Math.pow(1.01,-c/(0===b?50:1.5));this.mouseWheelTimerId?(this.currentZoom*=b,this.onMove?this.onMove(a):this.trigger("move",{origEvent:a}),clearTimeout(this.mouseWheelTimerId)):(this.active=!0,this.interactMode="wheelzoom",this.onStart?this.onStart(a):this.trigger("start",{origEvent:a}),this.currentZoom=this.initialZoom*b,this.onMove?this.onMove(a):this.trigger("move",{origEvent:a}));this.mouseWheelTimerId=setTimeout(function(){this.onEnd?
this.onEnd(a):this.trigger("end",{origEvent:a});this.active=!1;this.interactMode="none";this.mouseWheelTimerId=null}.bind(this),500);a.preventDefault()}};b.MultiInteractor._CalcRotationMatrix=function(b,e,h,g){var d=c.clone(g);c.scale(d,d,.5);var m=Math.min(d[0],d[1]);g=m*m;h=c.clone(h);c.subtract(h,h,d);e=c.clone(e);c.subtract(e,e,d);h[0]=-h[0];e[0]=-e[0];d=c.length(h);d>m&&(c.scale(h,h,m/d),d=m);h=a.fromValues(h[0],h[1],Math.sqrt(Math.max(0,g-d*d)));d=c.length(e);d>m&&(c.scale(e,e,m/d),d=m);e=a.fromValues(e[0],
e[1],Math.sqrt(Math.max(0,g-d*d)));1E-4>Math.abs(h[0]-e[0])&&1E-4>Math.abs(h[1]-e[1])?f.identity(b):(m=a.create(),a.cross(m,h,e),h=a.length(m),1E-4>Math.abs(h)?f.identity(b):(g=h/g,e=Math.sqrt(Math.max(0,1-g*g)),g=Math.sqrt(Math.max(0,(1-e)/2)),e=Math.sqrt(Math.max(0,(1+e)/2)),a.scale(m,m,-1/h),h=m[0]*g,d=m[1]*g,g*=m[2],b[0]=e*e+h*h-d*d-g*g,b[1]=2*(h*d+e*g),b[2]=2*(h*g-e*d),b[3]=0,b[4]=2*(h*d-e*g),b[5]=e*e-h*h+d*d-g*g,b[6]=2*(d*g+e*h),b[7]=0,b[8]=2*(h*g+e*d),b[9]=2*(d*g-e*h),b[10]=e*e-h*h-d*d+g*g,
b[11]=0))}})(window.BigLime=window.BigLime||{});
(function(){function b(k,c,a){function f(e,g){if(!c[e]){if(!k[e]){var h="function"==typeof require&&require;if(!g&&h)return h(e,!0);if(d)return d(e,!0);g=Error("Cannot find module '"+e+"'");throw g.code="MODULE_NOT_FOUND",g;}g=c[e]={exports:{}};k[e][0].call(g.exports,function(a){return f(k[e][1][a]||a)},g,g.exports,b,k,c,a)}return c[e].exports}for(var d="function"==typeof require&&require,e=0;e<a.length;e++)f(a[e]);return f}return b})()({1:[function(b,k,c){(function(a,c){var d=b("fflate");a.NrrdLoader3D=
function(){a.Loader3D.call(this);this.imgBufferArray=null};a.NrrdLoader3D.prototype=Object.create(a.Loader3D.prototype);a.NrrdLoader3D.prototype.constructor=a.NrrdLoader3D;a.NrrdLoader3D.prototype.getImageDims=function(a){return $jscomp.asyncExecutePromiseGeneratorProgram(function(b){return b.return(new Promise(function(b,c){try{var d=new FileReader;d.onerror=function(a){c(a)};d.onload=function(){try{var a=null,e=0,f=null,h=new Uint8Array(d.result.slice(0,Math.pow(2,24)));for(e=1;e<h.length;e++)if(10==
h[e-1]&&10==h[e]){a=(new TextDecoder).decode(h.subarray(0,e-2));break}a||c("Could not find header.");var g=a.split(/\r?\n/);for(e=0;e<g.length;e++){var l=g[e];if(!l.match(/^#/)&&(f=l.match(/(.*):(.*)/))&&"sizes"==f[1].trim()){var m=f[2].trim().split(/\s+/).map(function(a){return parseInt(a,10)});b(m);return}}c("Could not find image dimensions in header.")}catch(r){c(r)}};a instanceof FileSystemFileHandle?a.getFile().then(function(a){d.readAsArrayBuffer(a)}).catch(function(a){c(a)}):d.readAsArrayBuffer(a)}catch(n){c(n)}}))})};
a.NrrdLoader3D.prototype.loadImagesIntoVolume=function(a,b,c,d){var e=[];Array.prototype.push.apply(e,a);this.vol=b;this.warnings=this.errors=null;this.done=!1;this.loadCompleteCb=c;this.loadProgressCb=d;if(e&&e.length)if(e.some(function(a){return!(a instanceof FileSystemFileHandle)&&!(a instanceof File)}))this.done=!0,this.errors="NrrdLoader3D: Invalid item in file list.",this.loadCompleteCb&&this.loadCompleteCb(this);else{var f=new FileReader;f.onload=function(){this._onImageDataLoaded(f)}.bind(this);
f.onerror=function(){this._onImageLoadingError(f)}.bind(this);this.loadProgressCb&&this.loadProgressCb(0,1);a=e[0];a instanceof FileSystemFileHandle?a.getFile().then(function(a){f.readAsArrayBuffer(a)}).catch(function(a){this._onImageLoadingError(f)}.bind(this)):f.readAsArrayBuffer(a)}else this.done=!0,this.warnings="NrrdLoader3D: No files were loaded, because the supplied file list was empty.",this.loadCompleteCb&&this.loadCompleteCb(this)};a.NrrdLoader3D.prototype._onImageLoadingError=function(a){this.cancelled||
this.done||(this.done=!0,this.errors="Error loading image file "+(a.fileName||""),this.loadCompleteCb&&this.loadCompleteCb(this))};a.NrrdLoader3D.prototype._onImageDataLoaded=function(a){var b=this,c,e,f,k,p,u,q,t,z,v,r,y,J,I,Q,L,A,K,V,N,ha,ea,X,P,F,W,M,R,O,na;return $jscomp.asyncExecutePromiseGeneratorProgram(function(g){switch(g.nextAddress){case 1:if(b.cancelled)return g.return();g.setCatchFinallyBlocks(2);f=new Uint8Array(a.result);k=null;for(c=1;c<f.length;c++)if(10==f[c-1]&&10==f[c]){k=(new TextDecoder).decode(f.subarray(0,
c-2));break}if(!k)return b.done=!0,b.errors="Nrrd header not found.",b.loadCompleteCb&&b.loadCompleteCb(b),g.return();p=c+1;u=-1;q=0;t=-1;z="raw";v="little";r=[1,1,1];y=[[1,0,0],[0,1,0],[0,0,1]];J=[0,0,0];I=!1;Q=k.split(/\r?\n/);for(c=0;c<Q.length;c++)if(L=Q[c],L.match(/NRRD\d+/))I=!0;else if(!L.match(/^#/)&&(e=L.match(/(.*):(.*)/)))switch(A=e[1].trim(),K=e[2].trim(),A){case "type":V=$jscomp.makeIterator(b._interpretPixelType(K));u=V.next().value;V.next();q=V.next().value;break;case "dimension":t=
parseInt(K,10);break;case "sizes":N=K.split(/\s+/);r=N.map(function(a){return parseInt(a,10)});break;case "space directions":ha=K.match(/\(.*?\)/g);y=ha.map(function(a){return a.slice(1,-1).split(/,/).map(function(a){return parseFloat(a)})});break;case "spacings":N=K.split(/\s+/);N.map(function(a){return parseFloat(a)});break;case "space origin":J=K.split("(")[1].split(")")[0].split(",");J=J.map(function(a){return parseFloat(a)});break;case "encoding":z=K;break;case "endian":v=K}if(!I)return b.done=
!0,b.errors="Not a valid nrrd file.",b.loadCompleteCb&&b.loadCompleteCb(b),g.return();if(0>u||8!=u&&16!=u||2!=t&&3!=t)return b.done=!0,b.errors="Unsupported data type",b.loadCompleteCb&&b.loadCompleteCb(b),g.return();2==t&&(r=[r[0],r[1],1],y=[[y[0][0],y[0][1],0],[y[1][0],y[1][1],0],[0,0,1]],J=[J[0],J[1],0]);b.errors=b.vol.loadBegin(r,u,v);if(b.errors)return b.done=!0,b.loadCompleteCb&&b.loadCompleteCb(b),g.return();ea=f.subarray(p);X="raw"==z?ea:d.decompressSync(ea);P=8==u?X:new Uint16Array(X.buffer);
b.vol.setAttr("modality","nrrd");b.vol.setAttr("rescaleSlope",1);b.vol.setAttr("rescaleIntercept",0);b.vol.setAttr("dataOffset",q);b.vol.setAttr("sliceGap",1);b.vol.setAttr("rowDir",y[0]);b.vol.setAttr("colDir",y[1]);b.vol.calcNearLphAxes();F=r[2];W=r[0]*r[1];b.imgBufferArray=Array(4);M=8==u?4:2;R=0;case 4:if(!(R<F)){g.leaveTryBlock(0);break}M=Math.min(M,b.vol.dims[2]-R);O={startIndex:R,endIndex:R+M,numLeftToLoad:M,imgBuffers:b.imgBufferArray};c=0;case 7:if(!(c<M)){g.jumpTo(9);break}na=O.startIndex+
c;O.imgBuffers[c]=P.slice(na*W,(na+1)*W).buffer;O.numLeftToLoad--;if(0===O.numLeftToLoad&&(b._copyImagesToTexture(O),O.endIndex==b.vol.dims[2]&&!b.done))return b.vol.loadEnd(),b.done=!0,b.loadCompleteCb&&b.loadCompleteCb(b),g.return();if(!b.loadProgressCb){g.jumpTo(8);break}b.loadProgressCb(O.endIndex-O.numLeftToLoad,b.vol.dims[2]);return g.yield(new Promise(function(a){return setTimeout(a,5)}),11);case 11:if(b.cancelled)return g.return();case 8:c++;g.jumpTo(7);break;case 9:R+=M;g.jumpTo(4);break;
case 2:g.enterCatchBlock(),b._onImageLoadingError(a),g.jumpToEnd()}})};a.NrrdLoader3D.prototype._interpretPixelType=function(a){var b=-1,c=!1,d=0;switch(a){case "uchar":case "unsigned char":case "uint8":case "uint8_t":b=8;break;case "signed char":case "int8":case "int8_t":b=8;c=!0;d=Math.pow(2,b-1);break;case "ushort":case "unsigned short":case "unsigned short int":case "uint16":case "uint16_t":b=16;break;case "short":case "short int":case "signed short":case "signed short int":case "int16":case "int16_t":b=
16;c=!0;d=Math.pow(2,b-1);break;case "uint":case "unsigned int":case "uint32":case "uint32_t":b=32;break;case "int":case "signed int":case "int32":case "int32_t":b=32,c=!0,d=Math.pow(2,b-1)}return[b,c,d]}})(window.BigLime=window.BigLime||{})},{fflate:2}],2:[function(b,k,c){function a(a,b){"function"==typeof a&&(b=a,a={});this.ondata=b;return a}function f(a,b,c){c||(c=b,b={});"function"!=typeof c&&x(7);return oa(a,b,[pa],function(a){return ia(d(a.data[0],a.data[1]))},0,c)}function d(a,b){return la(a,
b||{},0,0)}function e(a,b,c){c||(c=b,b={});"function"!=typeof c&&x(7);return oa(a,b,[qa],function(a){return ia(h(a.data[0],Ka(a.data[1])))},1,c)}function h(a,b){return xa(a,{i:2},b&&b.out,b&&b.dictionary)}function g(a,b,c){c||(c=b,b={});"function"!=typeof c&&x(7);return oa(a,b,[pa,cb,function(){return[l]}],function(a){return ia(l(a.data[0],a.data[1]))},2,c)}function l(a,b){b||(b={});var c=ra(),d=a.length;c.p(a);a=la(a,b,La(b),8);var e=a.length;return Ma(a,b),E(a,e-8,c.d()),E(a,e-4,d),a}function m(a,
b,c){c||(c=b,b={});"function"!=typeof c&&x(7);return oa(a,b,[qa,db,function(){return[n]}],function(a){return ia(n(a.data[0],a.data[1]))},3,c)}function n(a,b){var c=Na(a);c+8>a.length&&x(6,"invalid gzip data");return xa(a.subarray(c,-8),{i:2},b&&b.out||new r(eb(a)),b&&b.dictionary)}function p(a,b){b||(b={});var c=Aa();c.p(a);a=la(a,b,b.dictionary?6:2,4);return Oa(a,b),E(a,a.length-4,c.d()),a}function u(a,b,c){c||(c=b,b={});"function"!=typeof c&&x(7);return oa(a,b,[qa,fb,function(){return[q]}],function(a){return ia(q(a.data[0],
Ka(a.data[1])))},5,c)}function q(a,b){return xa(a.subarray(Pa(a,b&&b.dictionary),-4),{i:2},b&&b.out,b&&b.dictionary)}function t(a,b){if(b){b=new r(a.length);for(var c=0;c<a.length;++c)b[c]=a.charCodeAt(c);return b}if(gb)return gb.encode(a);var d=a.length,e=new r(a.length+(a.length>>1)),f=0,w=function(a){e[f++]=a};for(c=0;c<d;++c){if(f+5>e.length){var g=new r(f+8+(d-c<<1));g.set(e);e=g}g=a.charCodeAt(c);128>g||b?w(g):(2048>g?w(192|g>>6):55295<g&&57344>g?(g=65536+(g&1047552)|a.charCodeAt(++c)&1023,
w(240|g>>18),w(128|g>>12&63),w(128|g>>6&63)):(w(224|g>>12),w(128|g>>6&63)),w(128|g&63))}return aa(e,0,f)}function z(a,b){if(b){b="";for(var c=0;c<a.length;c+=16384)b+=String.fromCharCode.apply(null,a.subarray(c,c+16384));return b}if(Qa)return Qa.decode(a);b=hb(a);a=b.s;b=b.r;b.length&&x(8);return a}var v=b("./node-worker.cjs"),r=Uint8Array,y=Uint16Array,J=Int32Array,I=new r([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Q=new r([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,
11,11,12,12,13,13,0,0]),L=new r([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),A=function(a,b){for(var c=new y(31),d=0;31>d;++d)c[d]=b+=1<<a[d-1];a=new J(c[30]);for(d=1;30>d;++d)for(b=c[d];b<c[d+1];++b)a[b]=b-c[d]<<5|d;return{b:c,r:a}},K=A(I,2),V=K.b,N=K.r;V[28]=258;N[258]=28;for(var ha=A(Q,0),ea=ha.b,X=ha.r,P=new y(32768),F=0;32768>F;++F){var W=(F&43690)>>1|(F&21845)<<1;W=(W&52428)>>2|(W&13107)<<2;W=(W&61680)>>4|(W&3855)<<4;P[F]=((W&65280)>>8|(W&255)<<8)>>1}var M=function(a,b,c){for(var d=a.length,
e=0,f=new y(b);e<d;++e)a[e]&&++f[a[e]-1];var w=new y(b);for(e=1;e<b;++e)w[e]=w[e-1]+f[e-1]<<1;if(c)for(c=new y(1<<b),f=15-b,e=0;e<d;++e){if(a[e]){var g=e<<4|a[e],h=b-a[e],G=w[a[e]-1]++<<h;for(h=G|(1<<h)-1;G<=h;++G)c[P[G]>>f]=g}}else for(c=new y(d),e=0;e<d;++e)a[e]&&(c[e]=P[w[a[e]-1]++]>>15-a[e]);return c},R=new r(288);for(F=0;144>F;++F)R[F]=8;for(F=144;256>F;++F)R[F]=9;for(F=256;280>F;++F)R[F]=7;for(F=280;288>F;++F)R[F]=8;var O=new r(32);for(F=0;32>F;++F)O[F]=5;var na=M(R,9,0),$a=M(R,9,1),ab=M(O,
5,0),bb=M(O,5,1),Ba=function(a){for(var b=a[0],c=1;c<a.length;++c)a[c]>b&&(b=a[c]);return b},ba=function(a,b,c){var d=b/8|0;return(a[d]|a[d+1]<<8)>>(b&7)&c},Ca=function(a,b){var c=b/8|0;return(a[c]|a[c+1]<<8|a[c+2]<<16)>>(b&7)},sa=function(a){return(a+7)/8|0},aa=function(a,b,c){if(null==b||0>b)b=0;if(null==c||c>a.length)c=a.length;return new r(a.subarray(b,c))};c.FlateErrorCode={UnexpectedEOF:0,InvalidBlockType:1,InvalidLengthLiteral:2,InvalidDistance:3,StreamFinished:4,NoStreamHandler:5,InvalidHeader:6,
NoCallback:7,InvalidUTF8:8,ExtraFieldTooLong:9,InvalidDate:10,FilenameTooLong:11,StreamFinishing:12,InvalidZipData:13,UnknownCompressionMethod:14};var ib=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],x=function(a,b,c){b=Error(b||ib[a]);b.code=a;Error.captureStackTrace&&Error.captureStackTrace(b,
x);if(!c)throw b;return b},xa=function(a,b,c,d){var e=a.length,f=d?d.length:0;if(!e||b.f&&!b.l)return c||new r(0);var w=!c,g=w||2!=b.i,h=b.i;w&&(c=new r(3*e));var G=function(a){var b=c.length;a>b&&(a=new r(Math.max(2*b,a)),a.set(c),c=a)},S=b.f||0,l=b.p||0,m=b.b||0,k=b.l,n=b.d,D=b.m,p=b.n,q=8*e;do{if(!k){S=ba(a,l,1);var B=ba(a,l+1,3);l+=3;if(B)if(1==B)k=$a,n=bb,D=9,p=5;else if(2==B){D=ba(a,l,31)+257;n=ba(a,l+10,15)+4;k=D+ba(a,l+5,31)+1;l+=14;p=new r(k);var t=new r(19);for(B=0;B<n;++B)t[L[B]]=ba(a,
l+3*B,7);l+=3*n;B=Ba(t);n=(1<<B)-1;var u=M(t,B,1);for(B=0;B<k;)if(t=u[ba(a,l,n)],l+=t&15,t>>=4,16>t)p[B++]=t;else{var y=0,v=0;16==t?(v=3+ba(a,l,3),l+=2,y=p[B-1]):17==t?(v=3+ba(a,l,7),l+=3):18==t&&(v=11+ba(a,l,127),l+=7);for(;v--;)p[B++]=y}k=p.subarray(0,D);B=p.subarray(D);D=Ba(k);p=Ba(B);k=M(k,D,1);n=M(B,p,1)}else x(1);else{t=sa(l)+4;l=a[t-4]|a[t-3]<<8;B=t+l;if(B>e){h&&x(0);break}g&&G(m+l);c.set(a.subarray(t,B),m);b.b=m+=l;b.p=l=8*B;b.f=S;continue}if(l>q){h&&x(0);break}}g&&G(m+131072);t=(1<<D)-1;
u=(1<<p)-1;for(v=l;;v=l){y=k[Ca(a,l)&t];B=y>>4;l+=y&15;if(l>q){h&&x(0);break}y||x(2);if(256>B)c[m++]=B;else if(256==B){v=l;k=null;break}else{y=B-254;if(264<B){B-=257;var z=I[B];y=ba(a,l,(1<<z)-1)+V[B];l+=z}B=n[Ca(a,l)&u];z=B>>4;B||x(3);l+=B&15;B=ea[z];3<z&&(z=Q[z],B+=Ca(a,l)&(1<<z)-1,l+=z);if(l>q){h&&x(0);break}g&&G(m+131072);y=m+y;if(m<B)for(v=f-B,z=Math.min(B,y),0>v+m&&x(3);m<z;++m)c[m]=d[v+m];for(;m<y;++m)c[m]=c[m-B]}}b.l=k;b.p=v;b.b=m;b.f=S;k&&(S=1,b.m=D,b.d=n,b.n=p)}while(!S);return m!=c.length&&
w?aa(c,0,m):c.subarray(0,m)},fa=function(a,b,c){c<<=b&7;b=b/8|0;a[b]|=c;a[b+1]|=c>>8},ta=function(a,b,c){c<<=b&7;b=b/8|0;a[b]|=c;a[b+1]|=c>>8;a[b+2]|=c>>16},Ea=function(a,b){for(var c=[],d=0;d<a.length;++d)a[d]&&c.push({s:d,f:a[d]});var e=c.length;a=c.slice();if(!e)return{t:ja,l:0};if(1==e)return b=new r(c[0].s+1),b[c[0].s]=1,{t:b,l:1};c.sort(function(a,b){return a.f-b.f});c.push({s:-1,f:25001});d=c[0];var f=c[1],g=0,w=1,h=2;for(c[0]={s:-1,f:d.f+f.f,l:d,r:f};w!=e-1;)d=c[c[g].f<c[h].f?g++:h++],f=c[g!=
w&&c[g].f<c[h].f?g++:h++],c[w++]={s:-1,f:d.f+f.f,l:d,r:f};f=a[0].s;for(d=1;d<e;++d)a[d].s>f&&(f=a[d].s);var G=new y(f+1);w=Da(c[w-1],G,0);if(w>b){c=d=0;f=w-b;g=1<<f;for(a.sort(function(a,b){return G[b.s]-G[a.s]||a.f-b.f});d<e;++d)if(h=a[d].s,G[h]>b)c+=g-(1<<w-G[h]),G[h]=b;else break;for(c>>=f;0<c;)e=a[d].s,G[e]<b?c-=1<<b-G[e]++-1:++d;for(;0<=d&&c;--d)e=a[d].s,G[e]==b&&(--G[e],++c);w=b}return{t:new r(G),l:w}},Da=function(a,b,c){return-1==a.s?Math.max(Da(a.l,b,c+1),Da(a.r,b,c+1)):b[a.s]=c},Ra=function(a){for(var b=
a.length;b&&!a[--b];);for(var c=new y(++b),d=0,e=a[0],f=1,g=function(a){c[d++]=a},h=1;h<=b;++h)if(a[h]==e&&h!=b)++f;else{if(!e&&2<f){for(;138<f;f-=138)g(32754);2<f&&(g(10<f?f-11<<5|28690:f-3<<5|12305),f=0)}else if(3<f){g(e);for(--f;6<f;f-=6)g(8304);2<f&&(g(f-3<<5|8208),f=0)}for(;f--;)g(e);f=1;e=a[h]}return{c:c.subarray(0,d),n:b}},ua=function(a,b){for(var c=0,d=0;d<b.length;++d)c+=a[d]*b[d];return c},Sa=function(a,b,c){var d=c.length;b=sa(b+2);a[b]=d&255;a[b+1]=d>>8;a[b+2]=a[b]^255;a[b+3]=a[b+1]^255;
for(var e=0;e<d;++e)a[b+e+4]=c[e];return 8*(b+4+d)},Ta=function(a,b,c,d,e,f,g,h,l,m,k){fa(b,k++,c);++e[256];c=Ea(e,15);var w=c.t,G=c.l;c=Ea(f,15);var S=c.t,n=c.l;c=Ra(w);var D=c.c,p=c.n;c=Ra(S);for(var Y=c.c,q=c.n,ma=new y(19),H=0;H<D.length;++H)++ma[D[H]&31];for(H=0;H<Y.length;++H)++ma[Y[H]&31];H=Ea(ma,7);c=H.t;H=H.l;for(var Z=19;4<Z&&!c[L[Z-1]];--Z);var t=m+5<<3,r=ua(e,R)+ua(f,O)+g;e=ua(e,w)+ua(f,S)+g+14+3*Z+ua(ma,c)+2*ma[16]+3*ma[17]+7*ma[18];if(0<=l&&t<=r&&t<=e)return Sa(b,k,a.subarray(l,l+m));
fa(b,k,1+(e<r));k+=2;if(e<r){a=M(w,G,0);l=w;m=M(S,n,0);w=M(c,H,0);fa(b,k,p-257);fa(b,k+5,q-1);fa(b,k+10,Z-4);k+=14;for(H=0;H<Z;++H)fa(b,k+3*H,c[L[H]]);k+=3*Z;p=[D,Y];for(Y=0;2>Y;++Y)for(q=p[Y],H=0;H<q.length;++H)D=q[H]&31,fa(b,k,w[D]),k+=c[D],15<D&&(fa(b,k,q[H]>>5&127),k+=q[H]>>12)}else a=na,l=R,m=ab,S=O;for(H=0;H<h;++H)c=d[H],255<c?(D=c>>18&31,ta(b,k,a[D+257]),k+=l[D+257],7<D&&(fa(b,k,c>>23&31),k+=I[D]),D=c&31,ta(b,k,m[D]),k+=S[D],3<D&&(ta(b,k,c>>5&8191),k+=Q[D])):(ta(b,k,a[c]),k+=l[c]);ta(b,k,a[256]);
return k+l[256]},jb=new J([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),ja=new r(0),kb=function(a,b,c,d,e,f){var g=f.z||a.length,h=new r(d+g+5*(1+Math.ceil(g/7E3))+e),w=h.subarray(d,h.length-e),G=f.l,l=(f.r||0)&7;if(b){l&&(w[0]=f.r>>3);var S=jb[b-1];b=S>>13;S&=8191;var m=(1<<c)-1,k=f.p||new y(32768),n=f.h||new y(m+1),D=Math.ceil(c/3),p=2*D,H=function(b){return(a[b]^a[b+1]<<D^a[b+2]<<p)&m},q=new J(25E3),Y=new y(288),t=new y(32),u=0,v=0;c=f.i||0;for(var z=0,x=f.w||0,A=0;c+2<g;++c){var E=
H(c),L=c&32767,F=n[E];k[L]=F;n[E]=L;if(x<=c){var K=g-c;if((7E3<u||24576<z)&&(423<K||!G)){l=Ta(a,w,0,q,Y,t,v,z,A,c-A,l);z=u=v=0;A=c;for(var C=0;286>C;++C)Y[C]=0;for(C=0;30>C;++C)t[C]=0}var M=2,P=0,R=S,O=L-F&32767;if(2<K&&E==H(c-O)){E=Math.min(b,K)-1;var V=Math.min(32767,c);for(K=Math.min(258,K);O<=V&&--R&&L!=F;){if(a[c+M]==a[c+M-O]){for(C=0;C<K&&a[c+C]==a[c+C-O];++C);if(C>M){M=C;P=O;if(C>E)break;L=Math.min(O,C-2);var T=0;for(C=0;C<L;++C){var U=c-O+C&32767,W=U-k[U]&32767;W>T&&(T=W,F=U)}}}L=F;F=k[L];
O+=L-F&32767}}P?(q[z++]=268435456|N[M]<<18|X[P],x=N[M]&31,P=X[P]&31,v+=I[x]+Q[P],++Y[257+x],++t[P],x=c+M,++u):(q[z++]=a[c],++Y[a[c]])}}for(c=Math.max(c,x);c<g;++c)q[z++]=a[c],++Y[a[c]];l=Ta(a,w,G,q,Y,t,v,z,A,c-A,l);G||(f.r=l&7|w[l/8|0]<<3,l-=7,f.h=n,f.p=k,f.i=c,f.w=x)}else{for(c=f.w||0;c<g+G;c+=65535)b=c+65535,b>=g&&(w[l/8|0]=G,b=g),l=Sa(w,l+1,a.subarray(c,b));f.i=g}return aa(h,0,d+sa(l)+e)},lb=function(){for(var a=new Int32Array(256),b=0;256>b;++b){for(var c=b,d=9;--d;)c=(c&1&&-306674912)^c>>>1;
a[b]=c}return a}(),ra=function(){var a=-1;return{p:function(b){for(var c=a,d=0;d<b.length;++d)c=lb[c&255^b[d]]^c>>>8;a=c},d:function(){return~a}}},Aa=function(){var a=1,b=0;return{p:function(c){for(var d=a,e=b,f=c.length|0,g=0;g!=f;){for(var h=Math.min(g+2655,f);g<h;++g)e+=d+=c[g];d=(d&65535)+15*(d>>16);e=(e&65535)+15*(e>>16)}a=d;b=e},d:function(){a%=65521;b%=65521;return(a&255)<<24|(a&65280)<<8|(b&255)<<8|b>>8}}},la=function(a,b,c,d,e){if(!e&&(e={l:1},b.dictionary)){var f=b.dictionary.subarray(-32768),
g=new r(f.length+a.length);g.set(f);g.set(a,f.length);a=g;e.w=f.length}return kb(a,null==b.level?6:b.level,null==b.mem?e.l?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(a.length)))):20:12+b.mem,c,d,e)},ya=function(a,b){var c={},d;for(d in a)c[d]=a[d];for(d in b)c[d]=b[d];return c},mb=function(a,b,c){var d=a();a=a.toString();a=a.slice(a.indexOf("[")+1,a.lastIndexOf("]")).replace(/\s+/g,"").split(",");for(var e=0;e<d.length;++e){var f=d[e],g=a[e];if("function"==typeof f){b+=";"+g+"=";var h=f.toString();
if(f.prototype)if(-1!=h.indexOf("[native code]"))f=h.indexOf(" ",8)+1,b+=h.slice(f,h.indexOf("(",f));else{b+=h;for(var w in f.prototype)b+=";"+g+".prototype."+w+"="+f.prototype[w].toString()}else b+=h}else c[g]=f}return b},Fa=[],nb=function(a,b,c,d){if(!Fa[c]){for(var e="",f={},g=a.length-1,h=0;h<g;++h)e=mb(a[h],e,f);Fa[c]={c:mb(a[g],e,f),e:f}}a=ya({},Fa[c].e);e=(0,v.default);b=Fa[c].c+";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage="+b.toString()+"}";f=[];for(var w in a)a[w].buffer&&
f.push((a[w]=new a[w].constructor(a[w])).buffer);return e(b,c,a,f,d)},qa=function(){return[r,y,J,I,Q,L,V,ea,$a,bb,P,ib,M,Ba,ba,Ca,sa,aa,x,xa,h,ia,Ka]},pa=function(){return[r,y,J,I,Q,L,N,X,na,R,ab,O,P,jb,ja,M,fa,ta,Ea,Da,Ra,ua,Sa,Ta,sa,aa,kb,la,d,ia]},cb=function(){return[Ma,La,E,ra,lb]},db=function(){return[Na,eb]},ob=function(){return[Oa,E,Aa]},fb=function(){return[Pa]},ia=function(a){return postMessage(a,[a.buffer])},Ka=function(a){return a&&{out:a.size&&new r(a.size),dictionary:a.dictionary}},
oa=function(a,b,c,d,e,f){var g=nb(c,d,e,function(a,b){g.terminate();f(a,b)});g.postMessage([a,b],b.consume?[a.buffer]:[]);return function(){g.terminate()}},ca=function(a){a.ondata=function(a,b){return postMessage([a,b],[a.buffer])};return function(b){b.data.length?(a.push(b.data[0],b.data[1]),postMessage([b.data[0].length])):a.flush()}},va=function(a,b,c,d,e,f,g){var h,w=nb(a,d,e,function(a,c){if(a)w.terminate(),b.ondata.call(b,a);else if(Array.isArray(c))if(1==c.length){if(b.queuedSize-=c[0],b.ondrain)b.ondrain(c[0])}else c[1]&&
w.terminate(),b.ondata.call(b,a,c[0],c[1]);else g(c)});w.postMessage(c);b.queuedSize=0;b.push=function(a,c){b.ondata||x(5);if(h)b.ondata(x(4,0,1),null,!!c);b.queuedSize+=a.length;w.postMessage([a,h=c],[a.buffer])};b.terminate=function(){w.terminate()};f&&(b.flush=function(){w.postMessage([])})},T=function(a,b){return a[b]|a[b+1]<<8},C=function(a,b){return(a[b]|a[b+1]<<8|a[b+2]<<16|a[b+3]<<24)>>>0},Ua=function(a,b){return C(a,b)+4294967296*C(a,b+4)},E=function(a,b,c){for(;c;++b)a[b]=c,c>>>=8},Ma=function(a,
b){var c=b.filename;a[0]=31;a[1]=139;a[2]=8;a[8]=2>b.level?4:9==b.level?2:0;a[9]=3;0!=b.mtime&&E(a,4,Math.floor(new Date(b.mtime||Date.now())/1E3));if(c)for(a[3]=8,b=0;b<=c.length;++b)a[b+10]=c.charCodeAt(b)},Na=function(a){31==a[0]&&139==a[1]&&8==a[2]||x(6,"invalid gzip data");var b=a[3],c=10;b&4&&(c+=(a[10]|a[11]<<8)+2);for(var d=(b>>3&1)+(b>>4&1);0<d;d-=!a[c++]);return c+(b&2)},eb=function(a){var b=a.length;return(a[b-4]|a[b-3]<<8|a[b-2]<<16|a[b-1]<<24)>>>0},La=function(a){return 10+(a.filename?
a.filename.length+1:0)},Oa=function(a,b){var c=b.level;a[0]=120;a[1]=(0==c?0:6>c?1:9==c?3:2)<<6|(b.dictionary&&32);a[1]|=31-(a[0]<<8|a[1])%31;b.dictionary&&(c=Aa(),c.p(b.dictionary),E(a,2,c.d()))},Pa=function(a,b){(8!=(a[0]&15)||7<a[0]>>4||(a[0]<<8|a[1])%31)&&x(6,"invalid zlib data");(a[1]>>5&1)==+!b&&x(6,"invalid zlib data: "+(a[1]&32?"need":"unexpected")+" dictionary");return(a[1]>>3&4)+2},da=function(){function a(a,b){"function"==typeof a&&(b=a,a={});this.ondata=b;this.o=a||{};this.s={l:0,i:32768,
w:32768,z:32768};this.b=new r(98304);this.o.dictionary&&(a=this.o.dictionary.subarray(-32768),this.b.set(a,32768-a.length),this.s.i=32768-a.length)}a.prototype.p=function(a,b){this.ondata(la(a,this.o,0,0,this.s),b)};a.prototype.push=function(a,b){this.ondata||x(5);this.s.l&&x(4);var c=a.length+this.s.z;c>this.b.length?(c>2*this.b.length-32768&&(c=new r(c&-32768),c.set(this.b.subarray(0,this.s.z)),this.b=c),c=this.b.length-this.s.z,this.b.set(a.subarray(0,c),this.s.z),this.s.z=this.b.length,this.p(this.b,
!1),this.b.set(this.b.subarray(-32768)),this.b.set(a.subarray(c),32768),this.s.z=a.length-c+32768,this.s.i=32766,this.s.w=32768):(this.b.set(a,this.s.z),this.s.z+=a.length);this.s.l=b&1;if(this.s.z>this.s.w+8191||b)this.p(this.b,b||!1),this.s.w=this.s.i,this.s.i-=2};a.prototype.flush=function(){this.ondata||x(5);this.s.l&&x(4);this.p(this.b,!1);this.s.w=this.s.i;this.s.i-=2};return a}();c.Deflate=da;var pb=function(){return function(b,c){va([pa,function(){return[ca,da]}],this,a.call(this,b,c),function(a){a=
new da(a.data);onmessage=ca(a)},6,1)}}();c.AsyncDeflate=pb;c.deflate=f;c.deflateSync=d;var U=function(){function a(a,b){"function"==typeof a&&(b=a,a={});this.ondata=b;a=a&&a.dictionary&&a.dictionary.subarray(-32768);this.s={i:0,b:a?a.length:0};this.o=new r(32768);this.p=new r(0);a&&this.o.set(a)}a.prototype.e=function(a){this.ondata||x(5);this.d&&x(4);if(!this.p.length)this.p=a;else if(a.length){var b=new r(this.p.length+a.length);b.set(this.p);b.set(a,this.p.length);this.p=b}};a.prototype.c=function(a){this.s.i=
+(this.d=a||!1);a=this.s.b;var b=xa(this.p,this.s,this.o);this.ondata(aa(b,a,this.s.b),this.d);this.o=aa(b,this.s.b-32768);this.s.b=this.o.length;this.p=aa(this.p,this.s.p/8|0);this.s.p&=7};a.prototype.push=function(a,b){this.e(a);this.c(b)};return a}();c.Inflate=U;var Va=function(){return function(b,c){va([qa,function(){return[ca,U]}],this,a.call(this,b,c),function(a){a=new U(a.data);onmessage=ca(a)},7,0)}}();c.AsyncInflate=Va;c.inflate=e;c.inflateSync=h;var Ga=function(){function a(a,b){this.c=
ra();this.l=0;this.v=1;da.call(this,a,b)}a.prototype.push=function(a,b){this.c.p(a);this.l+=a.length;da.prototype.push.call(this,a,b)};a.prototype.p=function(a,b){a=la(a,this.o,this.v&&La(this.o),b&&8,this.s);this.v&&(Ma(a,this.o),this.v=0);b&&(E(a,a.length-8,this.c.d()),E(a,a.length-4,this.l));this.ondata(a,b)};a.prototype.flush=function(){da.prototype.flush.call(this)};return a}();c.Gzip=Ga;c.Compress=Ga;var qb=function(){return function(b,c){va([pa,cb,function(){return[ca,da,Ga]}],this,a.call(this,
b,c),function(a){a=new Ga(a.data);onmessage=ca(a)},8,1)}}();c.AsyncGzip=qb;c.AsyncCompress=qb;c.gzip=g;c.compress=g;c.gzipSync=l;c.compressSync=l;var Ha=function(){function a(a,b){this.v=1;this.r=0;U.call(this,a,b)}a.prototype.push=function(a,b){U.prototype.e.call(this,a);this.r+=a.length;if(this.v){a=this.p.subarray(this.v-1);var c=3<a.length?Na(a):4;if(c>a.length){if(!b)return}else if(1<this.v&&this.onmember)this.onmember(this.r-a.length);this.p=a.subarray(c);this.v=0}U.prototype.c.call(this,b);
!this.s.f||this.s.l||b||(this.v=sa(this.s.p)+9,this.s={i:0},this.o=new r(0),this.push(new r(0),b))};return a}();c.Gunzip=Ha;var rb=function(){return function(b,c){var d=this;va([qa,db,function(){return[ca,U,Ha]}],this,a.call(this,b,c),function(a){a=new Ha(a.data);a.onmember=function(a){return postMessage(a)};onmessage=ca(a)},9,0,function(a){return d.onmember&&d.onmember(a)})}}();c.AsyncGunzip=rb;c.gunzip=m;c.gunzipSync=n;var Wa=function(){function a(a,b){this.c=Aa();this.v=1;da.call(this,a,b)}a.prototype.push=
function(a,b){this.c.p(a);da.prototype.push.call(this,a,b)};a.prototype.p=function(a,b){a=la(a,this.o,this.v&&(this.o.dictionary?6:2),b&&4,this.s);this.v&&(Oa(a,this.o),this.v=0);b&&E(a,a.length-4,this.c.d());this.ondata(a,b)};a.prototype.flush=function(){da.prototype.flush.call(this)};return a}();c.Zlib=Wa;var Cb=function(){return function(b,c){va([pa,ob,function(){return[ca,da,Wa]}],this,a.call(this,b,c),function(a){a=new Wa(a.data);onmessage=ca(a)},10,1)}}();c.AsyncZlib=Cb;c.zlib=function(a,b,
c){c||(c=b,b={});"function"!=typeof c&&x(7);return oa(a,b,[pa,ob,function(){return[p]}],function(a){return ia(p(a.data[0],a.data[1]))},4,c)};c.zlibSync=p;var Ia=function(){function a(a,b){U.call(this,a,b);this.v=a&&a.dictionary?2:1}a.prototype.push=function(a,b){U.prototype.e.call(this,a);if(this.v){if(6>this.p.length&&!b)return;this.p=this.p.subarray(Pa(this.p,this.v-1));this.v=0}b&&(4>this.p.length&&x(6,"invalid zlib data"),this.p=this.p.subarray(0,-4));U.prototype.c.call(this,b)};return a}();c.Unzlib=
Ia;var sb=function(){return function(b,c){va([qa,fb,function(){return[ca,U,Ia]}],this,a.call(this,b,c),function(a){a=new Ia(a.data);onmessage=ca(a)},11,0)}}();c.AsyncUnzlib=sb;c.unzlib=u;c.unzlibSync=q;var Xa=function(){function b(b,c){this.o=a.call(this,b,c)||{};this.G=Ha;this.I=U;this.Z=Ia}b.prototype.i=function(){var a=this;this.s.ondata=function(b,c){a.ondata(b,c)}};b.prototype.push=function(a,b){this.ondata||x(5);if(this.s)this.s.push(a,b);else{if(this.p&&this.p.length){var c=new r(this.p.length+
a.length);c.set(this.p);c.set(a,this.p.length)}else this.p=a;2<this.p.length&&(this.s=31==this.p[0]&&139==this.p[1]&&8==this.p[2]?new this.G(this.o):8!=(this.p[0]&15)||7<this.p[0]>>4||(this.p[0]<<8|this.p[1])%31?new this.I(this.o):new this.Z(this.o),this.i(),this.s.push(this.p,b),this.p=null)}};return b}();c.Decompress=Xa;var Db=function(){function a(a,b){Xa.call(this,a,b);this.queuedSize=0;this.G=rb;this.I=Va;this.Z=sb}a.prototype.i=function(){var a=this;this.s.ondata=function(b,c,d){a.ondata(b,
c,d)};this.s.ondrain=function(b){a.queuedSize-=b;if(a.ondrain)a.ondrain(b)}};a.prototype.push=function(a,b){this.queuedSize+=a.length;Xa.prototype.push.call(this,a,b)};return a}();c.AsyncDecompress=Db;c.decompress=function(a,b,c){c||(c=b,b={});"function"!=typeof c&&x(7);return 31==a[0]&&139==a[1]&&8==a[2]?m(a,b,c):8!=(a[0]&15)||7<a[0]>>4||(a[0]<<8|a[1])%31?e(a,b,c):u(a,b,c)};c.decompressSync=function(a,b){return 31==a[0]&&139==a[1]&&8==a[2]?n(a,b):8!=(a[0]&15)||7<a[0]>>4||(a[0]<<8|a[1])%31?h(a,b):
q(a,b)};var Ya=function(a,b,c,d){for(var e in a){var f=a[e],g=b+e,h=d;Array.isArray(f)&&(h=ya(d,f[1]),f=f[0]);f instanceof r?c[g]=[f,h]:(c[g+="/"]=[new r(0),h],Ya(f,g,c,d))}},gb="undefined"!=typeof TextEncoder&&new TextEncoder,Qa="undefined"!=typeof TextDecoder&&new TextDecoder,tb=0;try{Qa.decode(ja,{stream:!0}),tb=1}catch(G){}var hb=function(a){for(var b="",c=0;;){var d=a[c++],e=(127<d)+(223<d)+(239<d);if(c+e>a.length)return{s:b,r:aa(a,c-1)};e?3==e?(d=((d&15)<<18|(a[c++]&63)<<12|(a[c++]&63)<<6|a[c++]&
63)-65536,b+=String.fromCharCode(55296|d>>10,56320|d&1023)):b=e&1?b+String.fromCharCode((d&31)<<6|a[c++]&63):b+String.fromCharCode((d&15)<<12|(a[c++]&63)<<6|a[c++]&63):b+=String.fromCharCode(d)}},Eb=function(){function a(a){this.ondata=a;tb?this.t=new TextDecoder:this.p=ja}a.prototype.push=function(a,b){this.ondata||x(5);b=!!b;if(this.t)this.ondata(this.t.decode(a,{stream:!0}),b),b&&(this.t.decode().length&&x(8),this.t=null);else{this.p||x(4);var c=new r(this.p.length+a.length);c.set(this.p);c.set(a,
this.p.length);c=hb(c);a=c.s;c=c.r;b?(c.length&&x(8),this.p=null):this.p=c;this.ondata(a,b)}};return a}();c.DecodeUTF8=Eb;var Fb=function(){function a(a){this.ondata=a}a.prototype.push=function(a,b){this.ondata||x(5);this.d&&x(4);this.ondata(t(a),this.d=b||!1)};return a}();c.EncodeUTF8=Fb;c.strToU8=t;c.strFromU8=z;var ub=function(a){return 1==a?3:6>a?2:9==a?1:0},vb=function(a,b){return b+30+T(a,b+26)+T(a,b+28)},xb=function(a,b,c){var d=T(a,b+28),e=z(a.subarray(b+46,b+46+d),!(T(a,b+8)&2048));d=b+46+
d;var f=C(a,b+20),g=c&&4294967295==f?wb(a,d):[f,C(a,b+24),C(a,b+42)];c=g[0];f=g[1];g=g[2];return[T(a,b+10),c,f,e,d+T(a,b+30)+T(a,b+32),g]},wb=function(a,b){for(;1!=T(a,b);b+=4+T(a,b+2));return[Ua(a,b+12),Ua(a,b+4),Ua(a,b+20)]},ka=function(a){var b=0;if(a)for(var c in a){var d=a[c].length;65535<d&&x(9);b+=d+4}return b},wa=function(a,b,c,d,e,f,g,h){var l=d.length,m=c.extra,k=h&&h.length,n=ka(m);E(a,b,null!=g?33639248:67324752);b+=4;null!=g&&(a[b++]=20,a[b++]=c.os);a[b]=20;b+=2;a[b++]=c.flag<<1|(0>f&&
8);a[b++]=e&&8;a[b++]=c.compression&255;a[b++]=c.compression>>8;e=new Date(null==c.mtime?Date.now():c.mtime);var w=e.getFullYear()-1980;(0>w||119<w)&&x(10);E(a,b,w<<25|e.getMonth()+1<<21|e.getDate()<<16|e.getHours()<<11|e.getMinutes()<<5|e.getSeconds()>>1);b+=4;-1!=f&&(E(a,b,c.crc),E(a,b+4,0>f?-f-2:f),E(a,b+8,c.size));E(a,b+12,l);E(a,b+14,n);b+=16;null!=g&&(E(a,b,k),E(a,b+6,c.attrs),E(a,b+10,g),b+=14);a.set(d,b);b+=l;if(n)for(var p in m)c=m[p],d=c.length,E(a,b,+p),E(a,b+2,d),a.set(c,b+4),b+=4+d;k&&
(a.set(h,b),b+=k);return b},Za=function(a,b,c,d,e){E(a,b,101010256);E(a,b+8,c);E(a,b+10,c);E(a,b+12,d);E(a,b+16,e)},za=function(){function a(a){this.filename=a;this.c=ra();this.compression=this.size=0}a.prototype.process=function(a,b){this.ondata(null,a,b)};a.prototype.push=function(a,b){this.ondata||x(5);this.c.p(a);this.size+=a.length;b&&(this.crc=this.c.d());this.process(a,b||!1)};return a}();c.ZipPassThrough=za;var Gb=function(){function a(a,b){var c=this;b||(b={});za.call(this,a);this.d=new da(b,
function(a,b){c.ondata(null,a,b)});this.compression=8;this.flag=ub(b.level)}a.prototype.process=function(a,b){try{this.d.push(a,b)}catch(D){this.ondata(D,null,b)}};a.prototype.push=function(a,b){za.prototype.push.call(this,a,b)};return a}();c.ZipDeflate=Gb;var Hb=function(){function a(a,b){var c=this;b||(b={});za.call(this,a);this.d=new pb(b,function(a,b,d){c.ondata(a,b,d)});this.compression=8;this.flag=ub(b.level);this.terminate=this.d.terminate}a.prototype.process=function(a,b){this.d.push(a,b)};
a.prototype.push=function(a,b){za.prototype.push.call(this,a,b)};return a}();c.AsyncZipDeflate=Hb;var Ib=function(){function a(a){this.ondata=a;this.u=[];this.d=1}a.prototype.add=function(a){var b=this;this.ondata||x(5);if(this.d&2)this.ondata(x(4+8*(this.d&1),0,1),null,!1);else{var c=t(a.filename),d=c.length,e=a.comment,f=e&&t(e);e=d!=a.filename.length||f&&e.length!=f.length;var g=d+ka(a.extra)+30;if(65535<d)this.ondata(x(11,0,1),null,!1);d=new r(g);wa(d,0,a,c,e,-1);var h=[d],l=function(){for(var a=
0,c=h;a<c.length;a++)b.ondata(null,c[a],!1);h=[]},m=this.d;this.d=0;var k=this.u.length,n=ya(a,{f:c,u:e,o:f,t:function(){a.terminate&&a.terminate()},r:function(){l();if(m){var a=b.u[k+1];a?a.r():b.d=1}m=1}}),p=0;a.ondata=function(c,d,e){c?(b.ondata(c,d,e),b.terminate()):(p+=d.length,h.push(d),e?(c=new r(16),E(c,0,134695760),E(c,4,a.crc),E(c,8,p),E(c,12,a.size),h.push(c),n.c=p,n.b=g+p+16,n.crc=a.crc,n.size=a.size,m&&n.r(),m=1):m&&l())};this.u.push(n)}};a.prototype.end=function(){var a=this;if(this.d&
2)this.ondata(x(4+8*(this.d&1),0,1),null,!0);else this.d?this.e():this.u.push({r:function(){a.d&1&&(a.u.splice(-1,1),a.e())},t:function(){}}),this.d=3};a.prototype.e=function(){for(var a=0,b=0,c=0,d=0,e=this.u;d<e.length;d++){var f=e[d];c+=46+f.f.length+ka(f.extra)+(f.o?f.o.length:0)}d=new r(c+22);e=0;for(var g=this.u;e<g.length;e++)f=g[e],wa(d,a,f,f.f,f.u,-f.c-2,b,f.o),a+=46+f.f.length+ka(f.extra)+(f.o?f.o.length:0),b+=f.b;Za(d,a,this.u.length,c,b);this.ondata(null,d,!0);this.d=2};a.prototype.terminate=
function(){for(var a=0,b=this.u;a<b.length;a++)b[a].t();this.d=2};return a}();c.Zip=Ib;c.zip=function(a,b,c){c||(c=b,b={});"function"!=typeof c&&x(7);var e={};Ya(a,"",e,b);var g=Object.keys(e),h=g.length,l=0,m=0,k=h,n=Array(h),p=[],w=function(){for(var a=0;a<p.length;++a)p[a]()},q=function(a,b){Ja(function(){c(a,b)})};Ja(function(){q=c});var G=function(){for(var a=new r(m+22),b=l,c=m-l,d=m=0;d<k;++d){var e=n[d];try{var f=e.c.length;wa(a,m,e,e.f,e.u,f);var g=30+e.f.length+ka(e.extra),h=m+g;a.set(e.c,
h);wa(a,l,e,e.f,e.u,f,m,e.m);l+=16+g+(e.m?e.m.length:0);m=h+f}catch(Ab){return q(Ab,null)}}Za(a,l,n.length,c,b);q(null,a)};h||G();a=function(a){var b=g[a],c=e[b],k=c[0],r=c[1],u=ra(),v=k.length;u.p(k);var y=t(b),z=y.length,D=r.comment,Z=D&&t(D),H=Z&&Z.length,S=ka(r.extra),A=0==r.level?0:8;c=function(c,d){c?(w(),q(c,null)):(c=d.length,n[a]=ya(r,{size:v,crc:u.d(),c:d,f:y,m:Z,u:z!=b.length||Z&&D.length!=H,compression:A}),l+=30+z+S+c,m+=76+2*(z+S)+(H||0)+c,--h||G())};65535<z&&c(x(11,0,1),null);if(A)if(16E4>
v)try{c(null,d(k,r))}catch(Bb){c(Bb,null)}else p.push(f(k,r,c));else c(null,k)};for(b=0;b<k;++b)a(b);return w};c.zipSync=function(a,b){b||(b={});var c={},e=[];Ya(a,"",c,b);var f=a=0;for(z in c){b=c[z];var g=b[0],h=b[1],l=0==h.level?0:8;b=t(z);var m=b.length,k=h.comment,n=k&&t(k),p=n&&n.length,q=ka(h.extra);65535<m&&x(11);var w=l?d(g,h):g,G=w.length,u=ra();u.p(g);e.push(ya(h,{size:g.length,crc:u.d(),c:w,f:b,m:n,u:m!=z.length||n&&k.length!=p,o:a,compression:l}));a+=30+m+q+G;f+=76+2*(m+q)+(p||0)+G}c=
new r(f+22);var z=a;f-=a;for(g=0;g<e.length;++g)b=e[g],wa(c,b.o,b,b.f,b.u,b.c.length),h=30+b.f.length+ka(b.extra),c.set(b.c,b.o+h),wa(c,a,b,b.f,b.u,b.c.length,b.o,b.m),a+=16+h+(b.m?b.m.length:0);Za(c,a,e.length,f,z);return c};var yb=function(){function a(){}a.prototype.push=function(a,b){this.ondata(null,a,b)};a.compression=0;return a}();c.UnzipPassThrough=yb;var Jb=function(){function a(){var a=this;this.i=new U(function(b,c){a.ondata(null,b,c)})}a.prototype.push=function(a,b){try{this.i.push(a,
b)}catch(D){this.ondata(D,null,b)}};a.compression=8;return a}();c.UnzipInflate=Jb;var Kb=function(){function a(a,b){var c=this;32E4>b?this.i=new U(function(a,b){c.ondata(null,a,b)}):(this.i=new Va(function(a,b,d){c.ondata(a,b,d)}),this.terminate=this.i.terminate)}a.prototype.push=function(a,b){this.i.terminate&&(a=aa(a,0));this.i.push(a,b)};a.compression=8;return a}();c.AsyncUnzipInflate=Kb;var Lb=function(){function a(a){this.onfile=a;this.k=[];this.o={0:yb};this.p=ja}a.prototype.push=function(a,
b){var c=this;this.onfile||x(5);this.p||x(4);if(0<this.c){var d=Math.min(this.c,a.length),e=a.subarray(0,d);this.c-=d;this.d?this.d.push(e,!this.c):this.k[0].push(e);a=a.subarray(d);if(a.length)return this.push(a,b)}else{var f=0,g=0,h=void 0,l=void 0;this.p.length?a.length?(l=new r(this.p.length+a.length),l.set(this.p),l.set(a,this.p.length)):l=this.p:l=a;var m=l.length,k=this.c;a=k&&this.d;d=function(){var a=C(l,g);if(67324752==a){f=1;h=g;n.d=null;n.c=0;var b=T(l,g+6),d=T(l,g+8);a=b&2048;var e=b&
8,p=T(l,g+26);b=T(l,g+28);if(m>g+30+p+b){var q=[];n.k.unshift(q);f=2;var r=C(l,g+18),t=C(l,g+22),w=z(l.subarray(g+30,g+=30+p),!a);4294967295==r?(a=e?[-2]:wb(l,g),r=a[0],t=a[1]):e&&(r=-1);g+=b;n.c=r;var u,v={name:w,compression:d,start:function(){v.ondata||x(5);if(r){var a=c.o[d];if(!a)v.ondata(x(14,"unknown compression type "+d,1),null,!1);u=0>r?new a(w):new a(w,r,t);u.ondata=function(a,b,c){v.ondata(a,b,c)};for(a=0;a<q.length;a++)u.push(q[a],!1);c.k[0]==q&&c.c?c.d=u:u.push(ja,!0)}else v.ondata(null,
ja,!0)},terminate:function(){u&&u.terminate&&u.terminate()}};0<=r&&(v.size=r,v.originalSize=t);n.onfile(v)}return"break"}if(k){if(134695760==a)return h=g+=12+(-2==k&&8),f=3,n.c=0,"break";if(33639248==a)return h=g-=4,f=3,n.c=0,"break"}};for(var n=this;g<m-4&&"break"!==d();++g);this.p=ja;0>k&&(d=f?l.subarray(0,h-12-(-2==k&&8)-(134695760==C(l,h-16)&&4)):l.subarray(0,g),a?a.push(d,!!f):this.k[+(2==f)].push(d));if(f&2)return this.push(l.subarray(g),b);this.p=l.subarray(g)}b&&(this.c&&x(13),this.p=null)};
a.prototype.register=function(a){this.o[a.compression]=a};return a}();c.Unzip=Lb;var Ja="function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout?setTimeout:function(a){a()};c.unzip=function(a,b,c){c||(c=b,b={});"function"!=typeof c&&x(7);var d=[],f=function(){for(var a=0;a<d.length;++a)d[a]()},g={},l=function(a,b){Ja(function(){c(a,b)})};Ja(function(){l=c});for(var m=a.length-22;101010256!=C(a,m);--m)if(!m||65558<a.length-m)return l(x(13,0,1),null),f;var k=T(a,m+8);if(k){var n=
k,p=C(a,m+16),q=4294967295==p||65535==n;q&&(m=C(a,m-12),q=101075792==C(a,m))&&(n=k=C(a,m+32),p=C(a,m+48));var t=b&&b.filter;b=function(b){var c=xb(a,p,q),m=c[0];b=c[1];var n=c[2],u=c[3],v=c[4];c=vb(a,c[5]);p=v;v=function(a,b){a?(f(),l(a,null)):(b&&(g[u]=b),--k||l(null,g))};if(!t||t({name:u,size:b,originalSize:n,compression:m}))if(m)if(8==m)if(m=a.subarray(c,c+b),524288>n||b>.8*n)try{v(null,h(m,{out:new r(n)}))}catch(zb){v(zb,null)}else d.push(e(m,{size:n},v));else v(x(14,"unknown compression type "+
m,1),null);else v(null,aa(a,c,c+b));else v(null,null)};for(m=0;m<n;++m)b(m)}else l(null,{});return f};c.unzipSync=function(a,b){for(var c={},d=a.length-22;101010256!=C(a,d);--d)(!d||65558<a.length-d)&&x(13);var e=T(a,d+8);if(!e)return{};var f=C(a,d+16),g=4294967295==f||65535==e;g&&(d=C(a,d-12),g=101075792==C(a,d))&&(e=C(a,d+32),f=C(a,d+48));b=b&&b.filter;for(d=0;d<e;++d){var l=xb(a,f,g),m=l[0],k=l[1],n=l[2],p=l[3];f=l[4];l=vb(a,l[5]);if(!b||b({name:p,size:k,originalSize:n,compression:m}))m?8==m?c[p]=
h(a.subarray(l,l+k),{out:new r(n)}):x(14,"unknown compression type "+m):c[p]=aa(a,l,l+k)}return c}},{"./node-worker.cjs":3}],3:[function(b,k,c){var a={};c.default=function(b,c,e,h,g){b=new Worker(a[c]||(a[c]=URL.createObjectURL(new Blob([b+';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'],{type:"text/javascript"}))));b.onmessage=function(a){var b=a.data;(a=b.$e$)?(b=Error(a[0]),b.code=a[1],b.stack=a[2],g(b,null)):g(null,b)};b.postMessage(e,h);return b}},
{}]},{},[1]);
(function(b,k){var c=glMatrix.vec2;b.OpacityControl=function(a,c,d){this.graphAreaColor="#a0a0a0";this.toolsAreaColor="#c0c0c0";this.presets=d;this._buildUi(a,c,d);this.opacityCurve=d?b.OpacityCurve.FromString(d[0].opacityCurveStr):new b.OpacityCurve;this.activePtIndex=0;this.colorPicker.value=b.Color.ToHexString(this.opacityCurve.curvePts[this.activePtIndex]);this._drawGraph();this.graphInteractor=new b.Interactor(this.canvas,"opgraph",{btns:0,shift:k,ctrl:k,alt:!1});this.graphInteractor.addEventListener("start move end",this._onGraphInteract.bind(this));
this.canvas.addEventListener(b.Utils.isTouchDevice()?"touchend":"mouseup",this._onGraphClick.bind(this))};b.OpacityControl.prototype._buildUi=function(a,c,d){var e=b.Ui;this.mainDiv=e.CreateElement("div","opcontrol_maindiv",null,{width:a,height:c});c-=50;this.graphDiv=e.CreateElement("div","opcontrol_graphdiv",this.mainDiv,{width:a,height:c});this.toolsDiv=e.CreateElement("div","opcontrol_toolsdiv",this.mainDiv,{width:a-2,height:50,bottom:0,border:"1px solid #909090"});this.canvas=e.CreateElement("canvas",
"opcontrol_canvas",this.graphDiv,{width:a,height:c},{width:a,height:c,borderWidth:6});this.canvas.addEventListener("contextmenu",function(a){a.preventDefault()});this.colorPicker=e.CreateElement("input","opcontrol_colorpicker",this.toolsDiv,{width:75,height:30,left:20,top:10},{type:"color",value:"#ffffff"});this.colorPicker.addEventListener("change",this._onColorSelected.bind(this));e.CreateElement("label","opcontrol_colorpicker_label",this.toolsDiv,{left:110,top:16},{innerHTML:"Point color"});if(d){this.presetSelector=
e.CreateElement("select","opcontrol_presetselector",this.toolsDiv,{width:140,height:30,right:80,top:10,fontSize:16},{val:"0"});for(a=0;a<d.length;a++)e.CreateElement("option","opcontrol_presetoption",this.presetSelector,{},{value:a.toString(),text:d[a].name});this.presetSelector.addEventListener("change",function(){this.trigger("preset-selected",{val:this.presetSelector.selectedIndex})}.bind(this));e.CreateElement("label","opcontrol_presetselector_label",this.toolsDiv,{right:20,top:16},{innerHTML:"Preset"})}};
b.OpacityControl.prototype.setOpacityCurve=function(a,b){this.opacityCurve.setControlPoints(a.controlPts);this._drawGraph();this.presets&&this._updatePresetSelector();b||this.trigger("opacity-change",{opCurve:this.opacityCurve})};b.OpacityControl.prototype.setPresets=function(a){for(;0<this.presetSelector.options.length;)this.presetSelector.remove(0);a.forEach(function(a,c){b.Ui.CreateElement("option","3dcon_presetoption",this.presetSelector,{},{value:c.toString(),text:a.name})}.bind(this))};b.OpacityControl.prototype._updatePresetSelector=
function(){if(this.presets){for(var a=this.opacityCurve.toString(),b=-1,c=0;c<this.presets.length;c++)if(this.presets[c].opacityCurveStr==a){b=c;break}this.presetSelector.selectedIndex!=b&&(this.presetSelector.selectedIndex=b)}};b.OpacityControl.prototype._onColorSelected=function(){if(null!==this.activePtIndex){var a=this.opacityCurve.curvePts[this.activePtIndex];if(a){var c=b.Color.FromHexString(this.colorPicker.value);a.r=c.r;a.g=c.g;a.b=c.b;this.opacityCurve._updateControlPointsFromCurvePoints()}this._drawGraph();
this.trigger("opacity-change",{opCurve:this.opacityCurve})}};b.OpacityControl.prototype._onGraphInteract=function(a){if("start"==a.type){if(b.Utils.isTouchDevice()||0===a.detail.origEvent.button){var f=this._hitTest(this.graphInteractor.currPoint);if(null!==f){this.activePtIndex=f;this.draggingCurve=!0;this.colorPicker.value=b.Color.ToHexString(this.opacityCurve.curvePts[this.activePtIndex]);this.alphaStart=this.opacityCurve.curvePts[this.activePtIndex].a;for(this.leftPtIndex=this.indxStart=this.activePtIndex;0<
this.leftPtIndex&&!this.opacityCurve.curvePts[this.leftPtIndex-1];)this.leftPtIndex--;for(this.rightPtIndex=this.activePtIndex;this.rightPtIndex<this.opacityCurve.numPoints()-1&&!this.opacityCurve.curvePts[this.rightPtIndex+1];)this.rightPtIndex++;this._drawGraph();this.trigger("opacity-change-start")}}}else if("move"==a.type){if(this.draggingCurve){f=c.create();if(a.detail.origEvent.ctrlKey||a.detail.origEvent.metaKey){c.subtract(f,this._windowPointToCurvePoint(this.graphInteractor.currPoint),this._windowPointToCurvePoint(this.graphInteractor.prevPoint));
a.detail.origEvent.shiftKey&&c.scale(f,f,.2);a=this.opacityCurve.controlPts;var d=a.length/2;if(3<d&&(f=Math.round(f[0]),f=0<f?Math.min(f,Math.max(0,b.OpacityCurve.NumPoints-1-a[2*d-4]-10)):Math.max(f,Math.min(0,-(a[2]-10))),0!=f)){for(var e=2;e<2*d-2;e+=2)a[e]+=f;this.opacityCurve.setControlPoints(a)}}else c.subtract(f,this._windowPointToCurvePoint(this.graphInteractor.currPoint),this._windowPointToCurvePoint(this.graphInteractor.startPoint)),a.detail.origEvent.shiftKey&&c.scale(f,f,.2),a=this.opacityCurve.curvePts,
a[this.activePtIndex].a=Math.max(0,Math.min(255,Math.round(this.alphaStart+f[1]))),0!==this.activePtIndex&&this.activePtIndex!==this.opacityCurve.numPoints()-1&&(f=Math.max(this.leftPtIndex,Math.min(this.rightPtIndex,Math.round(this.indxStart+f[0]))),f!=this.activePtIndex&&(a[f]=a[this.activePtIndex],a[this.activePtIndex]=null,this.activePtIndex=f));this.opacityCurve._updateControlPointsFromCurvePoints();this._drawGraph();this.trigger("opacity-change",{opCurve:this.opacityCurve})}}else"end"==a.type&&
this.draggingCurve&&(this.trigger("opacity-change-end"),this.draggingCurve=!1)};b.OpacityControl.prototype._onGraphClick=function(a){var c=b.Utils.isTouchDevice();if(c||2===a.button)if(!c||a.originalEvent&&a.originalEvent.targetTouches&&a.originalEvent.targetTouches.length){a.preventDefault();c=b.Interactor._getEventCoordinates(a);a=this.canvas.getBoundingClientRect();c=[c[0]-a.left,c[1]-a.top];a=this.opacityCurve.curvePts;var d=this.opacityCurve.numPoints(),e=!1,h=this._hitTest(c);if(h&&h!=d-1)a[h]=
null,this.activePtIndex=0,this.colorPicker.value=b.Color.ToHexString(a[0]),e=!0;else if(c=this._windowPointToCurvePoint(c),!a[c[0]]){e=0;for(d=c[0]-1;0<=d;d--)if(a[d]){e=a[d];break}e=new b.Color(e.r,e.g,e.b,c[1]);a[c[0]]=e;this.activePtIndex=c[0];this.colorPicker.value=b.Color.ToHexString(e);e=!0}e&&(this.opacityCurve._updateControlPointsFromCurvePoints(),this._drawGraph(),this.trigger("opacity-change",{opCurve:this.opacityCurve}))}};b.OpacityControl.prototype._hitTest=function(a){a=this._windowPointToCurvePoint(a);
for(var b=this.opacityCurve.curvePts,c=b.length,e=256/c*(this.canvas.width/this.canvas.height),h=Number.MAX_SAFE_INTEGER,g=-1,l=0;l<c;l++)if(b[l]){var m=(l-a[0])*e,k=b[l].a-a[1];m=m*m+k*k;m<h&&(h=m,g=l)}return 10>Math.sqrt(h)?g:null};b.OpacityControl.prototype._windowPointToCurvePoint=function(a){var b=this.canvas.borderWidth,c=this.canvas.width-2*b,e=this.canvas.height-2*b,h=this.opacityCurve.numPoints()-1;c=Math.round((a[0]-b)*h/c);c=Math.max(0,Math.min(h,c));a=Math.round(255*(this.canvas.height-
1-a[1]-b)/e);a=Math.max(0,Math.min(255,a));return[c,a]};b.OpacityControl.prototype._drawGraph=function(){var a=this.canvas.getContext("2d"),c=this.canvas.width,d=this.canvas.height,e=this.canvas.borderWidth,h=c-2*e,g=d-2*e;a.clearRect(0,0,c,d);a.beginPath();a.fillStyle=this.graphAreaColor;a.fillRect(0,0,c,d);a.beginPath();a.strokeStyle="#606060";a.rect(0,0,c,d);a.stroke();a.rect(e,e,c-2*e,d-2*e);a.stroke();c=this.opacityCurve.controlPts;for(var l=b.OpacityCurve.NumPoints,m,k,p,u=0;u<c.length;u+=2){var q=
c[u],t=c[u+1],z=b.Color.ToHexString(t),v=e+q/(l-1)*h;t=d-(e+t.a/255*g);q=q==this.activePtIndex?6:4;a.beginPath();a.arc(v,t,q,0,2*Math.PI,!0);a.fillStyle=z;a.fill();if(m||0===m)q=a.createLinearGradient(m,k,v,t),q.addColorStop(0,p),q.addColorStop(1,z),a.strokeStyle=q,a.beginPath(),a.moveTo(m,k),a.lineTo(v,t),a.stroke();m=v;k=t;p=z}};b.OpacityControl.prototype.addEventListener=function(a,c){b.Notifier.prototype.addEventListener.call(this,a,c)};b.OpacityControl.prototype.removeEventListener=function(a,
c){b.Notifier.prototype.removeEventListener.call(this,a,c)};b.OpacityControl.prototype.trigger=function(a,c){b.Notifier.prototype.trigger.call(this,a,c)}})(window.BigLime=window.BigLime||{});
(function(b,k){b.OpacityCurve=function(c){var a=b.OpacityCurve.NumPoints;this.curvePts=Array(a);this.controlPts=[];c=c||[0,new b.Color(255,255,255,0),a/4,new b.Color(255,180,140,0),3*a/4,new b.Color(255,255,255,240),a-1,new b.Color(255,255,255,240)];this.setControlPoints(c);this.rgbaBuf=new Uint8Array(4*a)};b.OpacityCurve.NumPoints=1024;b.OpacityCurve.prototype.clone=function(){return new b.OpacityCurve(this.controlPts)};b.OpacityCurve.prototype.updateFrom=function(b){this.setControlPoints(b.controlPts)};
b.OpacityCurve.prototype.numPoints=function(){return this.curvePts.length};b.OpacityCurve.prototype.setControlPoints=function(c){this.controlPts=[];for(var a=0;a<this.curvePts.length;a++)this.curvePts[a]=null;for(a=0;a<c.length;a+=2)this.controlPts.push(c[a]),this.controlPts.push(b.Color.Clone(c[a+1])),this.curvePts[c[a]]=b.Color.Clone(c[a+1])};b.OpacityCurve.prototype.copyToTexture=function(c){if(c.width!=this.curvePts.length)b.Logger.Report("OpacityCurve.copyToTexture: Invalid texture size.",b.Logger.Severity.Error);
else{for(var a=this.curvePts,f=a.length,d=0,e=1,h=a[0]||new b.Color(0,0,0,0);e<f;){var g=a[e];g||e!=f-1||(g=new b.Color(0,0,0,0));if(g){for(var l=d;l<=e;l++){var m=(l-d)/(e-d);this.rgbaBuf[4*l]=Math.round(h.r+m*(g.r-h.r));this.rgbaBuf[4*l+1]=Math.round(h.g+m*(g.g-h.g));this.rgbaBuf[4*l+2]=Math.round(h.b+m*(g.b-h.b));this.rgbaBuf[4*l+3]=Math.round(h.a+m*(g.a-h.a))}d=e;h=g}e++}a=c.context.gl;c.bind();a.texSubImage2D(a.TEXTURE_2D,0,0,0,f,1,a.RGBA,a.UNSIGNED_BYTE,this.rgbaBuf);a.texSubImage2D(a.TEXTURE_2D,
0,0,1,f,1,a.RGBA,a.UNSIGNED_BYTE,this.rgbaBuf)}};b.OpacityCurve.prototype.toString=function(){for(var b="",a=this.controlPts,f=0;f<a.length;f+=2)b+="["+a[f].toString()+"]"+a[f+1].toString()+(f<a.length-2?"; ":"");return b};b.OpacityCurve.FromString=function(c){var a=null;try{var f=c.trim().split(";");c=[];for(var d=0;d<f.length;d++){var e=f[d],h=e.indexOf("["),g=e.indexOf("]"),l=parseInt(e.substring(h+1,g)),m=b.Color.FromString(e.substring(g+1));c.push(l,m)}a=new b.OpacityCurve(c)}catch(n){b.Logger.Report("OpacityCurve.FromString: Invalid input string",
b.Logger.Severity.Error)}return a};b.OpacityCurve.prototype._updateControlPointsFromCurvePoints=function(){this.controlPts=[];for(var c=0;c<this.curvePts.length;c++)this.curvePts[c]&&(this.controlPts.push(c),this.controlPts.push(b.Color.Clone(this.curvePts[c])))}})(window.BigLime=window.BigLime||{});
(function(b,k){b.ReliefMask=function(c,a,f,d){this.context=c;this.width=Math.round(f);this.height=Math.round(d);f=this.context.gl;this.texture=new b.Texture2D(c,a,this.width,this.height,f.RGBA,f.LINEAR);this.dataBuffer=new ArrayBuffer(4*this.width*this.height);this.dataView=new DataView(this.dataBuffer);this.dataBuffer8=new Uint8Array(this.dataBuffer);this.copyDataToTexture()};b.ReliefMask.prototype.destroy=function(){this.context&&(this.texture.destroy(),this.context=this.texture=null)};b.ReliefMask.prototype.copyDataToTexture=
function(b){b=b===k?null:b;var a=this.context.gl;this.texture.bind();var c=b?Math.max(0,b[0]):0,d=b?Math.min(this.height-c,b[1]-c+1):this.height;b=b?this.dataBuffer8.subarray(c*this.width*4,(c+d)*this.width*4):this.dataBuffer8;a.texSubImage2D(a.TEXTURE_2D,0,0,c,this.width,d,a.RGBA,a.UNSIGNED_BYTE,b)}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=b.Logger.Severity,a=glMatrix.vec3,f=glMatrix.vec4,d=glMatrix.mat4;b.RenderEngine=function(a){a=a===k?{}:a;this.canvas=a.canvas||b.Ui.CreateElement("canvas","renderengine_canvas",null,{width:100,height:100,background:"black"});this.ctx=new b.GLContext(this.canvas,a.options);this.volume=null;this.shaders={};this.frameBuffers={};this.vertexBuffers={};this.lutTexture=null;this.prevOpacityCurve="";this.loader=null;this.pickMode=this.loadingData=!1;this.shadowMapRez=.5;this.transforms=
{model:d.create(),view:d.create(),mvp:d.create(),mvpInv:d.create(),shadowMvp:[d.create(),d.create()],shadowMvpInv:[d.create(),d.create()]};a=this.ctx;this.volume=1==a.glVersion?new b.VolumeT2(a,a.GlMaxTextures-2):new b.VolumeT3(a,0);this.renderParams=new b.RenderParams;this.renderParams.slab=new b.Slab(this.volume);this.volume.setInterpType(this.renderParams.interpType);var c=a.gl;this.vertexBuffers.threed=a.createAttrBuffer(new b.Shapes3D.Cube(1),3);this.vertexBuffers.twod=a.createAttrBuffer(new b.Shapes3D.Rectangle(2,
2),3);this.frameBuffers.threed=new b.FrameBuffer(a,a.GlMaxTextures-1,this.canvas.width,this.canvas.height,c.RGBA,c.LINEAR,!1);this.frameBuffers.shadows=null;this.frameBuffers.gfx=null;this.lutTexture=new b.Texture2D(a,a.GlMaxTextures-2,b.OpacityCurve.NumPoints,16,c.RGBA,c.LINEAR);this._createColorMapLuts();this.mask=null;this.clearDisplay()};b.RenderEngine.prototype.destroy=function(){this.ctx&&(this.volume&&this.volume.destroy(),this.lutTexture&&this.lutTexture.destroy(),this.mask&&this.mask.destroy(),
Object.values(this.frameBuffers).forEach(function(a){a&&a.destroy()}),Object.values(this.vertexBuffers).forEach(function(a){a&&a.destroy()}),Object.values(this.shaders).forEach(function(a){a&&a.destroy()}),this.mask=this.volume=this.lutTexture=null,this.frameBuffers={},this.vertexBuffers={},this.shaders={},this.ctx=null)};b.RenderEngine.prototype.sizeRasterToMatch=function(a,b){b=b===k?1:b;var c=a.getBoundingClientRect();a=Math.round(b*c.width);c=Math.round(b*c.height);this.canvas.width!=a&&(this.canvas.width=
a);this.canvas.height!=c&&(this.canvas.height=c);this.frameBuffers.threed.resize(a,c);var d=this.renderParams;this.frameBuffers.gfx&&d.showGraphics&&this.frameBuffers.gfx.resize(2*a,2*c);this.frameBuffers.shadows&&d.lightSet.shadowsEnabled()&&(b=1>b?1:this.shadowMapRez,this.frameBuffers.shadows.resize(Math.round(b*a),2*Math.round(b*c)))};b.RenderEngine.prototype.clearDisplay=function(){var a=this.renderParams;a=a.renderType==b.RenderType.VR?a.vrBackColor||b.Color.Black():b.Color.Black();this.ctx.clearCanvas(a)};
b.RenderEngine.prototype.setShadowMapResolution=function(a){this.shadowMapRez!=a&&(this.shadowMapRez=a,this.frameBuffers.shadows&&this.frameBuffers.shadows.resize(Math.round(a*this.canvas.width),2*Math.round(a*this.canvas.height)))};b.RenderEngine.prototype.setRenderParams=function(a){this.renderParams=a};b.RenderEngine.prototype.loadVolume=function(a){a=a===k?{}:a;if(this.loadingData)b.Logger.Report("RenderEngine ignored an overlapping load request.",c.Warn),completionCb&&completionCb("RenderEngine ignored an overlapping load request.",
null,this);else{this.clearDisplay();this.frameBuffers.gfx&&this.frameBuffers.gfx.destroy();this.frameBuffers.shadows&&this.frameBuffers.shadows.destroy();this.mask&&this.mask.destroy();this.frameBuffers.shadows=null;this.mask=this.frameBuffers.gfx=null;this.ctx.setCurrentProgram(null);Object.values(this.shaders).forEach(function(a){a&&a.destroy()});this.shaders={};var d=this.loader=a.loader;d.clientData=d.clientData||{};d.clientData.renderEngineData={completionCb:a.completionCb};this.loadingData=
!0;if(d=d.loadImagesIntoVolume(a.imgFiles,this.volume,this._onVolumeLoaded.bind(this),a.progressCb))return b.Logger.Report(d,c.Error),this.loadingData=!1,a.completionCb&&a.completionCb(d,null,this),this.loader=null,d}};b.RenderEngine.prototype.cancelLoading=function(){this.loadingData&&(this.loadingData=!1,this.loader.cancelLoading(),this.loader=null)};b.RenderEngine.prototype._onVolumeLoaded=function(a){this.loadingData=!1;this.loader=null;var c=a.clientData.renderEngineData;if(a.errors)c.completionCb&&
c.completionCb(a.errors,a.warnings,this);else{try{var d=this.ctx,e=this.volume,f=d.GlMaxTextures-2-e.numTextures(),k=this.frameBuffers.threed.width,p=this.frameBuffers.threed.height;1<=f&&(this.frameBuffers.shadows=new b.FrameBuffer(d,d.GlMaxTextures-3,Math.round(this.shadowMapRez*k),2*Math.round(this.shadowMapRez*p),d.gl.RGBA,d.gl.LINEAR,!1));2<=f&&(this.frameBuffers.gfx=new b.FrameBuffer(d,d.GlMaxTextures-4,2*k,2*p,d.gl.RGBA,d.gl.LINEAR,!0));3<=f&&(this.mask=new b.ReliefMask(d,d.GlMaxTextures-5,
e.dims[0],e.dims[1]));this.baseRayStepSize=1/Math.max(e.dims[0],e.dims[1],e.dims[2],64)}catch(u){d="RenderEngine exception: "+u.message;c.completionCb&&c.completionCb(d,a.warnings,this);return}c.completionCb&&c.completionCb("",a.warnings,this)}};b.RenderEngine.prototype.hasImageData=function(){return this.volume.loaded};b.RenderEngine.prototype.animate=function(a,d){if(this.isAnimating())b.Logger.Report("RenderEngine: Overlapping animate request ignored.",c.Warn);else{var e=0<a?1E3/a:0,f=performance.now(),
h=d||this.render.bind(this),k=function(){if(0>=e)h();else{var a=performance.now();a-f>e&&(f=a,h())}this.animId=b.Utils.requestAnimFrame(k)}.bind(this);this.animId=b.Utils.requestAnimFrame(k)}};b.RenderEngine.prototype.stopAnimation=function(){this.isAnimating()&&(b.Utils.cancelAnimFrame(this.animId),this.animId=null)};b.RenderEngine.prototype.isAnimating=function(){return!!this.animId};b.RenderEngine.prototype.render=function(a){a=a===k?null:a;var c=this.volume;if(c.loaded&&!this.loadingData){var d=
this.renderParams;c.setInterpType(d.interpType);var e=this._getCurrentVolShaderNames(),f=e.vol;e=e.shadow;this.ctx.gl.enable(this.ctx.gl.CULL_FACE);this.updateTransforms();var n=d.slab?d.slab.getVerticesTx().map(function(a){return[].concat($jscomp.arrayFromIterable(a))}).flat():Array(24).fill(0),p=d.renderType==b.RenderType.VR,u=d.renderType==b.RenderType.XRAY;if(p||u)u=d.opacityCurve.toString(),u!=this.prevOpacityCurve&&(d.opacityCurve.copyToTexture(this.lutTexture),this.prevOpacityCurve=u);""!=
e&&this._renderShadowMaps(e,n);p&&this.frameBuffers.gfx&&d.showGraphics&&0<c.meshManager.numVisibleMeshes()&&this._renderGraphics();this._renderVolToFramebuffer(f,n);this._renderFramebufferToCanvas(a)}};b.RenderEngine.prototype._renderShadowMaps=function(a,c){var d=this.volume,e=d.getOpacityRange(),f=this.renderParams;a=this._useShader(a);a.setUniform("uBitsPerPixel",d.bpp);a.setUniform("uMosaicDims",d.txInfo?d.txInfo.mosaicDims:[1,1,1]);a.setUniform("uNumTextures",d.numTextures());a.setUniform("uVolShape",
d.shape);a.setUniform("uOpacityRange",[e[0],1/e[1]]);a.setUniform("uRayStepSize",this.baseRayStepSize);a.setUniform("uMaskEnabled",f.useMask);a.setUniform("uSlabInfo",c);a.setUniform("uVolNumImages",d.dims[2]);a.setAttribute("aPosition",this.vertexBuffers.threed);c=this.frameBuffers.shadows;d=c.width;e=c.height/2;for(var h=0;h<f.lightSet.dirLights.length;h++)0<f.lightSet.dirLights[h].shadowDarkness&&(a.setUniform("uShadowMvpTransform",this.transforms.shadowMvp[h]),a.setUniform("uShadowMvpInvTransform",
this.transforms.shadowMvpInv[h]),a.draw({target:c,clearColor:b.Color.White,viewport:[0,h*e,d,e]}))};b.RenderEngine.prototype._renderGraphics=function(){var a=this.volume;if(a.loaded&&!this.loadingData){var b=this._useShader("gfx");b.setUniform("uMvpTransform",this.transforms.mvp);b.setUniform("uMvpInvTransform",this.transforms.mvpInv);b.setUniform("uRotMatrix",this.renderParams.rotMatrix);b.setUniform("uPersp",this.renderParams.persp);var c=this.ctx.gl;c.bindFramebuffer(c.FRAMEBUFFER,this.frameBuffers.gfx.glFrameBuffer);
c.clearColor(1,1,1,1);c.clear(c.COLOR_BUFFER_BIT|c.DEPTH_BUFFER_BIT);c.enable(c.DEPTH_TEST);for(var d=c.drawingBufferWidth,f=c.drawingBufferHeight,k=0;2>k;k++){var p=a.meshManager.numVisibleVertices(k);0<p&&(a.meshManager.activateMeshes(k,b),b.setUniform("uRenderDepthMap",!1),b.draw({numVertices:p,target:this.frameBuffers.gfx,clear:!1,viewport:[0,k*f,d,f]}),b.setUniform("uRenderDepthMap",!0),b.draw({numVertices:p,target:this.frameBuffers.gfx,clear:!1,viewport:[d,k*f,d,f]}))}c.disable(c.DEPTH_TEST)}};
b.RenderEngine.prototype._renderVolToFramebuffer=function(c,d){var e=this.volume;if(e.loaded&&!this.loadingData){var h=this.transforms,k=this.renderParams;c=this._useShader(c);c.setUniform("uModelTransform",h.model);c.setUniform("uViewTransform",h.view);c.setUniform("uMvpTransform",h.mvp);c.setUniform("uMvpInvTransform",h.mvpInv);c.setUniform("uRayStepSize",this.baseRayStepSize/k.rayOversamp);c.setUniform("uPersp",k.persp);c.setUniform("uMarkerLoc",k.markerLoc);c.setUniform("uMarkerSize",k.markerSize);
c.setUniform("uShowMarker",k.showMarker);c.setUniform("uMaskEnabled",k.useMask);c.setUniform("uSlabInfo",d);c.setUniform("uVolShape",e.shape);c.setUniform("uVolNumImages",e.dims[2]);c.setUniform("uBitsPerPixel",e.bpp);c.setUniform("uNumTextures",e.numTextures());c.setUniform("uMosaicDims",e.txInfo?e.txInfo.mosaicDims:[1,1,1]);c.setAttribute("aPosition",this.vertexBuffers.threed);if(d=k.renderType==b.RenderType.VR){if(e=e.getOpacityRange(),c.setUniform("uAntiAlias",k.antiAlias?1:0),c.setUniform("uGfxBlendWeight",
k.gfxBlendWeight),c.setUniform("uMarkerColor",b.Color.ScaleTo1(k.markerColor)),c.setUniform("uOpacityRange",[e[0],1/e[1]]),c.setUniform("uOutBufferSize",this.frameBuffers.threed.getSize()),c.setUniform("uSealBorders",k.sealBorders),c.setUniform("uShadowSampler",this.frameBuffers.shadows?this.frameBuffers.shadows.txIndex:-1),c.setUniform("uVrBackColor",b.Color.ScaleTo1(k.vrBackColor).slice(0,3)),!this.pickMode)for(c.setUniform("uAmbientLight",k.lightSet.ambientLight),e=0;e<k.lightSet.dirLights.length;e++){var n=
k.lightSet.dirLights[e],p="uLights["+e.toString()+"].";c.setUniform(p+"diffuse",n.diffuse);c.setUniform(p+"specStrength",n.specStrength);c.setUniform(p+"specExp",n.specExp);c.setUniform(p+"shadowDarkness",n.shadowDarkness);c.setUniform(p+"shadowSoftness",n.shadowSoftness);c.setUniform(p+"shadowMvp",h.shadowMvp[e]);n=f.fromValues(n.dir[0],n.dir[1],n.dir[2],0);f.normalize(n,f.transformMat4(n,n,h.mvpInv));c.setUniform(p+"dir",a.fromValues(n[0],n[1],n[2]))}}else k.renderType==b.RenderType.XRAY&&(e=e.getOpacityRange(),
c.setUniform("uOpacityRange",[e[0],1/e[1]]),c.setUniform("uUseLut",k.useXrayLut));h=d?k.vrBackColor||b.Color.Black():b.Color.Black();c.draw({target:this.frameBuffers.threed,clearColor:h})}};b.RenderEngine.prototype._renderFramebufferToCanvas=function(a){if(this.volume.loaded&&!this.loadingData){var c=this.ctx.gl,d=this.renderParams,e=this._useShader("winLevel");e.setInputTexture("uWLSampler",this.frameBuffers.threed.texture);e.setInputTexture("uLutSampler",this.lutTexture);e.setUniform("uWinWidth",
d.winWidth);e.setUniform("uWinLevel",d.winLevel);e.setUniform("uMarkerColor",b.Color.ScaleTo1(d.markerColor));e.setUniform("uPassThruMode",d.renderType==b.RenderType.VR?1:0);e.setUniform("uColorMapIndex",d.colorMapIndex);e.setAttribute("aPosition",this.vertexBuffers.twod);e.draw();a&&(a=a(this.transforms))&&(e=this._useShader("slab"),e.setUniform("uMvpTransform",this.transforms.mvp),e.setUniform("uPersp",d.persp),e.setAttribute("aPosition",a.vertexBuffer),e.setAttribute("aColor",a.attrBuffer),e.draw({clear:!1,
drawMode:c.LINES,numVertices:2*a.numLines}))}};b.RenderEngine.prototype._getCurrentVolShaderNames=function(){var a=this.volume;if(a.loaded&&!this.loadingData){var c=this.renderParams,d=c.renderType==b.RenderType.VR,f=c.renderType==b.RenderType.XRAY,k=d?"vr":f?"xray":"mip",n=c.clipToSlab?"_slab":"";f=!f&&c.showGraphics&&this.frameBuffers.gfx&&0<a.meshManager.numVisibleMeshes()?"_gfx":"";var p=d&&this.frameBuffers.shadows&&c.lightSet.shadowsEnabled()?"_shadows":"",u="";1===this.ctx.glVersion&&(c=c.interpType==
b.Interp3D.TriLinear?"lin":"nn",u=1>=a.numTextures()?"_st":"_mt",u="_"+a.bpp.toString()+"bit_"+c+u);return{vol:k+n+f+p+u,shadow:d?"shadows"+n+u:""}}};b.RenderEngine.prototype._useShader=function(a){a=this.shaders[a]||this._createShader(a);this.ctx.setCurrentProgram(a);return a};b.RenderEngine.prototype._createShader=function(a){var c=this.volume,d=this.ctx.glVersion.toString(),e=a.split("_"),f=e[0],k=b.ShaderCode[f+"_vert_"+d];d=b.ShaderCode[f+"_frag_"+d];var p="";-1!==a.indexOf("_slab")&&(p+="\n#define CLIP_TO_SLAB");
-1!==a.indexOf("_gfx")&&(p+="\n#define RENDER_GRAPHICS");-1!==a.indexOf("_shadows")&&(p+="\n#define RENDER_SHADOWS");if("vr"==f||"shadows"==f||"xray"==f||"winLevel"==f){var u=1/this.lutTexture.height;p+="\n#define LUT_TX_YOFFSET "+u.toString()+(0==u%1?".0":"")}if("winLevel"==f){u=256/this.lutTexture.width;var q=2/this.lutTexture.height;p+="\n#define LUT_TX_XSCALE "+u.toString()+(0==u%1?".0":"");p+="\n#define LUT_TX_YSCALE "+q.toString()+(0==q%1?".0":"")}1==this.ctx.glVersion&&(p+="\n#define PIXEL_LAYOUT_"+
e.slice(e.length-3).join("_").toUpperCase(),p+="\n#define NUM_IMAGE_TEXTURES "+c.numTextures());e={"//<<SYMBOL_DEFS>>//":p};k=new b.ShaderProgram(this.ctx,a,k,d,e,e,!0);this.shaders[a]=k;"vr"==f&&k.setInputTexture("uGfxSampler",this.frameBuffers.gfx?this.frameBuffers.gfx.texture:null);"vr"!=f&&"shadows"!=f&&"xray"!=f||k.setInputTexture("uLutSampler",this.lutTexture);if("vr"==f||"shadows"==f||"xray"==f||"mip"==f)k.setInputTexture("uMaskSampler",this.mask?this.mask.texture:null),2===this.ctx.glVersion?
k.setInputTexture("uVolumeSampler",c.texture):1==c.numTextures()?k.setInputTexture("uSampler",c.textures[0]):k.setInputTexture("uSamplers",c.textures);return k};b.RenderEngine.prototype.updateTransforms=function(){this.calcTransforms(this.renderParams,this.ctx.canvas,{result:this.transforms})};b.RenderEngine.prototype.calcTransforms=function(c,f,g){g=g===k?{omitLights:!1,result:null}:g;var e=g.result||{model:d.create(),view:d.create(),mvp:d.create(),mvpInv:d.create(),shadowMvp:g.omitLights?null:[d.create(),
d.create()],shadowMvpInv:g.omitLights?null:[d.create(),d.create()]};if(!this.volume.loaded)return e;var h=a.normalize(a.create(),this.volume.shape);a.scale(h,h,2);d.fromScaling(e.model,h);h=d.fromTranslation(d.create(),a.fromValues(-c.pan[0],-c.pan[1],0));var n=Array.isArray(c.zoom)?c.zoom:[c.zoom,c.zoom];n=d.fromScaling(d.create(),a.fromValues(n[0],n[1],1));d.multiply(e.view,n,d.multiply(d.create(),h,c.rotMatrix));f=f.height/f.width;f=d.fromScaling(d.create(),a.fromValues(Math.min(f,1),Math.min(1/
f,1),1));d.multiply(e.mvp,f,d.multiply(d.create(),e.view,e.model));d.invert(e.mvpInv,e.mvp);if(!g.omitLights&&c.renderType==b.RenderType.VR)for(g=0;g<c.lightSet.dirLights.length;g++){var p=c.lightSet.dirLights[g];if(0<p.shadowDarkness){h=e.shadowMvp[g];d.copy(h,e.model);n=d.clone(c.rotMatrix);p=a.cross(a.create(),a.fromValues(0,0,1),p.dir);var u=Math.asin(a.length(p));1E-4<Math.abs(u)&&(p=d.fromRotation(d.create(),-u,p),d.multiply(n,p,n));d.multiply(h,n,h);d.multiply(h,f,h);d.invert(e.shadowMvpInv[g],
h)}}return e};b.RenderEngine.prototype._createColorMapLuts=function(){var a=Math.min(257,this.lutTexture.width),b=this.lutTexture.context.gl,c=new Uint8Array(4*a);this.lutTexture.bind();var d,f,k=[];k.push([0,0,0,255]);k.push([1,1,171,255]);k.push([1,1,224,255]);k.push([0,110,255,255]);k.push([1,171,254,255]);k.push([1,224,254,255]);k.push([1,254,1,255]);k.push([190,255,0,255]);k.push([255,255,0,255]);k.push([255,224,0,255]);k.push([255,141,0,255]);k.push([250,94,0,255]);k.push([245,0,0,255]);k.push([245,
0,197,255]);k.push([222,180,222,255]);k.push([255,255,255,255]);k.push([255,255,255,255]);for(d=0;d<a;d++){var p=k[Math.floor(d/16)];for(f=0;4>f;f++)c[4*d+f]=p[f]}b.texSubImage2D(b.TEXTURE_2D,0,0,2,a,1,b.RGBA,b.UNSIGNED_BYTE,c);b.texSubImage2D(b.TEXTURE_2D,0,0,3,a,1,b.RGBA,b.UNSIGNED_BYTE,c)}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=glMatrix.vec2,a=glMatrix.vec3,f=glMatrix.mat4;b.RenderParams=function(d){this.antiAlias=!1;this.clipToSlab=!0;this.gfxBlendWeight=.5;this.interpType=b.Interp3D.TriLinear;this.lightSet=new b.LightSet;this.markerColor=b.Color.FromName("green");this.markerLoc=a.fromValues(.5,.5,.5);this.markerSize=.0075;this.opacityCurve=new b.OpacityCurve;this.pan=c.fromValues(0,0);this.persp=0;this.rayOversamp=1;this.renderType=b.RenderType.VR;this.rotMatrix=f.create();this.sealBorders=!1;this.showSlab=
this.showMarker=this.showGraphics=!0;this.slab=null;this.useMask=!1;this.colorMapIndex=0;this.useXrayLut=!1;this.vrBackColor=new b.Color(18,9,57);this.winLevel=0;this.zoom=this.winWidth=1;d&&this.updateFrom(d)};b.RenderParams.prototype.updateFrom=function(d){Object.hasOwn(d,"antiAlias")&&(this.antiAlias=d.antiAlias);Object.hasOwn(d,"clipToSlab")&&(this.clipToSlab=d.clipToSlab);Object.hasOwn(d,"gfxBlendWeight")&&(this.gfxBlendWeight=d.gfxBlendWeight);Object.hasOwn(d,"interpType")&&(this.interpType=
d.interpType);Object.hasOwn(d,"lightSet")&&this.lightSet.updateFrom(d.lightSet);Object.hasOwn(d,"markerColor")&&(this.markerColor=b.Color.Clone(d.markerColor));Object.hasOwn(d,"markerLoc")&&a.copy(this.markerLoc,d.markerLoc);Object.hasOwn(d,"markerSize")&&(this.markerSize=d.markerSize);Object.hasOwn(d,"pan")&&c.copy(this.pan,d.pan);Object.hasOwn(d,"persp")&&(this.persp=d.persp);Object.hasOwn(d,"rayOversamp")&&(this.rayOversamp=d.rayOversamp);Object.hasOwn(d,"renderType")&&(this.renderType=d.renderType);
Object.hasOwn(d,"rotMatrix")&&f.copy(this.rotMatrix,d.rotMatrix);Object.hasOwn(d,"sealBorders")&&(this.sealBorders=d.sealBorders);Object.hasOwn(d,"showGraphics")&&(this.showGraphics=d.showGraphics);Object.hasOwn(d,"showMarker")&&(this.showMarker=d.showMarker);Object.hasOwn(d,"showSlab")&&(this.showSlab=d.showSlab);Object.hasOwn(d,"useMask")&&(this.useMask=d.useMask);Object.hasOwn(d,"useXrayLut")&&(this.useXrayLut=d.useXrayLut);Object.hasOwn(d,"colorMapIndex")&&(this.colorMapIndex=d.colorMapIndex);
Object.hasOwn(d,"vrBackColor")&&(this.vrBackColor=b.Color.Clone(d.vrBackColor));Object.hasOwn(d,"winLevel")&&(this.winLevel=d.winLevel);Object.hasOwn(d,"winWidth")&&(this.winWidth=d.winWidth);Object.hasOwn(d,"opacityCurveStr")?this.opacityCurve.updateFrom(b.OpacityCurve.FromString(d.opacityCurveStr)):Object.hasOwn(d,"opacityCurve")&&this.opacityCurve.updateFrom(d.opacityCurve);Object.hasOwn(d,"slab")&&(this.slab?this.slab.updateFrom(d.slab):this.slab=d.slab.clone());Object.hasOwn(d,"zoom")&&(Array.isArray(d.zoom)?
Array.isArray(this.zoom)?c.copy(this.zoom,d.zoom):this.zoom=c.clone(d.zoom):Array.isArray(this.zoom)?c.set(this.zoom,d.zoom,d.zoom):this.zoom=d.zoom)}})(window.BigLime=window.BigLime||{});
(function(b,k){b.Settings=function(c){this.antiAlias=!1;this.interpType=b.Interp3D.TriLinear;this.lightSet=new b.LightSet;this.opacityCurveStr=(new b.OpacityCurve).toString();this.useXrayLut=!1;this.persp=this.colorMapIndex=0;this.rayOversamp=1;this.renderType=b.RenderType.VR;this.sealBorders=!1;this.vrBackColor=new b.Color(18,9,57);c&&this.updateFrom(c)};b.Settings.prototype.updateFrom=function(c){Object.hasOwn(c,"antiAlias")&&(this.antiAlias=c.antiAlias);Object.hasOwn(c,"interpType")&&(this.interpType=
c.interpType);Object.hasOwn(c,"lightSet")&&this.lightSet.updateFrom(c.lightSet);Object.hasOwn(c,"useXrayLut")&&(this.useXrayLut=c.useXrayLut);Object.hasOwn(c,"colorMapIndex")&&(this.colorMapIndex=c.colorMapIndex);Object.hasOwn(c,"persp")&&(this.persp=c.persp);Object.hasOwn(c,"rayOversamp")&&(this.rayOversamp=c.rayOversamp);Object.hasOwn(c,"renderType")&&(this.renderType=c.renderType);Object.hasOwn(c,"sealBorders")&&(this.sealBorders=c.sealBorders);Object.hasOwn(c,"vrBackColor")&&(this.vrBackColor=
b.Color.Clone(c.vrBackColor));Object.hasOwn(c,"opacityCurveStr")?this.opacityCurveStr=c.opacityCurveStr:Object.hasOwn(c,"opacityCurve")&&(this.opacityCurveStr=c.opacityCurve.toString())};b.Settings.prototype.matches=function(c){return this.antiAlias==c.antiAlias&&this.interpType==c.interpType&&this.lightSet.valueEquals(c.lightSet)&&this.opacityCurveStr==c.opacityCurve.toString()&&this.useXrayLut==c.useXrayLut&&this.colorMapIndex==c.colorMapIndex&&this.persp==c.persp&&this.rayOversamp==c.rayOversamp&&
this.renderType==c.renderType&&this.sealBorders==c.sealBorders&&b.Color.AreEqual(this.vrBackColor,c.vrBackColor)?!0:!1};b.Settings.prototype.toJsonString=function(){return JSON.stringify(this,function(b,a){return a.toFixed?Number(a.toFixed(8)):a},4)};b.Settings.FromJsonString=function(c){c=JSON.parse(c);var a=new b.Settings;a.updateFrom(c);a.name=c.name;return a}})(window.BigLime=window.BigLime||{});
(function(b,k){b.Shader=function(b,a,f,d,e,h){this.context=b;this.type=a;this.name=f||"";this.code="";this.glShader=null;this.isCompiled=!1;if(e)for(var c in e)e.hasOwnProperty(c)&&(d=d.split(c).join(e[c]));this.code=d;this.glShader=b.gl.createShader(this.type);b.gl.shaderSource(this.glShader,this.code);("undefined"===typeof h||h)&&this.compile()};b.Shader.prototype.destroy=function(){this.context&&(this.glShader&&this.context.gl.deleteShader(this.glShader),this.context=null,this.code="",this.glShader=
null,this.isCompiled=!1)};b.Shader.prototype.compile=function(){if(!this.isCompiled){var c=this.context.gl;c.compileShader(this.glShader);c.getShaderParameter(this.glShader,c.COMPILE_STATUS)||c.isContextLost()?this.isCompiled=!0:b.Logger.Report("Shader.compile: "+this.name+" compilation error(s):\n"+c.getShaderInfoLog(this.glShader),b.Logger.Severity.Error)}}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=b.Logger.Severity;b.ShaderProgram=function(a,c,d,e,h,g,l){this.context=a;this.name=c||"";this.glProgram=this.fShader=this.vShader=null;this.uniforms={};this.attributes={};this.numVertices=k;this.indexBuffer=null;this.isCompiled=!1;c=this.context.gl;this.vShader=new b.Shader(a,c.VERTEX_SHADER,this.name+"_vshader",d,h,l);this.fShader=new b.Shader(a,c.FRAGMENT_SHADER,this.name+"_fshader",e,g,l);this.glProgram=c.createProgram();c.attachShader(this.glProgram,this.vShader.glShader);
c.attachShader(this.glProgram,this.fShader.glShader);("undefined"===typeof l||l)&&this.compile()};b.ShaderProgram.prototype.destroy=function(){this.context&&(this.glProgram&&this.context.gl.deleteProgram(this.glProgram),this.vShader&&this.vShader.destroy(),this.fShader&&this.fShader.destroy(),this.fShader=this.vShader=this.glProgram=null,this.uniforms={},this.attributes={},this.context=null)};b.ShaderProgram.prototype.compile=function(){if(!this.isCompiled){this.vShader.compile();this.fShader.compile();
var a=this.context.gl,f=this.glProgram;a.linkProgram(f);if(a.getProgramParameter(f,a.LINK_STATUS)||a.isContextLost()){var d,e=a.getProgramParameter(f,a.ACTIVE_UNIFORMS);for(d=0;d<e;++d){var h=a.getActiveUniform(f,d),g=h.name.lastIndexOf("[0]")==h.name.length-3?h.name.slice(0,-3):h.name;this.uniforms[g]={index:d,type:h.type,size:h.size,loc:a.getUniformLocation(f,h.name)}}e=a.getProgramParameter(f,a.ACTIVE_ATTRIBUTES);for(d=0;d<e;++d)h=a.getActiveAttrib(f,d),this.attributes[h.name]={index:d,type:h.type,
size:h.size,loc:a.getAttribLocation(f,h.name),attrBuffer:null,bufferOffset:0};this.isCompiled=!0;a.detachShader(f,this.vShader.glShader);a.detachShader(f,this.fShader.glShader);a.deleteShader(this.vShader.glShader);a.deleteShader(this.fShader.glShader);this.vShader.glShader=null;this.fShader.glShader=null}else b.Logger.Report("ShaderProgram.compile: "+this.name+" link error(s):\n"+a.getProgramInfoLog(f),c.Error)}};b.ShaderProgram.prototype.setUniform=function(a,f,d){this.context.setCurrentProgram(this);
a.lastIndexOf("[0]")==a.length-3&&(a=a.slice(0,-3));var e=this.uniforms[a];e?(a=e.loc,e=this.context.uniformSetters[e.type],a&&e&&e(a,f)):"undefined"===typeof d||d||b.Logger.Report("ShaderProgram.setUniform: Unrecognized uniform: "+a,c.Warn)};b.ShaderProgram.prototype.setUniforms=function(a,b){for(var c in a)a.hasOwnProperty(c)&&this.setUniform(c,a[c],b)};b.ShaderProgram.prototype.getUniform=function(a,b){this.context.setCurrentProgram(this);var c=this.context.gl,e=this.uniforms[a];return e?b===k?
c.getUniform(this.glProgram,e.loc):(a=c.getUniformLocation(this.glProgram,a+"["+b.toString()+"]"))?c.getUniform(this.glProgram,a):null:null};b.ShaderProgram.prototype.hasUniform=function(a){a.lastIndexOf("[0]")==a.length-3&&(a=a.slice(0,-3));return this.uniforms.hasOwnProperty(a)};b.ShaderProgram.prototype.setAttribute=function(a,f,d,e){d=d===k?!0:d;e=e===k?0:e;this.attributes[a]?(this.attributes[a].attrBuffer=f,this.attributes[a].bufferOffset=e,this.numVertices=(f.numBytes-e)/f.bytesPerVertex,d&&
this.bindAttributes([a])):b.Logger.Report("ShaderProgram.setAttribute: Unrecognized attribute: "+a,c.Error)};b.ShaderProgram.prototype.bindAttributes=function(a){a=(a=a===k?[]:a)||[];var b=this.context.gl,c;for(c in this.attributes)if(this.hasAttribute(c)&&(0===a.length||0<=a.indexOf(c))){var e=this.attributes[c];e.attrBuffer&&(b.bindBuffer(b.ARRAY_BUFFER,e.attrBuffer.glBuffer),b.enableVertexAttribArray(e.loc),b.vertexAttribPointer(e.loc,e.attrBuffer.attrDim,e.attrBuffer.dataType,e.attrBuffer.normalizeValues,
0,e.bufferOffset))}};b.ShaderProgram.prototype.hasAttribute=function(a){return this.attributes.hasOwnProperty(a)};b.ShaderProgram.prototype.setIndexBuffer=function(a){this.indexBuffer=a};b.ShaderProgram.prototype.setInputTexture=function(a,b){if(Array.isArray(b)){for(var c=new Int32Array(b.length),e=0;e<b.length;e++)b[e].bind(),c[e]=b[e].txIndex;this.setUniform(a,c)}else b?(b.bind(),this.setUniform(a,b.txIndex)):this.setUniform(a,-1)};b.ShaderProgram.prototype.draw=function(a){var c=this.context.gl,
d=this.indexBuffer?this.indexBuffer.numIndices:this.numVertices,e=0,h=!0,g=[0,0,0,1],k=c.TRIANGLES,m=null,n=[0,0,c.drawingBufferWidth,c.drawingBufferHeight];a&&("undefined"!==typeof a.numVertices&&(d=a.numVertices),"undefined"!==typeof a.firstVertex&&(e=a.firstVertex),"undefined"!==typeof a.clear&&(h=a.clear),"undefined"!==typeof a.clearColor&&(g=b.Color.ScaleTo1(a.clearColor)),"undefined"!==typeof a.drawMode&&(k=a.drawMode),"undefined"!==typeof a.target&&(m=a.target),"undefined"!==typeof a.viewport&&
(n=a.viewport));c.bindFramebuffer(c.FRAMEBUFFER,m?m.glFrameBuffer:null);this.context.setCurrentProgram(this);c.viewport(n[0],n[1],n[2],n[3]);h&&(c.clearColor(g[0],g[1],g[2],g[3]),c.clear(c.COLOR_BUFFER_BIT));this.indexBuffer?(this.indexBuffer.bind(),c.drawElements(k,d,this.indexBuffer.dataType,e*this.indexBuffer.elemSize)):c.drawArrays(k,e,d)}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=glMatrix.vec3;b.Shapes3D=function(){};b.Shapes3D.Cube=function(a,c,d){c=c||[0,0,0];a/=2;a=[-a,-a,-a,+a,-a,-a,-a,+a,-a,-a,+a,-a,+a,-a,-a,+a,+a,-a,+a,-a,-a,+a,-a,+a,+a,+a,-a,+a,+a,-a,+a,-a,+a,+a,+a,+a,-a,+a,-a,+a,+a,-a,-a,+a,+a,-a,+a,+a,+a,+a,-a,+a,+a,+a,-a,-a,+a,-a,+a,+a,+a,-a,+a,-a,+a,+a,+a,+a,+a,+a,-a,+a,-a,-a,-a,-a,+a,-a,-a,-a,+a,-a,+a,-a,-a,+a,+a,-a,-a,+a,-a,-a,-a,-a,-a,+a,+a,-a,-a,-a,-a,+a,+a,-a,+a,+a,-a,-a];for(var e=0;e<a.length;e++)a[e]+=c[e%3];if(!d||!d.length)return a;
c=[];for(e=0;6>e;e++){var f=d[e%d.length];"string"==typeof f&&(f=b.Color.FromName(f,!0));for(var g=0;18>g;g++)c.push(f[g%3])}return{vertices:a,colors:c}};b.Shapes3D.Rectangle=function(a,f,d,e,h,g){var k=[];d=d||[0,0,0];e=e||[1,0,0];h=h||[0,1,0];c.normalize(e,e);c.normalize(h,h);a/=2;f/=2;var m=[0,0,0];c.scaleAndAdd(m,c.scaleAndAdd(m,d,e,-a),h,-f);k=k.concat(m);c.scaleAndAdd(m,c.scaleAndAdd(m,d,e,a),h,-f);k=k.concat(m);c.scaleAndAdd(m,c.scaleAndAdd(m,d,e,a),h,f);k=k.concat(m);c.scaleAndAdd(m,c.scaleAndAdd(m,
d,e,-a),h,-f);k=k.concat(m);c.scaleAndAdd(m,c.scaleAndAdd(m,d,e,a),h,f);k=k.concat(m);c.scaleAndAdd(m,c.scaleAndAdd(m,d,e,-a),h,f);k=k.concat(m);if(!g)return k;d=[];"string"==typeof ccolorol&&(g=b.Color.FromName(g,!0));for(e=0;18>e;e++)d.push(g[e%3]);return{vertices:k,colors:d}}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=glMatrix.vec3,a=glMatrix.mat4;b.Slab=function(b,d,e,h){this.vol=b;this.center=d?c.clone(d):c.scale(c.create(),b.shape,.5);this.shape=e?c.clone(e):c.clone(b.shape);this.orient=h?a.clone(h):a.create()};b.Slab.prototype.clone=function(){return new b.Slab(this.vol,this.center,this.shape,this.orient)};b.Slab.prototype.updateFrom=function(b){c.copy(this.center,b.center);c.copy(this.shape,b.shape);a.copy(this.orient,b.orient)};b.Slab.prototype.reset=function(){c.scale(this.center,this.vol.shape,
.5);c.copy(this.shape,this.vol.shape);a.identity(this.orient)};b.Slab.prototype.getVerticesTx=function(){var a=$jscomp.makeIterator(this.shape),b=a.next().value,e=a.next().value;a=a.next().value;var h=[b/2,e/2,a/2];return[[0,0,0],[b,0,0],[0,e,0],[b,e,0],[0,0,a],[b,0,a],[0,e,a],[b,e,a]].map(function(a){a=c.subtract(c.create(),a,h);c.transformMat4(a,a,this.orient);c.add(a,a,this.center);return c.divide(a,a,this.vol.shape)}.bind(this))}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=b.Logger.Severity;b.Texture2D=function(a,f,d,e,h,g){this.context=a;this.txIndex=f;this.width=Math.round(d);this.height=Math.round(e);this.pixelType=h;this.interpType=g;this.glTexture=null;this.is3D=!1;a=this.context.gl;0>f||f>=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS)?b.Logger.Report("Texture2D.ctor: Invalid texture index.",c.Error):0>=this.width||0>=this.height?b.Logger.Report("Texture2D.ctor: Texture size cannot be zero.",c.Error):(f=this.context.GlMaxTextureSize,this.width>
f||this.height>f?b.Logger.Report("Texture2D.ctor: The requested texture size is too large.",c.Error):(this.glTexture=a.createTexture(),this.bind(),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,this.interpType),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,this.interpType),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texImage2D(a.TEXTURE_2D,0,this.pixelType,this.width,this.height,0,this.pixelType,a.UNSIGNED_BYTE,
null)))};b.Texture2D.prototype.destroy=function(){if(this.context){var a=this.context.gl;this.bind();a.texImage2D(a.TEXTURE_2D,0,this.pixelType,1,1,0,this.pixelType,a.UNSIGNED_BYTE,null);this.unbind();a.deleteTexture(this.glTexture);this.context=this.glTexture=null}};b.Texture2D.prototype.bind=function(){this.context.bindTexture(this)};b.Texture2D.prototype.unbind=function(){this.context.unbindTexture(this)};b.Texture2D.prototype.setInterpType=function(a){if(this.interpType!=a){this.bind();var b=
this.context.gl;b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,a);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,a);this.interpType=a}};b.Texture2D.prototype.sizeEquals=function(a,b){return this.width==a&&this.height==b};b.Texture2D.prototype.resize=function(a,f){a=Math.round(a);f=Math.round(f);if(0>=a||0>=f)b.Logger.Report("Texture2D.resize: Texture size cannot be zero.",c.Error);else{var d=this.context.GlMaxTextureSize;a>d||f>d?b.Logger.Report("Texture2D.resize: Requested texture size is not supported on this device.",
c.Error):(d=this.context.gl,this.bind(),d.texImage2D(d.TEXTURE_2D,0,this.pixelType,a,f,0,this.pixelType,d.UNSIGNED_BYTE,null),this.width=a,this.height=f)}}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=b.Logger.Severity;b.Texture3D=function(a,f,d,e,h,g,k){this.context=a;this.txIndex=f;this.width=Math.round(d);this.height=Math.round(e);this.depth=Math.round(h);this.pixelType=g;this.interpType=k;this.glTexture=null;this.is3D=!0;0>=this.width||0>=this.height||0>=this.depth?b.Logger.Report("Texture3D.ctor: Invalid dimensions.",c.Error):(a=this.context.gl,0>f||f>=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS)?b.Logger.Report("Texture3D.ctor: Invalid texture index.",c.Error):(this.glTexture=
a.createTexture(),this.bind(),a.texParameteri(a.TEXTURE_3D,a.TEXTURE_MIN_FILTER,this.interpType),a.texParameteri(a.TEXTURE_3D,a.TEXTURE_MAG_FILTER,this.interpType),a.texParameteri(a.TEXTURE_3D,a.TEXTURE_WRAP_R,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_3D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_3D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texStorage3D(a.TEXTURE_3D,1,this.pixelType,this.width,this.height,this.depth)))};b.Texture3D.prototype.destroy=function(){if(this.context){var a=this.context.gl;
this.unbind();a.deleteTexture(this.glTexture);this.context=this.glTexture=null}};b.Texture3D.prototype.bind=function(){this.context.bindTexture(this)};b.Texture3D.prototype.unbind=function(){this.context.unbindTexture(this)};b.Texture3D.prototype.setInterpType=function(a){if(this.interpType!=a){this.bind();var b=this.context.gl;b.texParameteri(b.TEXTURE_3D,b.TEXTURE_MIN_FILTER,a);b.texParameteri(b.TEXTURE_3D,b.TEXTURE_MAG_FILTER,a);this.interpType=a}};b.Texture3D.prototype.sizeEquals=function(a,b,
c){return this.width==a&&this.height==b&&this.depth==c}})(window.BigLime=window.BigLime||{});
(function(b,k){b.ThreeDControls=function(c,a,f){this.options=f||{};this.tabs=[];this.pages=[];this.renderParams=new b.RenderParams;this.contentWidth=this.options.width||640;this.contentHeight=this.options.minimal?440:585;b.Dialog.call(this,{parent:c,title:this.options.title||"3D Controls",width:this.contentWidth+"px",height:this.contentHeight+32+"px",bkgndColor:"#cdb79a",titleBarColor:"#cdb79a",borderWidth:f.borderWidth,borderColor:f.borderColor});this.setContent(this._createContentDiv(a))};b.ThreeDControls.prototype=
Object.create(b.Dialog.prototype);b.ThreeDControls.prototype.constructor=b.ThreeDControls;b.ThreeDControls.prototype.setRenderParams=function(b){this.renderParams=b;this.syncWith(b)};b.ThreeDControls.prototype.setPosition=function(c,a){b.Ui.StyleElement(this.mainDiv,{left:c,top:a})};b.ThreeDControls.prototype._createContentDiv=function(c){for(var a=this.contentWidth,f=this.contentHeight,d=f-40-2,e=b.Ui,h=e.CreateElement("div","3dcon_contentdiv",null,{width:a,height:f,userSelect:"none"}),g=this.options.minimal?
["Opacity","Lights"]:["Main","Lights","Misc"],k=e.CreateElement("ul","3dcon_tablist",h,{width:a,height:f,listStyle:"none"}),m=0;m<g.length;m++){var n=m.toString(),p=(2).toString()+"px ",u=e.CreateElement("li","tablistitem",k,null,{dataTab:n});e.StyleElement(u,{width:100,height:40,left:102*m,top:0,textAlign:"center",verticalAlign:"middle",lineHeight:40,borderColor:"gray",borderStyle:"solid",borderWidth:p+p+"0px 0px",backgroundColor:0===m?"#e5cfb2":"#cdb79a"});u.innerHTML=g[m];this.tabs.push(u);n=e.CreateElement("div",
"3dcon_tabpage"+n,h,{width:a,height:d,left:0,top:f-d,display:0===m?"inherit":"none",backgroundColor:"#e5cfb2"});this.pages.push(n)}var q=this;f=function(){for(var a=parseInt(this.dataTab),b=0;b<g.length;b++)b===a?(e.StyleElement(q.pages[b],{display:"inherit"}),e.StyleElement(q.tabs[b],{backgroundColor:"#e5cfb2"})):(e.StyleElement(q.pages[b],{display:"none"}),e.StyleElement(q.tabs[b],{backgroundColor:"#cdb79a"}))};for(k=0;k<g.length;k++)this.tabs[k].addEventListener("click",f);this._createMainPage(this.pages[0]);
1<g.length&&this._createLightingPage(this.pages[1],a,d);2<g.length&&this._createMiscPage(this.pages[2],a,d,c);return h};b.ThreeDControls.prototype._createMainPage=function(c){var a=parseFloat(c.style.width),f=parseFloat(c.style.height),d=this.options.minimal?350:300,e=b.Ui;c=e.CreateElement("div","3dcon_mainpage_div",c,{width:a,height:f,fontSize:16});this.opacityControl=new b.OpacityControl(a-48,d);e.StyleElement(this.opacityControl.mainDiv,{left:24,top:24});c.append(this.opacityControl.mainDiv);
this.opacityControl.addEventListener("opacity-change-start opacity-change opacity-change-end",function(a){this.trigger(a.type,a.detail)}.bind(this));if(!this.options.minimal){a=this.options&&this.options.hideSlabGroup;d+=48;f=e.CreateButtonGroup("3dcon_mode",c,{width:a?180:120,height:170,left:24,top:d,fontSize:16},[{label:"MIP",value:"mip",checked:!0},{label:"VR",value:"vr"}],function(a){this.trigger("mode-change",{mode:a.target.value})}.bind(this),{btnSize:26,btnLeft:a?50:0});this.mipModeBtn=f.btns[0];
this.vrModeBtn=f.btns[1];f=e.CreateButtonGroup("3dcon_slab",c,{width:170,height:170,left:164,top:d,fontSize:16},[{label:"Show Marker",value:"show-marker-change",checked:!0},{label:"Show slab",value:"show-slab-change"},{label:"Clip to slab",value:"clip-to-slab-change"}],function(a){this.trigger(a.target.value,{val:a.target.checked})}.bind(this),{btnSize:26,independent:!0});this.showMarkerBtn=f.btns[0];this.showSlabBtn=f.btns[1];this.clipToSlabBtn=f.btns[2];f.btns[1].addEventListener("dblclick",function(){this.trigger("reset-slab-request")}.bind(this));
a&&(f.div.style.display="none");f=a?43:15;c=e.CreateElement("div","3dcon_persp",c,{width:a?300:180,height:170,top:d,right:24,border:"1px solid #606060"});var h=this.perspInput=e.CreateElement("select","3dcon_perspsel",c,{top:21,left:f,height:30,width:100,fontSize:16});e.CreateElement("option","3dcon_perspsel_0",h,{},{value:0,text:"Off"});e.CreateElement("option","3dcon_perspsel_0",h,{},{value:1,text:"Low"});e.CreateElement("option","3dcon_perspsel_2",h,{},{value:3,text:"Medium"});e.CreateElement("option",
"3dcon_perspsel_3",h,{},{value:8,text:"High"});h.value=0;h.addEventListener("change",function(){this.trigger("persp-change",{val:parseInt(h.value)})}.bind(this));e.CreateElement("label","3dcon_persp_label",c,{left:f+110,top:25},{innerHTML:"Perspective"});this.saveSettingsBtn=e.CreateSaveFileButton({id:"3dcon_savesettings_btn",parent:c,text:"Save Settings",flatStyle:!1,dbTag:"threedControlsSaveSettings",suggestedName:"Settings.txt",callback:this._onSaveSettings.bind(this),styles:{width:210,height:30,
top:72,left:f,fontSize:14}});this.loadSettingsBtn=e.CreateLoadFileButton({id:"3dcon_loadsettings_btn",parent:c,text:"Load Settings",flatStyle:!1,dbTag:"threedControlsLoadSettings",multiple:!1,callback:this._onLoadSettings.bind(this),styles:{width:210,height:30,top:122,left:f,fontSize:14}})}};b.ThreeDControls.prototype._createLightingPage=function(c,a,f){var d=b.Ui;c=d.CreateElement("div","3dcon_page_div",c,{width:a,height:f-30,top:30,fontSize:16});this.ambientSlider=d.CreateHSlider("3dcon_ambient",
c,{styles:{width:a-64,height:50,left:32,top:0},props:{}},{styles:{},props:{min:0,max:200,value:50,valueScale:.01}},{styles:{width:80},props:{innerHTML:"Ambient"}},{styles:{width:60},props:{}},function(a){this.renderParams.lightSet.ambientLight=a;this.trigger("change")}.bind(this),function(){this.trigger("change-start")}.bind(this),function(){this.trigger("change-end")}.bind(this));d.CreateElement("label","3dcon_lightsel_label",c,{left:32,top:115},{innerHTML:"Light #"});var e=this.lightSel=d.CreateElement("select",
"3dcon_lightsel_inp",c,{top:110,left:112,height:30,width:70});d.CreateElement("option","3dcon_lightsel_1",e,{},{value:0,text:"1"});d.CreateElement("option","3dcon_lightsel_2",e,{},{value:1,text:"2"});e.value=0;e.addEventListener("change",function(){var a=this.renderParams.lightSet.dirLights[this.lightSel.value];this.diffuseSlider.value=Math.round(100*a.diffuse);this.shadowsSlider.value=Math.round(100*a.shadowDarkness);this.specExpSlider.value=Math.round(100*Math.log2(a.specExp));this.specStrengthSlider.value=
Math.round(100*a.specStrength);this.shadowsSlider.value=Math.round(100*a.shadowDarkness)}.bind(this));this.diffuseSlider=d.CreateHSlider("3dcon_diffuse",c,{styles:{width:a-300,height:50,left:32,top:150},props:{}},{styles:{},props:{min:0,max:100,value:50,valueScale:.01}},{styles:{width:80},props:{innerHTML:"Diffuse"}},{styles:{width:50},props:{}},function(a){this.renderParams.lightSet.dirLights[e.value].diffuse=a;this.trigger("change")}.bind(this),function(){this.trigger("change-start")}.bind(this),
function(){this.trigger("change-end")}.bind(this));this.specStrengthSlider=d.CreateHSlider("3dcon_specstr",c,{styles:{width:a-300,height:50,left:32,top:200},props:{}},{styles:{},props:{min:0,max:100,value:50,valueScale:.01}},{styles:{width:80},props:{innerHTML:"Specular"}},{styles:{width:50},props:{}},function(a){this.renderParams.lightSet.dirLights[e.value].specStrength=a;this.trigger("change")}.bind(this),function(){this.trigger("change-start")}.bind(this),function(){this.trigger("change-end")}.bind(this));
this.specExpSlider=d.CreateHSlider("3dcon_specstr",c,{styles:{width:a-300,height:50,left:32,top:250},props:{}},{styles:{},props:{min:0,max:1E3,value:700,decimals:0,xfrm:function(a){return Math.round(Math.pow(2,a/100))}}},{styles:{width:80},props:{innerHTML:"Spec Exp"}},{styles:{width:50},props:{}},function(a){this.renderParams.lightSet.dirLights[e.value].specExp=a;this.trigger("change")}.bind(this),function(){this.trigger("change-start")}.bind(this),function(){this.trigger("change-end")}.bind(this));
this.shadowsSlider=d.CreateHSlider("3dcon_specstr",c,{styles:{width:a-300,height:50,left:32,top:300},props:{}},{styles:{},props:{min:0,max:150,value:50,valueScale:.01}},{styles:{width:80},props:{innerHTML:"Shadows"}},{styles:{width:50},props:{}},function(a){this.renderParams.lightSet.dirLights[e.value].shadowDarkness=a;this.trigger("change")}.bind(this),function(){this.trigger("change-start")}.bind(this),function(){this.trigger("change-end")}.bind(this));d.CreateElement("label","3dcon_lightpos_label",
c,{right:90,top:95},{innerHTML:"Light Position"});a=d.CreateElement("div","3dcon_lightpos",c,{width:240,height:240,top:110,right:15});var h=this.lightPositioner=new b.LightPositioner(a);h.addEventListener("change",function(){this.renderParams.lightSet.dirLights[e.value].dir=h.getLightDirection()}.bind(this));h.addEventListener("changeStart",function(){this.trigger("change-start")}.bind(this));h.addEventListener("changeEnd",function(){this.trigger("change-end")}.bind(this))};b.ThreeDControls.prototype._createMiscPage=
function(c,a,f,d){var e=b.Ui;c=e.CreateElement("div","3dcon_page_div",c,{width:a,height:f-20,top:20,left:0,fontSize:16});this.antiAliasBtn=e.CreateButtonGroup("3dcon_antialias",c,{width:230,height:80,left:32,top:10,fontSize:16},[{label:"Anti-alias",value:"",checked:!0}],function(a){this.trigger("antialias-change",{val:a.target.checked})}.bind(this),{btnSize:26,independent:!0}).btns[0];e.CreateElement("label","3dcon_respon_title",c,{width:200,height:40,top:125,left:32,fontSize:16},{innerHTML:"Interactive quality"});
this.iQualBtns=e.CreateButtonGroup("3dcon_respon",c,{width:230,height:200,left:32,top:150,fontSize:16},[{label:"1  Highest",value:1},{label:"2  Medium",value:.5,checked:!0},{label:"3  Lower",value:.25},{label:"4  Lowest",value:.125}],function(a){this.trigger("iqual-change",{val:a.target.value})}.bind(this),{btnSize:26}).btns;e.CreateElement("label","3dcon_speedtest_title",c,{width:160,height:40,bottom:95,left:32,fontSize:16},{innerHTML:"Speed test"});a=e.CreateElement("div","3dcon_speedtest",c,{width:230,
height:80,bottom:25,left:32,border:"1px solid #606060"});var h=e.CreateElement("label","3dcon_speedtest_fps",a,{width:80,height:40,top:30,left:125,fontSize:16},{innerHTML:"FPS: 0"}),g=e.CreateElement("button","3dcon_speedtest_btn",a,{width:80,height:40,top:20,left:30,fontSize:16});g.innerHTML="Run";g.addEventListener("click",function(){this.trigger("speedtest-toggle",{stateChangeCb:function(a){g.innerHTML="started"==a?"Stop":"Run"}.bind(this),fpsChangeCb:function(a){h.innerHTML="FPS: "+(a?a.toFixed(0):
"--")}.bind(this)})}.bind(this));e.CreateElement("div","3dcon_infobox",c,{top:10,bottom:25,left:300,right:32,padding:10,border:"1px solid #606060",fontSize:16}).innerHTML="GL version: "+d.GlVersionInfo+"<br/><br/>Renderer: "+d.RendererInfo+"<br/><br/>App build: "+b.Utils.getBuildInfo()};b.ThreeDControls.prototype.syncWith=function(c){var a=c.renderType===b.RenderType.VR,f=c.opacityCurve||b.OpacityCurve.FromString(c.opacityCurveStr);this.opacityControl.setOpacityCurve(f,!0);f=c.lightSet.dirLights[this.lightSel.value];
this.ambientSlider.value=Math.round(100*c.lightSet.ambientLight);this.diffuseSlider.value=Math.round(100*f.diffuse);this.shadowsSlider.value=Math.round(100*f.shadowDarkness);this.specExpSlider.value=Math.round(100*Math.log2(f.specExp));this.specStrengthSlider.value=Math.round(100*f.specStrength);this.shadowsSlider.value=Math.round(100*f.shadowDarkness);this.ambientSlider.valLabel.innerHTML=c.lightSet.ambientLight.toFixed(2);this.diffuseSlider.valLabel.innerHTML=f.diffuse.toFixed(2);this.specExpSlider.valLabel.innerHTML=
f.specExp.toFixed(0);this.shadowsSlider.valLabel.innerHTML=f.shadowDarkness.toFixed(2);this.specStrengthSlider.valLabel.innerHTML=f.specStrength.toFixed(2);this.lightPositioner.setLightDirection(f.dir);if(!this.options.minimal)for(this.vrModeBtn.checked=a,this.mipModeBtn.checked=!a,c instanceof b.RenderParam&&(this.showMarkerBtn.checked=c.showMarker,this.showSlabBtn.checked=c.showSlab,this.clipToSlabBtn.checked=c.clipToSlab),this.perspInput.value=c.persp,this.antiAliasBtn.checked=c.antiAlias,this.iQualBtns[1].checked=
!0,c=$jscomp.makeIterator(this.iQualBtns),a=c.next();!a.done;a=c.next())a=a.value,parseFloat(a.value)===engine.fastDrawFactor&&(a.checked=!0)};b.ThreeDControls.prototype._onSaveSettings=function(b){this.trigger("save-settings-request",{fileHandle:b})};b.ThreeDControls.prototype._onLoadSettings=function(c){if(c&&c.length){var a=new FileReader;a.onload=function(a){this.loadSettingsBtn.disabled=!1;try{var c=new b.Settings(JSON.parse(a.target.result));this.trigger("settings-file-loaded",{val:c})}catch(e){b.Logger.Report("Failed to read settings file",
b.Logger.Severity.Warn,!0)}}.bind(this);a.onerror=function(){b.Logger.Report("Failed to read settings file",b.Logger.Severity.Warn,!0);this.loadSettingsBtn.disabled=!1};c[0].getFile().then(function(b){a.readAsText(b)}).catch(function(){this.loadSettingsBtn.disabled=!1}.bind(this))}else this.loadSettingsBtn.disabled=!1};b.ThreeDControls.prototype.addEventListener=function(c,a){b.Notifier.prototype.addEventListener.call(this,c,a)};b.ThreeDControls.prototype.removeEventListener=function(c,a){b.Notifier.prototype.removeEventListener.call(this,
c,a)};b.ThreeDControls.prototype.trigger=function(c,a){b.Notifier.prototype.trigger.call(this,c,a)}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=glMatrix.vec2,a=glMatrix.vec3,f=glMatrix.mat4;b.ThreeDViewer=function(a){a=a===k?{}:a;this.site=a.site;this.controller=a.controller;this.canvas=b.Ui.CreateElement("canvas","threedviewer_canvas",this.site,{width:"100%",height:"100%",backgroundColor:"#000000"});this.canvas.addEventListener("contextmenu",function(a){a.preventDefault()});this.renderEngine=a.renderEngine?a.renderEngine:new b.RenderEngine({options:a.engineOptions});this.ownsEngine=!a.renderEngine;this.renderParams=
new b.RenderParams;this.renderParams.slab=new b.Slab(this.renderEngine.volume);this.renderParams.persp=2;this.defaultOrient=b.Utils.GetRotMatrix([1,0,0],[0,0,-1]);this.fastDrawDownsamp=.5;this.renderCallbacks=[];this.resizeTimerId=null;var c=this.renderEngine.ctx;this.slabLinesInfo={vertexBuffer:c.createAttrBuffer(new Float32Array(144),3,{drawMode:c.gl.DYNAMIC_DRAW}),attrBuffer:c.createAttrBuffer(new Float32Array(192),4,{drawMode:c.gl.STATIC_DRAW}),numLines:0};this.slabLinesInfo.attrBuffer.setData(Array.from({length:96},
function(a,b){return 0==b%2?0:1}));this.controller&&(this.controllerListener=this._onControllerEvent.bind(this),this.controller.addEventListener("AllEvents",this.controllerListener));a.omitInteractor||(this.interactor=new b.MultiInteractor(this.canvas),this.interactor.addEventListener("start move end",this._onInteractorEvent.bind(this)));!1!==a.autoResize&&(this.resizeListener=this.onResize().bind(this),window.addEventListener("resize",this.resizeListener));this.onResize()};b.ThreeDViewer.prototype.destroy=
function(){this.renderEngine&&(clearTimeout(this.resizeTimerId),this.resizeListener&&window.removeEventListener("resize",this.resizeListener),b.Utils.cancelAnimFrame(this.rafId),this.interactor&&this.interactor.stopListening(),this.controllerListener&&this.controller.removeEventListener("AllEvents",this.controllerListener),this.ownsEngine&&this.renderEngine.destroy(),this.renderEngine=null,this.canvas.remove())};b.ThreeDViewer.prototype.onResize=function(a){var c=this.canvas.getBoundingClientRect();
this.canvas.width=Math.round(c.width);this.canvas.height=Math.round(c.height);this.rafId=b.Utils.requestAnimFrame(this.render.bind(this));a?this.resizeTimerId=null:(this.resizeTimerId&&clearTimeout(this.resizeTimerId),this.resizeTimerId=setTimeout(function(){this.onResize(!0)}.bind(this),300))};b.ThreeDViewer.prototype.clear=function(){this.canvas.getContext("2d").clearRect(0,0,this.canvas.width,this.canvas.height)};b.ThreeDViewer.prototype.loadVolume=function(a,b,c,f){var d=function(a,b){if(!a)this.onNewVolumeLoaded();
c&&c(a,b,this)}.bind(this);this.renderEngine.loadVolume({imgFiles:a,loader:b,completionCb:d,progressCb:f,omitRender:!0,omitResetView:!0})};b.ThreeDViewer.prototype.cancelLoading=function(){this.renderEngine.cancelLoading()};b.ThreeDViewer.prototype.onNewVolumeLoaded=function(){};b.ThreeDViewer.prototype.render=function(){var a=this,b=this.renderEngine;if(b.hasImageData()){b.setRenderParams(this.renderParams);var c=b.isAnimating()?this.fastDrawDownsamp:1;b.sizeRasterToMatch(this.canvas,c);b.render(this.calcSlabLines.bind(this));
c=this.canvas.getContext("2d");c.clearRect(0,0,this.canvas.width,this.canvas.height);c.drawImage(b.canvas,0,0,this.canvas.width,this.canvas.height);this.renderCallbacks.forEach(function(b){b(a)})}};b.ThreeDViewer.prototype._onInteractorEvent=function(a){var b=this.renderEngine,d=this.renderParams,g=this.interactor;if("start"==a.type)g.setInitialValues({zoom:d.zoom,pan:d.pan,rot:d.rotMatrix,lighting:{ambient:d.lightSet.ambientLight,shadow:d.lightSet.dirLights[0].shadowDarkness}}),b.animate(15,this.render.bind(this));
else if("move"==a.type)switch(g.interactMode){case "zoom":case "wheelzoom":d.zoom=g.currentZoom;break;case "pan":c.copy(d.pan,g.currentPan);break;case "panzoom":d.zoom=g.currentZoom;c.copy(d.pan,g.currentPan);break;case "rotate":f.copy(d.rotMatrix,g.currentRot);break;case "light":d.lightSet.ambientLight=g.ambient,d.lightSet.dirLights[0].shadowDarkness=g.shadow}else"end"==a.type&&(b.stopAnimation(),this.render())};b.ThreeDViewer.prototype._onControllerEvent=function(a){var b=this.renderParams,c=this.renderEngine;
switch(a.type){case "change-start":case "opacity-change-start":c.animate(5,this.render.bind(this));break;case "change-end":case "opacity-change-end":c.stopAnimation(),this.render();case "change":this.renderEngine.isAnimating()||this.render();break;case "opacity-change":b.opacityCurve=a.detail.opCurve;this.renderEngine.isAnimating()||this.render();break;case "antialias-change":b.antiAlias=a.detail.val;this.render();break;case "iqual-change":this.fastDrawDownsamp=parseFloat(a.detail.val)}};b.ThreeDViewer.prototype.setPerspectiveFactor=
function(a){var b=this.renderParams,c=b.persp;b.persp=a;b.zoom*=this._calcPerspectiveZoomFactor(b.persp)/this._calcPerspectiveZoomFactor(c)};b.ThreeDViewer.prototype.setDefaultOrientation=function(a){f.copy(this.defaultOrient,a)};b.ThreeDViewer.prototype.resetOrientation=function(){f.copy(this.renderParams.rotMatrix,this.defaultOrient)};b.ThreeDViewer.prototype.resetZoom=function(){var a=this.renderParams;a.zoom=this.calcDefaultOrthoZoom()*this._calcPerspectiveZoomFactor(a.persp)};b.ThreeDViewer.prototype.resetPan=
function(){c.copy(this.renderParams.pan,[0,0])};b.ThreeDViewer.prototype.resetWindowWidthAndLevel=function(){var a=$jscomp.makeIterator(this.renderEngine.volume.getAutoWinLevel());this.renderParams.winWidth=a.next().value;this.renderParams.winLevel=a.next().value};b.ThreeDViewer.prototype.calcDefaultOrthoZoom=function(){var a=1;if(this.renderEngine.hasImageData()){a=this.renderEngine.volume;var b=[this.defaultOrient[1],this.defaultOrient[5],this.defaultOrient[9]],c=[this.defaultOrient[0],this.defaultOrient[4],
this.defaultOrient[8]].reduce(function(a,b,c,d){return Math.abs(b)>Math.abs(d[a])?c:a},0);b=b.reduce(function(a,b,c,d){return Math.abs(b)>Math.abs(d[a])?c:a},0);var f=this.canvas.width/this.canvas.height;a=a.shape[c]/a.shape[b]>f?a.diagSize/a.shape[c]*Math.max(1,f):a.diagSize/a.shape[b]*Math.max(1,1/f)}return a};b.ThreeDViewer.prototype._calcPerspectiveZoomFactor=function(b){var c=this.renderEngine.calcTransforms(this.renderParams,this.canvas,{omitLights:!0}),d=a.fromValues(.5,.5,.5);a.transformMat4(d,
d,c.mvp);return 1+Math.max(0,1-Math.abs(d[2]))*b};b.ThreeDViewer.prototype.calcSlabLines=function(b){function c(b,c,d,e,g,h){var l=a.subtract(a.create(),b[e],b[d]);a.normalize(l,l);b=a.subtract(a.create(),b[g],b[d]);a.normalize(b,b);if(1E-4<l[0]*b[1]-l[1]*b[0])for(d=[d,e,d,g,h,e,h,g],e=0;8>e;e+=2)h=$jscomp.makeIterator([d[e],d[e+1]]),g=h.next().value,h=h.next().value,l=g<h?10*g+h:10*h+g,k.includes(l)||(k.push(l),f.set(c[g],m),f.set(c[h],m+3),m+=6)}var d=this.renderParams.slab;if(!d)return null;var f=
new Float32Array(144),k=[],m=0,n=d.getVerticesTx().map(function(b){return a.subtract(a.create(),b,[.5,.5,.5])}),p=this.renderParams,u=n.map(function(c){c=a.transformMat4(a.create(),c,b.mvp);var d=1+p.persp*(c[2]+1);return a.divide(c,c,[d,d,1])});[[0,1,2,3],[1,5,3,7],[2,3,6,7],[4,0,6,2],[4,5,0,1],[5,4,7,6]].forEach(function(a){c.apply(null,[u,n].concat($jscomp.arrayFromIterable(a)))});this.slabLinesInfo.vertexBuffer.setData(f);this.slabLinesInfo.numLines=m/6;return this.slabLinesInfo};b.ThreeDViewer.prototype.txToViewport=
function(b){var c=this.renderParams,d=this.renderEngine.calcTransforms(c,this.canvas,{omitLights:!0});b=a.subtract(a.create(),b,[.5,.5,.5]);d=a.transformMat4(a.create(),b,d.mvp);c=1+c.persp*(d[2]+1);a.divide(d,d,[c,c,1]);return[(1+d[0])*this.canvas.width/2,(1-d[1])*this.canvas.height/2]};b.ThreeDViewer.prototype.viewportToTx=function(b,c){c=c===k?0:c;b=[2*b[0]/this.canvas.width-1,1-2*b[1]/this.canvas.height,c];var d=this.renderParams;c=1+d.persp*(c+1);a.multiply(b,b,[c,c,1]);c=this.renderEngine.calcTransforms(d,
this.canvas,{omitLights:!0});b=a.transformMat4(a.create(),b,c.mvpInv);return a.add(a.create(),b,[.5,.5,.5])}})(window.BigLime=window.BigLime||{});
(function(b,k){var c=glMatrix.vec3;b.TiffLoader3D=function(a){b.Loader3D.call(this);this.imgBufferArray=null;this.fileList=[];this.extraAttrs=a};b.TiffLoader3D.prototype=Object.create(b.Loader3D.prototype);b.TiffLoader3D.prototype.constructor=b.TiffLoader3D;b.TiffLoader3D.prototype.getImageDims=function(a){return $jscomp.asyncExecutePromiseGeneratorProgram(function(b){return b.return(new Promise(function(b,c){try{var d=new FileReader;d.onload=function(){try{var a=UTIF.decode(d.result);b([a[0].t256[0],
a[0].t257[0]])}catch(l){c(l)}};d.onerror=function(a){c(a)};a instanceof FileSystemFileHandle?a.getFile().then(function(a){d.readAsArrayBuffer(a)}).catch(function(a){c(a)}):d.readAsArrayBuffer(a)}catch(g){c(g)}}))})};b.TiffLoader3D.prototype.loadImagesIntoVolume=function(a,b,c,e){this.fileList=[];Array.prototype.push.apply(this.fileList,a);this.vol=b;this.warnings=this.errors=null;this.done=!1;this.loadCompleteCb=c;this.loadProgressCb=e;if(this.fileList&&this.fileList.length)if(this.fileList.some(function(a){return!(a instanceof
FileSystemFileHandle)&&!(a instanceof File)}))this.done=!0,this.errors="TiffLoader3D: Invalid item in file list.",this.loadCompleteCb&&this.loadCompleteCb(this);else{var d=new FileReader;d.onload=function(){this._onInitialImageLoaded(d)}.bind(this);d.onerror=function(){this._onImageLoadingError(d)}.bind(this);(a=this.fileList.find(function(a){return!a.name.toLowerCase().startsWith("slicegap")}))?(this.loadProgressCb&&this.loadProgressCb(0,this.fileList.length),a instanceof FileSystemFileHandle?a.getFile().then(function(a){d.readAsArrayBuffer(a)}).catch(function(a){this._onImageLoadingError(d)}.bind(this)):
d.readAsArrayBuffer(a)):this.done||(this.done=!0,this.errors="No tiff files were specified.",this.loadCompleteCb&&this.loadCompleteCb(this))}else this.done=!0,this.warnings="TiffLoader3D: No files were loaded, because the supplied file list was empty.",this.loadCompleteCb&&this.loadCompleteCb(this)};b.TiffLoader3D.prototype._onInitialImageLoaded=function(a){if(!this.cancelled)try{var f=UTIF.decode(a.result);if(1<f.length)this._handleMultiImageTiff(a.result,f);else{UTIF.decodeImage(a.result,f[0]);
var d=f[0].isLE?"little":"big",e=f[0].width,h=f[0].height,g=f[0].t258[0],k=1,m=!1,n=this.fileList.find(function(a){return a.name.toLowerCase().startsWith("slicegap")});if(n)try{k=parseFloat(n.name.substring(8)),0>k&&(m=!0),k=Math.abs(k)}catch(z){b.Logger.Report("Failed to read slice gap. Defaulting to 1.0.",b.Logger.Severity.Warn)}this.fileList=this.fileList.filter(function(a){return!a.name.toLowerCase().startsWith("slicegap")});this.fileList=m?this.fileList.sort(function(a,b){return a.name.localeCompare(b.name)}):
this.fileList.sort(function(a,b){return b.name.localeCompare(a.name)});if(this.errors=this.vol.loadBegin([e,h,this.fileList.length],g,d))this.done=!0,this.loadCompleteCb&&this.loadCompleteCb(this);else{this.vol.setAttr("modality","Tiff");this.vol.setAttr("rescaleSlope",1);this.vol.setAttr("rescaleIntercept",0);this.vol.setAttr("dataOffset",0);this.vol.setAttr("sliceGap",k);this.vol.setAttr("rowDir",c.fromValues(1,0,0));this.vol.setAttr("colDir",c.fromValues(0,1,0));this.vol.calcNearLphAxes();try{if(this.extraAttrs)for(var p=
$jscomp.makeIterator(this.extraAttrs),u=p.next();!u.done;u=p.next()){var q=u.value,t=f[0]["t"+q[0].toString()];Array.isArray(t)&&(t=t[0]);t||0===t||(t="");this.vol.setAttr(q[1],t.toString())}}catch(z){}this.imgBufferArray=Array(4);this._loadNextBatch(0)}}}catch(z){this._onImageLoadingError(a)}};b.TiffLoader3D.prototype._loadNextBatch=function(a){var b=8==this.vol.bpp?4:2;b=Math.min(b,this.vol.dims[2]-a);for(var c={startIndex:a,endIndex:a+b,numLeftToLoad:b,imgBuffers:this.imgBufferArray},e=0;e<b;e++)this._loadSingleImage(a+
e,c)};b.TiffLoader3D.prototype._loadSingleImage=function(a,b){var c=new FileReader;c.fileName=this.fileList[a].name;c.batchInfo=b;c.onload=function(){this._onImageLoaded(a,c)}.bind(this);c.onerror=function(){this._onImageLoadingError(c)}.bind(this);b=this.fileList[a];if(b instanceof FileSystemFileHandle)try{b.getFile().then(function(a){c.readAsArrayBuffer(a)})}catch(e){this._onImageLoadingError(c)}else c.readAsArrayBuffer(b)};b.TiffLoader3D.prototype._onImageLoadingError=function(a){this.cancelled||
this.done||(this.done=!0,this.errors="Error loading image "+(a.fileName||""),this.loadCompleteCb&&this.loadCompleteCb(this))};b.TiffLoader3D.prototype._onImageLoaded=function(a,b){if(!this.done&&!this.cancelled)try{var c=UTIF.decode(b.result);UTIF.decodeImage(b.result,c[0]);var e=b.batchInfo;e.imgBuffers[a-e.startIndex]=16==this.vol.bpp?new Uint16Array(c[0].data.buffer):new Uint8Array(c[0].data.buffer);e.numLeftToLoad--;this.loadProgressCb&&this.loadProgressCb(e.endIndex-e.numLeftToLoad,this.vol.dims[2]);
0===e.numLeftToLoad&&(this._copyImagesToTexture(e),e.endIndex<this.vol.dims[2]?this._loadNextBatch(e.endIndex):this.done||(this.vol.loadEnd(),this.done=!0,this.loadCompleteCb&&this.loadCompleteCb(this)))}catch(h){this._onImageLoadingError(b)}};b.TiffLoader3D.prototype._handleMultiImageTiff=function(a,b){var d=this,e,f,g,k,m,n,p,u,q,t,z,v,r,y,J,I,Q;return $jscomp.asyncExecutePromiseGeneratorProgram(function(h){switch(h.nextAddress){case 1:h.setCatchFinallyBlocks(2);UTIF.decodeImage(a,b[0]);e=b[0].isLE?
"little":"big";f=b[0].width;g=b[0].height;k=b.length;m=b[0].t258[0];n=1;if(p=d.fileList.find(function(a){return a.name.toLowerCase().startsWith("slicegap")}))try{n=parseFloat(p.name.substring(8))}catch(A){Lib3D.MiscUtils.reportMessage("Failed to read slice gap. Defaulting to 1.0")}u=[f,g,k];d.errors=d.vol.loadBegin(u,m,e);if(d.errors)return d.done=!0,d.loadCompleteCb&&d.loadCompleteCb(d),h.return();d.vol.setAttr("modality","Tiff");d.vol.setAttr("rescaleSlope",1);d.vol.setAttr("rescaleIntercept",0);
d.vol.setAttr("dataOffset",0);d.vol.setAttr("sliceGap",n);d.vol.setAttr("rowDir",c.fromValues(1,0,0));d.vol.setAttr("colDir",c.fromValues(0,1,0));d.vol.calcNearLphAxes();try{if(d.extraAttrs)for(q=$jscomp.makeIterator(d.extraAttrs),t=q.next();!t.done;t=q.next())z=t.value,v=b[0]["t"+z[0].toString()],Array.isArray(v)&&(v=v[0]),v||0===v||(v=""),d.vol.setAttr(z[1],v.toString())}catch(A){}d.imgBufferArray=Array(4);r=8==d.vol.bpp?4:2;b=b.slice().reverse();y=0;case 4:if(!(y<k)){h.leaveTryBlock(0);break}r=
Math.min(r,k-y);J={startIndex:y,endIndex:y+r,numLeftToLoad:r,imgBuffers:d.imgBufferArray};for(I=0;I<r;I++)if(Q=J.startIndex+I,0<Q&&(b[Q-1].data=null),UTIF.decodeImage(a,b[Q]),J.imgBuffers[I]=16==d.vol.bpp?new Uint16Array(b[Q].data.buffer):new Uint8Array(b[Q].data.buffer),J.numLeftToLoad--,0===J.numLeftToLoad&&(d._copyImagesToTexture(J),J.endIndex==k&&!d.done))return d.vol.loadEnd(),d.done=!0,d.loadCompleteCb&&d.loadCompleteCb(d),h.return();if(!d.loadProgressCb){h.jumpTo(7);break}d.loadProgressCb(J.endIndex-
J.numLeftToLoad,d.vol.dims[2]);return h.yield(new Promise(function(a){return setTimeout(a,5)}),8);case 8:if(d.cancelled)return h.return();case 7:y+=r;h.jumpTo(4);break;case 2:h.enterCatchBlock(),d._onImageLoadingError(fileReader),h.jumpToEnd()}})}})(window.BigLime=window.BigLime||{});
(function(b,k){b.VolumeT2=function(c,a){this.context=c;this.dims=[1,1,1];this.sliceGap=1;this.bpp=0;this.bigEndian=!1;this.sizeInBytes=0;this.shape=[1,1,1];this.diagSize=Math.sqrt(3);this.aspect=[1,1,1];this.attrs={};this.textures=[];this.txInfo=null;this.maxNumTextures=a;this.interpType=b.Interp3D.TriLinear;this.histogram=new b.Histogram3D(65536);this.loaded=!1;this.autoWinLevel=this.opacityRange=null;this.meshManager=new b.MeshManager(this);this.calcNearLphAxes()};b.VolumeT2.prototype.destroy=function(){if(this.context){for(var b=
0;b<this.textures.length;b++)this.textures[b].destroy();this.textures=[];this.context=this.nearLphAxes=this.attrs=this.dims=null}};b.VolumeT2.prototype.setInterpType=function(c){if(!(this.interpType=c)){this.interpType=c;var a=this.context.gl;c=c==b.Interp3D.NN?a.NEAREST:a.LINEAR;for(a=0;a<this.textures.length;a++)this.textures[a].setInterpType(c)}};b.VolumeT2.prototype.numTextures=function(){return this.textures.length};b.VolumeT2.prototype.addMesh=function(b){this.meshManager.addMesh(b)};b.VolumeT2.prototype.removeMesh=
function(b){return this.meshManager.removeMesh(b)};b.VolumeT2.prototype.removeAllMeshes=function(){return this.meshManager.removeAllMeshes()};b.VolumeT2.prototype.containsMesh=function(b){return this.meshManager.contains(b)};b.VolumeT2.prototype.loadBegin=function(c,a,f){this.loaded=!1;this.histogram.clear();this.autoWinLevel=this.opacityRange=null;this.sliceGap=1;this.meshManager.removeAllMeshes();if(8!=a&&16!=a)return"Unsupported bits-per-pixel.";var d=b.VolumeT2._calcMosaicTextureParams(c,a,this.context);
if(d.count>this.maxNumTextures)return"Volume is too large for this device.";try{this.dims=[c[0],c[1],c[2]];this.bpp=a;this.bigEndian=f.toLowerCase().startsWith("b");this.txInfo=d;this.sizeInBytes=a/8*c[1]*c[2]*c[0];var e=d.count,h=this.textures;this.textures=[];var g;for(g=e;g<h.length;g++)h[g].destroy();var k=this.context.gl;for(g=0;g<e;g++){var m=d.dims[g<e-1?0:2],n=d.dims[g<e-1?1:3];if(g<h.length&&h[g].sizeEquals(m,n))this.textures.push(h[g]);else{g<h.length&&h[g].destroy();var p=new b.Texture2D(this.context,
g,m,n,k.RGBA,k.LINEAR);p.setInterpType(this.interpType==b.Interp3D.NN?k.NEAREST:k.LINEAR);this.textures.push(p)}}}catch(u){return"Error configuring volume\n\n"+u.message}};b.VolumeT2._calcMosaicTextureParams=function(b,a,f){var c=b[0],e=b[1];b=b[2];var h=f.GlMaxTextureSize;a=32/a;f=Math.min(Math.floor(h/c),Math.ceil(Math.sqrt(b/a)));h=Math.min(Math.floor(h/e),Math.ceil(b/(f*a)));var g=f*h*a,k=Math.ceil(b/g);b=Math.ceil((b-(k-1)*g)/(f*a));return{count:k,dims:[f*c,h*e,f*c,b*e],mosaicDims:[f,h,f,b],
NTx:f,NTy:h,imgsPerTile:a,imgsPerTexture:g,tilesPerTexture:f*h}};b.VolumeT2.prototype.loadEnd=function(){this.loaded=!0;this.shape=[this.dims[0],this.dims[1],this.dims[2]*this.sliceGap];this.diagSize=glMatrix.vec3.length(this.shape);glMatrix.vec3.scale(this.aspect,this.shape,1/Math.max.apply(Math,$jscomp.arrayFromIterable(this.shape)))};b.VolumeT2.prototype.setAttr=function(b,a){b=b.toLowerCase();this.attrs[b]=a;"slicegap"==b&&(this.sliceGap=Number(a))};b.VolumeT2.prototype.getAttr=function(b,a){b=
this.attrs[b.toLowerCase()];if("undefined"===typeof b||null===b)b=a;return b};b.VolumeT2.prototype.modality=function(){return this.getAttr("modality","").toUpperCase()};b.VolumeT2.prototype.getOpacityRange=function(){if(this.opacityRange)return this.opacityRange;if("CT"==this.modality()){var b=this.getAttr("rescaleSlope",1);var a=(-1024-this.getAttr("rescaleIntercept",0))/b-this.getAttr("dataOffset",0);b=4096/b}else b=this.histogram.getThreshedMinMax(.5),a=b[0],b=Math.max(b[1]-b[0],1E-4);return this.opacityRange=
[a,b]};b.VolumeT2.prototype.getAutoWinLevel=function(){if(this.autoWinLevel)return this.autoWinLevel;if(!this.loaded)return[2048,1024];if("CT"==this.modality()){var b=this.getAttr("rescaleSlope",1);var a=(-1024-this.getAttr("rescaleIntercept",0)+640)/b-this.getAttr("dataOffset",0);b=1024/b}else b=this.histogram.getThreshedMinMax(.5),a=b[0],b=Math.max(b[1]-b[0],1E-4);return this.autoWinLevel=[b,a+b/2]};b.VolumeT2.prototype.calcNearLphAxes=function(){var b=glMatrix.vec3;this.nearLphAxes={};var a=this.getAttr("rowDir"),
f=this.getAttr("colDir");if(a&&f){var d=[0,0,0];b.cross(d,a,f);d=[a,f,d];var e=-1,h=0;for(a=0;3>a;a++)f=d[a][0],Math.abs(f)>Math.abs(h)&&(h=f,e=a);this.nearLphAxes.L=[0,0,0];this.nearLphAxes.L[e]=Math.sign(h);this.nearLphAxes.R=[0,0,0];b.negate(this.nearLphAxes.R,this.nearLphAxes.L);var g=-1;for(a=h=0;3>a;a++)a!=e&&(f=d[a][1],Math.abs(f)>Math.abs(h)&&(h=f,g=a));this.nearLphAxes.P=[0,0,0];this.nearLphAxes.P[g]=Math.sign(h);this.nearLphAxes.A=[0,0,0];b.negate(this.nearLphAxes.A,this.nearLphAxes.P);
this.nearLphAxes.H=[0,0,0];b.cross(this.nearLphAxes.H,this.nearLphAxes.L,this.nearLphAxes.P);this.nearLphAxes.F=[0,0,0];b.negate(this.nearLphAxes.F,this.nearLphAxes.H);return this.nearLphAxes}this.nearLphAxes.L=[1,0,0];this.nearLphAxes.R=[-1,0,0];this.nearLphAxes.P=[0,1,0];this.nearLphAxes.A=[0,-1,0];this.nearLphAxes.H=[0,0,1];this.nearLphAxes.F=[0,0,-1]}})(window.BigLime=window.BigLime||{});
(function(b,k){b.VolumeT3=function(c,a){this.context=c;this.txIndex=a;this.dims=[1,1,1];this.sliceGap=1;this.bpp=0;this.bigEndian=!1;this.sizeInBytes=0;this.shape=[1,1,1];this.diagSize=Math.sqrt(3);this.aspect=[1,1,1];this.attrs={};this.texture=null;this.interpType=b.Interp3D.TriLinear;this.histogram=new b.Histogram3D(65536);this.loaded=!1;this.autoWinLevel=this.opacityRange=null;this.meshManager=new b.MeshManager(this);this.calcNearLphAxes()};b.VolumeT3.prototype.destroy=function(){this.context&&
(this.texture&&(this.texture.destroy(),this.texture=null),this.context=this.nearLphAxes=this.attrs=this.dims=null)};b.VolumeT3.prototype.setInterpType=function(c){if(this.interpType!=c){var a=this.context.gl;c=c==b.Interp3D.NN?a.NEAREST:a.LINEAR;this.texture&&this.texture.setInterpType(c)}};b.VolumeT3.prototype.numTextures=function(){return 1};b.VolumeT3.prototype.addMesh=function(b){this.meshManager.addMesh(b)};b.VolumeT3.prototype.removeMesh=function(b){return this.meshManager.removeMesh(b)};b.VolumeT3.prototype.removeAllMeshes=
function(){return this.meshManager.removeAllMeshes()};b.VolumeT3.prototype.containsMesh=function(b){return this.meshManager.contains(b)};b.VolumeT3.prototype.loadBegin=function(c,a,f){this.loaded=!1;this.histogram.clear();this.autoWinLevel=this.opacityRange=null;this.sliceGap=1;this.meshManager.removeAllMeshes();if(8!=a&&16!=a)return"Unsupported bits-per-pixel.";try{var d=this.context.gl;!this.texture||this.texture.sizeEquals(c[0],c[1],c[2])&&a==this.bpp||(this.texture.destroy(),this.texture=null);
this.texture||(this.texture=new b.Texture3D(this.context,this.txIndex,c[0],c[1],c[2],8==a?d.R8:d.RG8,d.LINEAR),this.setInterpType(this.interpType));this.dims=[c[0],c[1],c[2]];this.bpp=a;this.bigEndian=f.toLowerCase().startsWith("b");this.sizeInBytes=a/8*c[1]*c[2]*c[0]}catch(e){return"Error configuring volume\n\n"+e.message}};b.VolumeT3.prototype.loadEnd=function(){this.loaded=!0;this.shape=[this.dims[0],this.dims[1],this.dims[2]*this.sliceGap];this.diagSize=glMatrix.vec3.length(this.shape);glMatrix.vec3.scale(this.aspect,
this.shape,1/Math.max.apply(Math,$jscomp.arrayFromIterable(this.shape)))};b.VolumeT3.prototype.setAttr=function(b,a){b=b.toLowerCase();this.attrs[b]=a;"slicegap"==b&&(this.sliceGap=Number(a))};b.VolumeT3.prototype.getAttr=function(b,a){b=this.attrs[b.toLowerCase()];if("undefined"===typeof b||null===b)b=a;return b};b.VolumeT3.prototype.modality=function(){return this.getAttr("modality","").toUpperCase()};b.VolumeT3.prototype.getOpacityRange=function(){return b.VolumeT2.prototype.getOpacityRange.call(this)};
b.VolumeT3.prototype.getAutoWinLevel=function(){return b.VolumeT2.prototype.getAutoWinLevel.call(this)};b.VolumeT3.prototype.calcNearLphAxes=function(){return b.VolumeT2.prototype.calcNearLphAxes.call(this)}})(window.BigLime=window.BigLime||{});
(function(b,k){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.gfx_vert_1="// gfx_vert_1\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; \nprecision highp int;\n\nattribute vec4 aPosition;\nattribute vec3 aNormal;\nattribute vec4 aColor;\nattribute vec4 aMaterial;\n\nuniform mat4 uMvpTransform;\nuniform mat4 uRotMatrix;\nuniform float uPersp;\n\nvarying vec4 vPosition;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec4 vMaterial;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition; \n    gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0);\n\n    // Transform the normal as well\n    vNormal = mat3(uRotMatrix) * aNormal; \n\n    // Set varying values\n    vPosition = gl_Position;\n    vMaterial = aMaterial;\n    vColor = aColor;\n}\n";b.ShaderCode.gfx_frag_1=
"// gfx_frag_1\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; \nprecision highp int;\n\nuniform bool  uRenderDepthMap;\nvarying vec4  vPosition;\nvarying vec3  vNormal;\nvarying vec4  vColor;\nvarying vec4  vMaterial;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    if (uRenderDepthMap) \n    {\n        // Encode the depth in the b and a channels of the output color\n        float depth = 65535.0*clamp((vPosition.z+1.0)/2.0, 0.0, 1.0);\n        float dHigh = floor(depth/256.0);\n        float dLo = (depth - dHigh*256.0);\n        gl_FragColor = vec4(0.0, 0.0, dHigh/255.0, dLo/255.0);\n    }\n    else\n    {\n        // Apply lighting to the fragment color\n        float mAmbient      = vMaterial.r * 2.0;\n        float mDiffuse      = vMaterial.g * 2.0;\n        float mSpecStrength = vMaterial.b * 2.0;\n        float mSpecPower    = vMaterial.a * 255.0;\n\n        vec3 lightDir = vec3(0.0, 0.0, 1.0);\n        float cdot = clamp(-dot(normalize(vNormal), lightDir), 0.0, 1.0);\n        float diffuse = mDiffuse*(cdot - 0.6);\n        float specular = (mSpecStrength == 0.0) ? 0.0 : mSpecStrength * pow(cdot,mSpecPower);\n        \n        float light = max(0.0, mAmbient + diffuse + specular );   \n        gl_FragColor = vec4(vColor.rgb*light, vColor.a);\n    }\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,k){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.mip_vert_1="// mip_vert_1\n//-----------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nuniform mat4   uMvpTransform;\nuniform mat4   uMvpInvTransform;\nuniform float  uPersp;\nattribute vec4 aPosition;\nvarying vec3   vRayStartT;\nvarying vec3   vRayDirT;\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition;\n    float w = gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0); \n\n\t// Pass the ray's starting point and direction to the fragment shader (in texture coordinates).\n\t// Note that scaling of vRayDirT by w is necessary for perspective-correct interpolation.\n\tvRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = w * (uMvpInvTransform * vec4(gl_Position.xy*(uPersp/w), 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.mip_frag_1=
"// mip_frag_1\n//-----------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\n// Uniforms and varyings\nuniform sampler2D  uSampler;                      // For volumes that fit in a single texture\nuniform sampler2D  uSamplers[NUM_IMAGE_TEXTURES]; // For volumes that span multiple textures\nuniform sampler2D  uMaskSampler;\nuniform bool       uMaskEnabled;\nuniform float  uRayStepSize;\nuniform vec3   uVolShape;\nuniform float  uVolNumImages;\nuniform vec4   uMosaicDims;\nuniform int    uNumTextures;\nuniform float  uSlabInfo[24];\nuniform bool   uPickMode;\nuniform vec2   uPickPoint;\nuniform bool   uShowMarker;\nuniform vec3   uMarkerLoc;\nuniform float  uMarkerSize;\nvarying vec3   vRayStartT;\nvarying vec3   vRayDirT;\n\n// Constants\nconst float BBoxTol   = 0.002; \nconst vec3 BboxMin    = vec3(-BBoxTol);\nconst vec3 BboxMax    = vec3(1.0 + BBoxTol);\nconst vec3 Zeros      = vec3(0.0);\nconst vec3 Ones       = vec3(1.0);\nconst vec4 ByteMaskRG = vec4(1.0, 256.0, 0.0, 0.0);\nconst vec4 ByteMaskBA = vec4(0.0, 0.0, 1.0, 256.0);\nconst vec2 ByteMask   = vec2(1.0, 256.0);\nconst vec2 ToFloat16  = vec2(256.0, 1.0)/257.0; // For converting a pair of bytes to a float \n\n// Globals\nfloat NzM1, MxInv, MyInv;\nint NumMosaicsM1;\nvec2 MinvFirst, MinvLast;\nvec3 VolAspect;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii;\nmat4 SlabXfrm;\n#endif\n\n// Function prototypes\nbool calcMipValue(vec3);\nbool calcPickLocation(vec3);\nfloat getPixVal(vec3);\nvec4 sampleTexture(vec2, int);\nvec4 encodeVec3(vec3);\nbool isMasked(vec3 pos);\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Perform ray casting\n\tvec3 rayDir = normalize(vRayDirT);\t\n\tbool stat = calcPickLocation(rayDir) || calcMipValue(rayDir);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the maximum intensity along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcMipValue(vec3 rayDir)\n{\n\t// Initialize some globals needed by the getPixVal() routines\n\tNumMosaicsM1 = uNumTextures - 1;\t\n\tNzM1 = uVolNumImages - 1.0;\n\tMxInv = 1.0/uMosaicDims[0];\n\tMyInv = 1.0/uMosaicDims[1];    \n\tMinvFirst = vec2(1.0/uMosaicDims[0], 1.0/uMosaicDims[1]);\n\tMinvLast  = vec2(1.0/uMosaicDims[2], 1.0/uMosaicDims[3]);\n\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\t\n\t// Initialize the ray\n\tvec3 pos = vRayStartT;\n\tvec3 rayStep = rayDir*uRayStepSize;\n\tfloat rayToMarkerDist = 10.0;\n\tbool enteredSlab = false;\n\t\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\t\n\n\t// Walk along the ray\n\tfloat maxPixVal = 0.0;\n\tfor (int i = 0; i < 32768; i++)\n\t{\t\t\n\t\t// Check whether the ray has exited the volume\n\t\tif ( any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\t\t\n\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tpos += rayStep;\n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\t\t\n\t\t// Get the current pixel value and compare it with the maximum\n\t\tif (!uMaskEnabled || !isMasked(pos)) { \n\t\t\tmaxPixVal = max( maxPixVal, getPixVal(pos) );\t\n\t\t}\t\n\t\t\t\n\t\t// Check whether to display a marker\n\t\trayToMarkerDist = min(rayToMarkerDist, length((pos-uMarkerLoc)*VolAspect));\t\n\n\t\tpos += rayStep;\n\t}\n\n\t// Encode the 16-bit pixel value in two 8-bit color channels\t\n\tmaxPixVal *= 255.0;\n\tmaxPixVal = max(maxPixVal, 1.0); // Don't allow zero, as we use zero to indicate background\n\tfloat highByte = floor(maxPixVal/256.0);\n\tfloat lowByte = maxPixVal - 256.0*highByte;\n\tfloat b = float(uShowMarker) * max(0.0, 1.0-rayToMarkerDist/uMarkerSize);\n    gl_FragColor = vec4(lowByte/255.0, highByte/255.0, b, 1.0);\n\treturn true;\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the location of the maximum intensity point along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcPickLocation(vec3 rayDir)\n{\n    if (!uPickMode) { return false; }\n\n\tfloat tol = 1.0; // NB: Units here are pixels, not fractional texture coordinates\n\tif ( (abs(gl_FragCoord.x - uPickPoint.x) > tol) ||  (abs(gl_FragCoord.y - uPickPoint.y) > tol) ) \n\t{\n\t\t// Skip the computation if this is not the target fragment\n\t\tgl_FragColor = vec4(0.0);\n\t}\n\telse\n\t{\n        // Initialize some globals\n        NumMosaicsM1 = uNumTextures - 1;\t\n        NzM1 = uVolNumImages - 1.0;\n        MxInv = 1.0/uMosaicDims[0];\n        MyInv = 1.0/uMosaicDims[1];    \n        MinvFirst = vec2(1.0/uMosaicDims[0], 1.0/uMosaicDims[1]);\n        MinvLast  = vec2(1.0/uMosaicDims[2], 1.0/uMosaicDims[3]);\n\t\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\n\t\t// Initialize the ray\n\t\tvec3 pos = vRayStartT;\n\t\tvec3 rayStep = rayDir*uRayStepSize;\n\t\tbool enteredSlab = false;\n\t\t\n\t\t// Initialize slab variables\n\t\t#ifdef CLIP_TO_SLAB\n\t\tfloat slabOffset;\n\t\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\t\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t\t#endif\n\t\n\t\t// Initialize max info\n\t\tfloat maxPixVal = 0.0;\n\t\tvec3 maxLoc = vec3(-1.0);\n\n\t\t// Walk along the ray\n\t\tfor (int i = 0; i < 32768; i++)\n\t\t{\t\n\t\t\t// Check whether the ray has exited the volume\t\t\t\n\t\t\tif ( any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\t\t\n\n\t\t\t// Honor any slab constraints\n\t\t\t#ifdef CLIP_TO_SLAB\n\t\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\t\tif ( enteredSlab ) { break; }\n\t\t\t\tpos += rayStep;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tenteredSlab = true;\n\t\t\t#endif\n\t\t\t\n\t\t\tif (!uMaskEnabled || !isMasked(pos)) { \n\t\t\t\tfloat pixVal = getPixVal(pos);\n\t\t\t\tif (pixVal > maxPixVal) {\n\t\t\t\t\tmaxPixVal = pixVal;\n\t\t\t\t\tmaxLoc = pos;\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos += rayStep;\n\t\t}\n\n\t\t// Encode the max location in the output color\t\n\t\tgl_FragColor = encodeVec3(maxLoc);\n\t}\n\treturn true;\n}\n\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tvec3 slabAxis0 = normalize(p1 - p0);\n\tvec3 slabAxis1 = normalize(p2 - p0);\n\tvec3 slabAxis2 = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*slabAxis0.x,  VolAspect.x*slabAxis1.x,  VolAspect.x*slabAxis2.x,  0.0,\n\t\tVolAspect.y*slabAxis0.y,  VolAspect.y*slabAxis1.y,  VolAspect.y*slabAxis2.y,  0.0,\n\t\tVolAspect.z*slabAxis0.z,  VolAspect.z*slabAxis1.z,  VolAspect.z*slabAxis2.z,  0.0,\n       -dot(slabCtr, slabAxis0), -dot(slabCtr, slabAxis1), -dot(slabCtr, slabAxis2),  1.0\n\t);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Encodes the components of a vec3 in an rgba color.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 encodeVec3(vec3 loc)\n{\n\tif ( any(lessThan(loc,Zeros)) || any(greaterThan(loc,Ones)) ) \n\t{\n\t\t// We indicate an invalid value by setting the rightmost bit\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t}\t\n\n\t// Use 10 bits for each coordinate\n\thighp int xi = int( min(1023.0, (loc.x*1023.0 + 0.5)) );\n\thighp int yi = int( min(1023.0, (loc.y*1023.0 + 0.5)) );\n\thighp int zi = int( min(1023.0, (loc.z*1023.0 + 0.5)) );\n\n\tint zLo = zi - (zi/128) * 128;\n\tint zHi = (zi - zLo)/128;\n\n\tint yLo = yi - (yi/32) * 32;\n\tint yHi = (yi - yLo)/32;\n\n\tint xLo = xi - (xi/8) * 8;\n\tint xHi = (xi - xLo)/8;\n\n\tfloat a = float(zLo*2)/255.0;\n\tfloat b = float(zHi + 8*yLo)/255.0;\n\tfloat g = float(yHi + 32*xLo)/255.0;\n\tfloat r = float(xHi)/255.0;\n\n\treturn vec4(r, g, b, a);\n}\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point. \n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.5) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.5) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel values\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif ( sliceBelowIsEven ) \n\t{\n\t\tpixValB = dot(sampB.rg, ByteMask);\n\t\tpixValA = dot(sampB.ba, ByteMask);\n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.5) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\t\t\n\t\tpixValB = dot(sampB.ba, ByteMask);\n\t\tpixValA = dot(sampA.rg, ByteMask); \n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.25) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.25) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.25) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n \n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.5) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.5) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif (sliceBelowIsEven) \n\t{\n\t\tpixValB = dot(sampB, ByteMaskRG); \n\t\tpixValA = dot(sampB, ByteMaskBA); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.5) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = dot(sampB, ByteMaskBA);\n\t\tpixValA = dot(sampA, ByteMaskRG);\n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.25) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.25) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) components\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.25) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Samples a given texture at a given texture coordinate.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 sampleTexture(vec2 tc, int textureIndex)\n{\n\t// Performance seems to be better if we unroll the first few terms:\n\tif (textureIndex == 0) {\n\t\treturn texture2D(uSamplers[0], tc);\n\t}\n\t#if NUM_IMAGE_TEXTURES >= 2\n\telse if (textureIndex == 1) {\n\t\treturn texture2D(uSamplers[1], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 3\n\telse if (textureIndex == 2) {\n\t\treturn texture2D(uSamplers[2], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 4\n\telse if (textureIndex == 3) {\n\t\treturn texture2D(uSamplers[3], tc);\n\t} \n\t#endif\n\t#endif\n\t#endif\n\telse \n\t{\n\t\tfor (int i=4; i<NUM_IMAGE_TEXTURES; i++) \n\t\t{\n\t\t\tif (i == textureIndex) { return texture2D(uSamplers[i], tc);}\n\t\t}\n\t}\n} \n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture2D(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,k){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.shadows_vert_1="// shadows_vert_1\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nuniform mat4   uShadowMvpTransform;\nuniform mat4   uShadowMvpInvTransform;\nattribute vec4 aPosition;\nvarying vec3   vRayStartT;\nvarying vec3   vRayDirT;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space\n    gl_Position = uShadowMvpTransform * aPosition; \n\n    // Pass the ray's starting point and direction, in texture coordinates, to the fragment shader\n    vRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = (uShadowMvpInvTransform * vec4(0.0, 0.0, 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.shadows_frag_1=
"// shadows_frag_1\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\nprecision highp sampler2D;\n\n// Uniforms and varyings\nuniform sampler2D  uSampler;                      // For volumes that fit in a single texture\nuniform sampler2D  uSamplers[NUM_IMAGE_TEXTURES]; // For volumes that are split across multiple textures\nuniform sampler2D  uLutSampler;\nuniform sampler2D  uMaskSampler;\nuniform bool       uMaskEnabled;\nuniform vec3   uVolShape;\nuniform float  uVolNumImages;\nuniform vec4   uMosaicDims;\nuniform int    uNumTextures;\nuniform float  uRayStepSize;\nuniform float  uOpacityRange[2];\nuniform float  uSlabInfo[24];\nuniform mat4   uShadowMvpTransform;\n\nvarying  vec3  vRayStartT;\nvarying  vec3  vRayDirT;\n\n// Constants\nconst vec3 Ones             = vec3(1.0);\nconst vec3 Zeros            = vec3(0.0);\nconst float BBoxTol         = 0.002; \nconst vec3 BboxMin          = vec3(-BBoxTol);\nconst vec3 BboxMax          = vec3(1.0+BBoxTol);\nconst float TransparencySat = 0.02; // Saturation value\nconst vec2 ToFloat16        = vec2(256.0, 1.0)/257.0; // For converting a pair of bytes to a float \nconst vec4 ByteMaskRG       = vec4(1.0, 256.0, 0.0, 0.0);\nconst vec4 ByteMaskBA       = vec4(0.0, 0.0, 1.0, 256.0);\nconst vec2 ByteMask         = vec2(1.0, 256.0);\n\n// Globals\nfloat PixScale, PixOffset;\nfloat NzM1, MxInv, MyInv;\nint NumMosaicsM1;\nvec2 MinvFirst, MinvLast; \nvec3 VolAspect;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii, SlabAxes[3];\nmat4 SlabXfrm;\n#endif\n\n// Function prototypes\nvec4 renderShadowMap(vec3);\nfloat getNormalizedPixVal(vec3);\nvec4  sampleTexture(vec2, int);\nvec4  encodeFloat(float);\nbool isMasked(vec3 pos);\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n\t// Initialize globals\n\tPixScale  = 255.0 * uOpacityRange[1];\n\tPixOffset = uOpacityRange[0] * uOpacityRange[1];\n\n\t// Compute the shadow map\n    gl_FragColor = renderShadowMap( normalize(vRayDirT) );\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the shadow map.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 renderShadowMap(vec3 rayDir)\n{\n\t// Initialize some globals\n\tNumMosaicsM1 = uNumTextures - 1;\t\n\tNzM1 = uVolNumImages - 1.0;\n\tMxInv = 1.0/uMosaicDims[0];\n\tMyInv = 1.0/uMosaicDims[1];\n\tMinvFirst = vec2(1.0/uMosaicDims[0], 1.0/uMosaicDims[1]);\n\tMinvLast  = vec2(1.0/uMosaicDims[2], 1.0/uMosaicDims[3]);\n\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\t\n\t// Initialize locals\n\tfloat stepSize   = uRayStepSize;\n\tvec3  rayStep    = stepSize * rayDir;\n\tfloat opacityExp = stepSize * 128.0;\n\tfloat bestDelta  = -1.0; \n\tfloat bestDepth  =  1.0;\n\tvec4 shadowMvp   = vec4(uShadowMvpTransform[0][2], uShadowMvpTransform[1][2], uShadowMvpTransform[2][2], uShadowMvpTransform[3][2]);\n\n\t// Initialize the ray\n\tvec3 pos        = vRayStartT;\n\tfloat tTot      = 1.0;\n\tfloat tBase     = 1.0;\n\tbool climbing   = false;\n\tbool enteredSlab = false;\n\t\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\n\n\t// Walk along the ray, looking for the largest jump in opacity\n\tfor (int i = 0; i < 32768; i++)\n\t{\t\t\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\t\t\t\n\t\t\tpos += rayStep; \n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\n\t\tif (uMaskEnabled && isMasked(pos)) { \n\t\t\tpos += rayStep; \n\t\t\tcontinue; \n\t\t}\n\t\t\t\n\t\t// Get the cuurent voxel's opacity \n\t\tfloat opac = texture2D( uLutSampler, vec2(getNormalizedPixVal(pos), LUT_TX_YOFFSET)).a;\n\t\tif (opac == 0.0)\n\t\t{\n\t\t\t// We have entered an empty-space region, so increase the stepsize\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\n\t\t}\n\t\telse if (stepSize > 1.5*uRayStepSize) \n\t\t{\n\t\t\t// Revert to normal-size steps, and back-up a bit\n\t\t\tstepSize = uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\n\t\t\tpos -= rayStep;\n\t\t\topac = texture2D( uLutSampler, vec2(getNormalizedPixVal(pos), LUT_TX_YOFFSET)).a;\n\t\t}\n\n\t\t// Update the accumulated transparency\n\t\tfloat t = pow(max(0.0, 1.0-opac), opacityExp);\n\t\ttBase = mix(tBase, tTot, float(!climbing));\n\t\ttTot *= t;\n\t\tclimbing = climbing || (t < 0.99);\n\n\t\t// Check whether we are ending a climb, or maybe even the whole ray\n\t\tvec3 nextPos = pos + rayStep;\n\t\tbool terminateRay = (tTot < TransparencySat) || any(lessThan(nextPos, BboxMin)) || any(greaterThan(nextPos, BboxMax));\n\t\tif ( climbing && ((t >= 0.99) || terminateRay) ) // We are ending a climb\n\t\t{\n\t\t\tclimbing = false;\n\t\t\tfloat delta = tBase - tTot; \n\t\t\tfloat improved = float(delta > bestDelta);\n\t\t\tbestDelta = mix(bestDelta, delta, improved);\n\t\t\tbestDepth = mix(bestDepth, dot(shadowMvp, vec4(pos-0.5, 1.0)), improved);\n\t\t\tterminateRay = terminateRay || (bestDelta >= tTot);  \t\t\t\t\n\t\t}\n\t\tif (terminateRay) { break; }\n\n\t\tpos = nextPos;\n\t}\n\t\n\t// Return the best depth estimate\n\tfloat d = (bestDepth + 1.0)/2.0; // Ranges between 0.0 and 1.0\n\treturn encodeFloat(d);\n}\n\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tSlabAxes[0] = normalize(p1 - p0);\n\tSlabAxes[1] = normalize(p2 - p0);\n\tSlabAxes[2] = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*SlabAxes[0].x,  VolAspect.x*SlabAxes[1].x,  VolAspect.x*SlabAxes[2].x,  0.0,\n\t\tVolAspect.y*SlabAxes[0].y,  VolAspect.y*SlabAxes[1].y,  VolAspect.y*SlabAxes[2].y,  0.0,\n\t\tVolAspect.z*SlabAxes[0].z,  VolAspect.z*SlabAxes[1].z,  VolAspect.z*SlabAxes[2].z,  0.0,\n       -dot(slabCtr, SlabAxes[0]), -dot(slabCtr, SlabAxes[1]), -dot(slabCtr, SlabAxes[2]),  1.0\n\t);\n}\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Encodes a float value in the first two components of a vec4.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 encodeFloat(float val)\n{\n\tfloat cVal = 65535.0 * clamp(val, 0.0, 1.0);\n\tfloat dHi = floor(cVal/256.0);\n\tfloat dLo = cVal - dHi*256.0;\n\treturn vec4(dHi/255.0, dLo/255.0, 0.0, 1.0);\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Samples a given texture at a given texture coordinate.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 sampleTexture(vec2 tc, int textureIndex)\n{\n\t// Performance seems to be better if we unroll the first few terms:\n\tif (textureIndex == 0) {\n\t\treturn texture2D(uSamplers[0], tc);\n\t}\n\t#if NUM_IMAGE_TEXTURES >= 2\n\telse if (textureIndex == 1) {\n\t\treturn texture2D(uSamplers[1], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 3\n\telse if (textureIndex == 2) {\n\t\treturn texture2D(uSamplers[2], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 4\n\telse if (textureIndex == 3) {\n\t\treturn texture2D(uSamplers[3], tc);\n\t} \n\t#endif\n\t#endif\n\t#endif\n\telse \n\t{\n\t\tfor (int i=4; i<NUM_IMAGE_TEXTURES; i++) \n\t\t{\n\t\t\tif (i == textureIndex) { return texture2D(uSamplers[i], tc);}\n\t\t}\n\t}\n} \n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point. \n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.5) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.5) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel values\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif ( sliceBelowIsEven ) \n\t{\n\t\tpixValB = dot(sampB.rg, ByteMask);\n\t\tpixValA = dot(sampB.ba, ByteMask);\n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.5) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\t\t\n\t\tpixValB = dot(sampB.ba, ByteMask);\n\t\tpixValA = dot(sampA.rg, ByteMask); \n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.25) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.25) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.25) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.5) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.5) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif (sliceBelowIsEven) \n\t{\n\t\tpixValB = dot(sampB, ByteMaskRG); \n\t\tpixValA = dot(sampB, ByteMaskBA); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.5) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = dot(sampB, ByteMaskBA);\n\t\tpixValA = dot(sampA, ByteMaskRG);\n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.25) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.25) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.25) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\t\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture2D(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,k){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.slab_vert_1="// slab_vert_1\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float;\nprecision highp int;\n\nattribute vec4 aPosition;\nattribute vec4 aColor;\nvarying vec4   vColor;\nuniform mat4   uMvpTransform;\nuniform float  uPersp;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    gl_Position = uMvpTransform * aPosition;\n    gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0);\n    vColor = aColor;\n}\n";b.ShaderCode.slab_frag_1=
"// slab_frag_1\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; \nprecision highp int;\nvarying vec4    vColor;\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    gl_FragColor = vColor;\n}\n"})(window.BigLime=window.BigLime||{});
(function(b,k){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.vr_vert_1="// vr_vert_1\n//-----------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nattribute vec4 aPosition;\nuniform mat4   uMvpTransform;\nuniform mat4   uMvpInvTransform;\nuniform float  uPersp;\nvarying vec3   vRayStartT;\nvarying vec3   vRayDirT;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition;\n    float w = gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0); \n\n\t// Pass the ray's starting point and direction to the fragment shader (in texture coordinates).\n\t// Note that scaling of vRayDirT by w is necessary for perspective-correct interpolation.\n\tvRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = w * (uMvpInvTransform * vec4(gl_Position.xy*(uPersp/w), 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.vr_frag_1=
"// vr_frag_1\n//-----------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\nprecision highp sampler2D;\n\n// Uniforms and varyings\nuniform sampler2D  uSampler;                      // For volumes that fit in a single texture\nuniform sampler2D  uSamplers[NUM_IMAGE_TEXTURES]; // For volumes that span multiple textures\nuniform sampler2D  uLutSampler;\nuniform sampler2D  uMaskSampler;\nuniform bool       uMaskEnabled;\nuniform vec3   uVrBackColor;\nuniform vec3   uVolShape;\nuniform float  uVolNumImages;\nuniform vec4   uMosaicDims;\nuniform int    uNumTextures;\nuniform float  uRayStepSize;\nuniform vec2   uOutBufferSize;\nuniform float  uOpacityRange[2];\nuniform int    uAntiAlias;\nuniform float  uSlabInfo[24];\nuniform bool   uSealBorders;\nuniform bool   uPickMode;\nuniform vec2   uPickPoint;\nuniform bool   uShowMarker;\nuniform vec3   uMarkerLoc;\nuniform float  uMarkerSize;\nuniform vec4   uMarkerColor;\nuniform mat4   uModelTransform;\nuniform mat4   uViewTransform;\nuniform float  uAmbientLight;\nstruct Light {\n\tfloat diffuse;\n\tfloat specStrength;\n\tfloat specExp;\n\tfloat shadowDarkness;\n\tfloat shadowSoftness;\n\tvec3  dir;\n\tmat4  shadowMvp;\n};\nuniform Light uLights[2];\n\n#ifdef RENDER_GRAPHICS\nuniform sampler2D uGfxSampler;\nuniform float uGfxBlendWeight;\n#endif\n#ifdef RENDER_SHADOWS\nuniform sampler2D uShadowSampler;\n#endif\n\nvarying vec3 vRayStartT;\nvarying vec3 vRayDirT;\n\n \n// Constants\nvec3 UnitVectors[3];\nconst vec3 Ones             = vec3(1.0);\nconst vec3 Zeros            = vec3(0.0);\nconst float BBoxTol         = 0.002; \nconst vec3 BboxMin          = vec3(-BBoxTol);\nconst vec3 BboxMax          = vec3(1.0 + BBoxTol);\nconst float TransparencySat = 0.02; // Saturation value\nconst vec2 ToFloat16        = vec2(256.0, 1.0)/257.0; // For converting a pair of bytes to a float \nconst vec4 ByteMaskRG       = vec4(1.0, 256.0, 0.0, 0.0);\nconst vec4 ByteMaskBA       = vec4(0.0, 0.0, 1.0, 256.0);\nconst vec2 ByteMask         = vec2(1.0, 256.0);\n\n// Globals\nfloat PixScale, PixOffset;\nfloat NzM1, MxInv, MyInv;\nint NumMosaicsM1;\nvec2 MinvFirst, MinvLast; \nvec3 VolAspect;\nvec3 BorderNormal, GradOffset;\nfloat BorderNormalWeight, BorderReflectanceWeight;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii, SlabAxes[3];\nmat4 SlabXfrm;\n#endif\n\n\n// Function prototypes\nbool  calcVrValue(vec3);\nbool  calcPickLocation(vec3);\nfloat getNormalizedPixVal(vec3);\nvec4  sampleTexture(vec2, int);\nvoid  getBorderInfo(vec3, vec3, vec3, float, vec3);\nfloat rand(vec2);\nvec4  encodeVec3(vec3);\nbool isMasked(vec3 pos);\n\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n#ifdef RENDER_SHADOWS\nfloat calcShadowWeight(vec3, int);\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\t\t\n\t// Initialize globals\n\tPixScale  = 255.0 * uOpacityRange[1];\n\tPixOffset = uOpacityRange[0] * uOpacityRange[1];\n\t\n\t// Perform ray casting\n\tvec3 rayDir = normalize(vRayDirT);\n\tbool stat = calcPickLocation(rayDir) || calcVrValue(rayDir);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the integrated color and opacity along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcVrValue(vec3 rayDir)\n{\n\t// Initialize some globals\n\tNumMosaicsM1 = uNumTextures - 1;\t\n\tNzM1 = uVolNumImages - 1.0;\n\tMxInv = 1.0/uMosaicDims[0];\n\tMyInv = 1.0/uMosaicDims[1];\n    MinvFirst = vec2(1.0/uMosaicDims[0], 1.0/uMosaicDims[1]);\n\tMinvLast  = vec2(1.0/uMosaicDims[2], 1.0/uMosaicDims[3]);\n\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\t\n\t// Initialize constants\n\tUnitVectors[0]      = vec3(1.0, 0.0, 0.0);\n\tUnitVectors[1]      = vec3(0.0, 1.0, 0.0);\n\tUnitVectors[2]      = vec3(0.0, 0.0, 1.0);\t\n\tvec3 gdx            = vec3(1.0/uVolShape[0], 0.0, 0.0);      // Offset for computing grad.x\n\tvec3 gdy            = vec3(0.0, 1.0/uVolShape[1], 0.0);      // Offset for computing grad.y\n\tvec3 gdz            = vec3(0.0, 0.0, 1.0/uVolShape[2]);      // Offset for computing grad.z\n\tvec3 gradDelta      = 1.5 * vec3(gdx.x, gdy.y, gdz.z);       // Offsets for computing gradients near borders\n\tfloat stepSize      = uRayStepSize;                          // The step-size for raycasting\n\tvec3 rayStep        = uRayStepSize * rayDir;                 // The ray increment\n\tfloat opacityExp    = uRayStepSize * 128.0;                  // For scaling the opacity to the ray step size\n\tfloat borderThresh  = uRayStepSize * 5.0;                    // Distance threshold for shading border surfaces\n\tfloat random        = rand(gl_FragCoord.xy);                 // For antialiasing\n\tint randIndex       = int(10.0*random + 1.0);\n\tfloat randRayOffset = float(uAntiAlias) * uRayStepSize * (random - 0.5); \n\n\t// Default border values\n\tBorderNormal = vec3(1.0, 0.0, 0.0);\n\tBorderNormalWeight = 0.0;\n\tBorderReflectanceWeight = 1.0;\n\tGradOffset = vec3(0.0);\n\n\t// Initialize the ray\n\tfloat tTot            = 1.0;                                 // Accumulated transparency\n\tvec3 cTot             = vec3(0.0);                           // Accumulated color\n\tvec3 pos              = vRayStartT;                          // Current ray position\n\tvec3 pos_s            = vec3(0.0);                           // Current ray position in slab coordinates\n\tfloat currPixVal      = getNormalizedPixVal(pos);\n\tfloat prevPixVal      = 0.0;\n\tfloat nextPixVal      = 0.0;\n\tvec3 prevGrad         = vec3(0.0);\t\n\tfloat perpMarkerDist  = length( cross( (pos-uMarkerLoc)*VolAspect, normalize(rayDir*VolAspect) ) );\n\tbool omitMarkerTest   = !uShowMarker || (perpMarkerDist > uMarkerSize);\n\tbool enteredSlab      = false;\n\t\n\t#ifdef RENDER_GRAPHICS\n\tvec2 fragCoord = 0.5*gl_FragCoord.xy/uOutBufferSize;\n\tvec4 gfxColor0 = texture2D(uGfxSampler, vec2(fragCoord.x,       fragCoord.y      ));\n\tvec4 gfxDepth0 = texture2D(uGfxSampler, vec2(fragCoord.x + 0.5, fragCoord.y      ));\n\tvec4 gfxColor1 = texture2D(uGfxSampler, vec2(fragCoord.x,       fragCoord.y + 0.5));\n\tvec4 gfxDepth1 = texture2D(uGfxSampler, vec2(fragCoord.x + 0.5, fragCoord.y + 0.5));\n\tfloat depth0 = 2.0* dot(gfxDepth0.ba, ToFloat16) - 1.0;\n\tfloat depth1 = 2.0* dot(gfxDepth1.ba, ToFloat16) - 1.0;\n\tbool omitG0Test = (depth0 > 0.999);\n\tbool omitG1Test = (depth1 > 0.999);\n\tmat4 mvTransform = uViewTransform * uModelTransform;\n\tvec4 mvTransformZ = vec4(mvTransform[0][2], mvTransform[1][2], mvTransform[2][2], mvTransform[3][2]);\n\t#endif\n\n\tfloat prevShadowWeight0 = -1.0;\n\tfloat prevShadowWeight1 = -1.0;\n\tfloat sh0 = uLights[0].shadowDarkness;\n\tfloat sh1 = uLights[1].shadowDarkness;\n\tfloat drel0 = (uLights[0].diffuse == uLights[1].diffuse) ? 0.5 : uLights[0].diffuse/(uLights[0].diffuse + uLights[1].diffuse + 0.0001);\n\tfloat drel1 = 1.0 - drel0;\n\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\n\n\t// Walk along the ray\n\tfor (int i = 0; i < 32768; i++)\n\t{\t\t\n\t\t// We're done if the ray has exited the volume, or if the opacity threshold is exceeded\n\t\tif ( (tTot < TransparencySat) || any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\n\n\t\t// Does the current ray position intersect the marker?\n\t\tif (!omitMarkerTest)\n\t\t{\t\n\t\t\tvec3 pmVec = (pos - uMarkerLoc)*VolAspect;\t\n\t\t\tif ( length(pmVec) <= uMarkerSize ) {\n\t\t\t\tfloat pmPerpDist = length( cross(pmVec, normalize(rayDir*VolAspect)) );\n\t\t\t\tfloat shade = mix(1.0 - pmPerpDist/uMarkerSize, 1.0, 0.4);\n\t\t\t\tcTot += shade * uMarkerColor.rgb * uMarkerColor.a * tTot;\n\t\t\t\ttTot *= 1.0 - uMarkerColor.a;\n\t\t\t\tomitMarkerTest = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t\t\t\t\n\t\t// Apply random ray offset for antialiasing\n\t\tpos += (float(i == randIndex) * randRayOffset) * rayDir;\n\n\t\t#ifdef RENDER_GRAPHICS\t\t\n\t\tif ( !omitG0Test || !omitG1Test )\n\t\t{\t\n\t\t\tfloat gPosZ = dot(mvTransformZ, vec4(pos-0.5, 1.0));\n\t\t\tif ((!omitG1Test) && (gPosZ > depth1)) {\n\t\t\t\tcTot += gfxColor1.rgb * gfxColor1.a * tTot;\n\t\t\t\tcTot = mix(cTot, gfxColor1.rgb, uGfxBlendWeight);\n\t\t\t\ttTot *= 1.0 - gfxColor1.a;\n\t\t\t\tomitG1Test = true;\n\t\t\t\tcontinue;\t\t\t\n\t\t\t}\n\t\t\tif ((!omitG0Test) && (gPosZ > depth0)) {\n\t\t\t\tcTot += gfxColor0.rgb * gfxColor0.a * tTot;\n\t\t\t\tcTot = mix(cTot, gfxColor0.rgb, uGfxBlendWeight);\n\t\t\t\ttTot *= 1.0 - gfxColor0.a;\n\t\t\t\tomitG0Test = true;\n\t\t\t\tcontinue;\t\t\t\n\t\t\t}\n\t\t}\n\t\t#endif\t\t\n\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tpos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tprevPixVal = 0.0;  currPixVal = 0.0;\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\t\t\t\n\t\t\tpos += rayStep;  \n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\n\t\t// Get the pixel value. Use 3-point averaging along the ray\n\t\tnextPixVal = getNormalizedPixVal(pos + rayStep);\n\t\tfloat pixVal = 0.25*( prevPixVal + 2.0*currPixVal + nextPixVal );\n\t\tprevPixVal = currPixVal;  currPixVal = nextPixVal;\n\n\t\t// Check the opacity value\n\t\tvec4 lutVal = (uMaskEnabled && isMasked(pos)) ? vec4(0.0) : texture2D(uLutSampler, vec2(pixVal, LUT_TX_YOFFSET)); \n\n\t\tif (lutVal.a == 0.0)\n\t\t{\n\t\t\t// We have entered an empty-space region, so increase the stepsize\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (stepSize > 1.5*uRayStepSize) {\n\t\t\t\t// Revert to normal-size steps, and back-up\n\t\t\t\tstepSize    = uRayStepSize;\n\t\t\t\trayStep     = stepSize*rayDir;\n\t\t\t\tpos        -= rayStep;\n\t\t\t\tcurrPixVal  = getNormalizedPixVal(pos);\n\t\t\t\tprevPixVal  = getNormalizedPixVal(pos - rayStep);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check whether we are near a border\n\t\t\tif (uSealBorders) {\n\t\t\t\tgetBorderInfo(pos, rayDir, pos_s, borderThresh, gradDelta);\n\t\t\t}\n\n\t\t\t// Compute the intensity gradient\n\t\t\tvec3 gpos = pos + GradOffset;\n\t\t\tvec3 grad = vec3( \n\t\t\t\tgetNormalizedPixVal(gpos + gdx) - getNormalizedPixVal(gpos - gdx),\n\t\t\t\tgetNormalizedPixVal(gpos + gdy) - getNormalizedPixVal(gpos - gdy),\n\t\t\t\tgetNormalizedPixVal(gpos + gdz) - getNormalizedPixVal(gpos - gdz) );\t\n\n\t\t\t// Modify the gradient near borders\n\t\t\tgrad = mix(grad, BorderNormal, BorderNormalWeight);\n\t\t\tgrad = mix(grad, prevGrad, 0.5);\n\t\t\tprevGrad = grad;\n\t\t\tfloat gradMag = length(grad);\n\n\t\t\t// Compute the lighting factors\n\t\t\tvec3 N = grad/gradMag;\n\t\t\tvec3 L0 = uLights[0].dir;\n\t\t\tvec3 L1 = uLights[1].dir;\n\t\t\tvec3 R0 = reflect(-1.0*L0, N); // Assumes that L0, L1 are normalized\n\t\t\tvec3 R1 = reflect(-1.0*L1, N);\n\n\t\t\tfloat diffuse0 = 2.0 * uLights[0].diffuse * max(0.0, dot(N,L0));\n\t\t\tfloat diffuse1 = 2.0 * uLights[1].diffuse * max(0.0, dot(N,L1));\n\n\t\t\tfloat sdot0 = max(0.0, dot(R0, rayDir));\n\t\t\tfloat sdot1 = max(0.0, dot(R1, rayDir));\n\t\t\tfloat specular0 = 2.0 * uLights[0].specStrength * pow(sdot0, uLights[0].specExp);\n\t\t\tfloat specular1 = 2.0 * uLights[1].specStrength * pow(sdot1, uLights[1].specExp);\n\n\t\t\tfloat dsFactor = float(gradMag > 0.001)*BorderReflectanceWeight;\n\t\t\tfloat light0 = uAmbientLight*drel0 + (diffuse0 + specular0)*dsFactor; \n\t\t\tfloat light1 = uAmbientLight*drel1 + (diffuse1 + specular1)*dsFactor; \n\n\t\t\t// Maybe draw shadows\n\t\t\t#ifdef RENDER_SHADOWS\n\t\t\tif (sh0 > 0.0) { \n\t\t\t\tfloat shadowWeight0 = ((prevShadowWeight0 < 0.0) || (tTot > 0.10)) ? calcShadowWeight(pos,0) : prevShadowWeight0;\n\t\t\t\tlight0 *= max(0.0, 1.0-sh0*shadowWeight0);\n\t\t\t\tprevShadowWeight0 = shadowWeight0;\n\t\t\t}\n\t\t\tif (sh1 > 0.0) {\n\t\t\t\tfloat shadowWeight1 = ((prevShadowWeight1 < 0.0) || (tTot > 0.10)) ? calcShadowWeight(pos,1) : prevShadowWeight1;\n\t\t\t\tlight1 *= max(0.0, 1.0-sh1*shadowWeight1); \n\t\t\t\tprevShadowWeight1 = shadowWeight1;\n\t\t\t}\n\t\t\t\t#endif // RENDER_SHADOWS\n\n\t\t\t// Update the total color\n\t\t\tfloat light = light0 + light1;\n\n\t\t\t// Update the total color\n\t\t\tfloat t = pow(max(0.0, 1.0-lutVal.a), opacityExp);\n\t\t\tvec3 c = lutVal.rgb * (1.0 - t) * light;\n\t\t\tcTot += c*tTot;\n\t\t\ttTot *= t;\n\t\t}\n\t\t\t\n\t\tpos += rayStep;\n\t}\n\t\n\tcTot += uVrBackColor*tTot;\n\tgl_FragColor = vec4(cTot, 1.0);\n\treturn true;\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the location of the most salient point along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcPickLocation(vec3 rayDir)\n{\n    if (!uPickMode) { return false; }\n\n\tfloat tol = 1.0; // NB: Units here are pixels, not fractional texture coordinates\n\tif ( (abs(gl_FragCoord.x - uPickPoint.x) > tol) ||  (abs(gl_FragCoord.y - uPickPoint.y) > tol) ) \n\t{\n\t\t// Skip the computation if this is not the target fragment\n\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t}\n\telse\n\t{\n\t\t// Initialize some globals\n        NumMosaicsM1 = uNumTextures - 1;\t\n        NzM1 = uVolNumImages - 1.0;\n        MxInv = 1.0/uMosaicDims[0];\n        MyInv = 1.0/uMosaicDims[1];\n        MinvFirst = vec2(1.0/uMosaicDims[0], 1.0/uMosaicDims[1]);\n        MinvLast  = vec2(1.0/uMosaicDims[2], 1.0/uMosaicDims[3]);\n\t\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\n\t\t// Initialize locals\n\t\tvec3 rayStep         = uRayStepSize * rayDir;\n\t\tfloat opacityExp     = uRayStepSize * 128.0;\n\t\tvec3 maxLoc          = vec3(-1.0);\n\t\tvec3 runStart        = vec3(-1.0);\n\t\tfloat bestDelta      = -1.0; \n\n\t\t// Initialize the ray\n\t\tvec3 pos = vRayStartT;\n\t\tfloat tTot = 1.0;\n\t\tfloat tBase = -1.0;\n\t\t\n\t\t// Initialize slab variables\n\t\t#ifdef CLIP_TO_SLAB\n\t\tfloat slabOffset;\n\t\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\t\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t\t#endif\n\n\t\t// Walk along the ray\n\t\tfor (int i = 0; i < 32768; i++)\n\t\t{\t\t\n\t\t\t// Honor any slab constraints\n\t\t\t#ifdef CLIP_TO_SLAB\n\t\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\t\tpos += rayStep;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t#endif\n\n\t\t\t// Update the accumulated transparency\n\t\t\tfloat opac = (uMaskEnabled && isMasked(pos)) ? 0.0 : texture2D(uLutSampler, vec2(getNormalizedPixVal(pos), LUT_TX_YOFFSET)).a;\n\t\t\tfloat t = pow( max(0.0, 1.0-opac), opacityExp);\n\t\t\ttTot *= t;\n\n\t\t\t// Check whether the transparency is strictly decreasing\n\t\t\tif ( (t < 0.99) && (runStart.x < 0.0) )  \n\t\t\t{ \n\t\t\t\trunStart = pos; // The voxel has some opacity, so we are starting a new run\n\t\t\t\ttBase = tTot;\n\t\t\t}\n\n\t\t\tvec3 nextPos = pos + rayStep;\n\t\t\tbool terminateRay = (tTot < TransparencySat) || any(lessThan(nextPos, BboxMin)) || any(greaterThan(nextPos, BboxMax));\n\t\t\tif ( (runStart.x >= 0.0) && ((t >= 0.99) || terminateRay) ) // We are ending a run\n\t\t\t{\n\t\t\t\tfloat delta = tBase - tTot; \n\t\t\t\tfloat improved = float(delta > bestDelta);\n\t\t\t\tbestDelta = mix(bestDelta, delta, improved);\n\t\t\t\tmaxLoc = mix(maxLoc, runStart, improved);\n\t\t\t\trunStart = vec3(-1.0); \t\n\t\t\t\tterminateRay = terminateRay || (bestDelta >= tTot);  \t\t\t\n\t\t\t}\n\t\t\tif (terminateRay) { break; }\t\t\n\n\t\t\tpos = nextPos;\n\t\t}\n\t\t\n\t\t// Encode the max location in the output color\t\n\t\tgl_FragColor = encodeVec3(maxLoc);\n\t}\n\treturn true;\n}\n\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tSlabAxes[0] = normalize(p1 - p0);\n\tSlabAxes[1] = normalize(p2 - p0);\n\tSlabAxes[2] = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*SlabAxes[0].x,  VolAspect.x*SlabAxes[1].x,  VolAspect.x*SlabAxes[2].x,  0.0,\n\t\tVolAspect.y*SlabAxes[0].y,  VolAspect.y*SlabAxes[1].y,  VolAspect.y*SlabAxes[2].y,  0.0,\n\t\tVolAspect.z*SlabAxes[0].z,  VolAspect.z*SlabAxes[1].z,  VolAspect.z*SlabAxes[2].z,  0.0,\n       -dot(slabCtr, SlabAxes[0]), -dot(slabCtr, SlabAxes[1]), -dot(slabCtr, SlabAxes[2]),  1.0\n\t);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the distance to the nearest border, and the normal vector of\n//   that border.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid getBorderInfo(vec3 pos, vec3 rayDir, vec3 pos_s, float borderThresh, vec3 gradDelta)\n{\n\t// Check the volume borders\n\tfloat minDist = borderThresh + 1.0;\n\tbool isSlabBorder = false;\n\t\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tfloat p = abs(pos[i]);\n\t\tif (p < minDist) { minDist = p;  BorderNormal = UnitVectors[i]; }\t\n\n\t\tp = abs(1.0 - pos[i]);\n\t\tif (p < minDist) { minDist = p;  BorderNormal = -1.0*UnitVectors[i]; }\t\n\n        #ifdef CLIP_TO_SLAB\t\n\t\tp = abs( SlabRadii[i] + pos_s[i] );\n\t\tif ( p < minDist ) { minDist = p;  BorderNormal = SlabAxes[i];  isSlabBorder = true; }\n\n\t\tp = abs( SlabRadii[i] - pos_s[i] );\n\t\tif ( p < minDist ) { minDist = p;  BorderNormal = -1.0*SlabAxes[i]; isSlabBorder = true; }\t\n        #endif\t\t\t\t\t\t\t\n\t}\t\n\n\tbool doBorderMod    = (minDist < borderThresh);\n\tfloat cosFactor     = max( 0.0, dot(normalize(BorderNormal),rayDir) );\n\tBorderNormalWeight  = doBorderMod ? (1.0 - minDist/borderThresh)*pow(cosFactor,0.25) : 0.0;\n\tBorderReflectanceWeight = doBorderMod ? 1.0 - 0.75*pow(cosFactor,4.0) : 1.0;\n\tGradOffset          = (doBorderMod && !isSlabBorder ) ? BorderNormal*gradDelta : Zeros;\n}\n\n\n#ifdef RENDER_SHADOWS\n///////////////////////////////////////////////////////////////////////////////\n//\n// Implements percentage-closer filtering for soft shadow edges.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat calcShadowWeight(vec3 pos, int lightIndex)\n{\n\t// Initialize constants\n\tfloat step = (lightIndex == 0) ? 0.0054*uLights[0].shadowSoftness : 0.0054*uLights[1].shadowSoftness;\n\tfloat dx = step / max(1.0, uOutBufferSize.x/uOutBufferSize.y);\n\tfloat dy = step / max(1.0, uOutBufferSize.y/uOutBufferSize.x);\n\n\t// Get the shadow-map coordinates of the input point\n\tmat4 shadowMvp = (lightIndex == 0) ? uLights[0].shadowMvp : uLights[1].shadowMvp;\n\tvec4 pt = 0.5*(shadowMvp * vec4(pos-0.5, 1.0) + 1.0);\n\n\t// Apply a random offset to reduce banding artifacts\n\tfloat px0 = pt.x + dx * 0.8*(rand(pos.xz) - 0.5);\n\tfloat py0 = pt.y + dy * 0.8*(rand(pos.yz) - 0.5);\n\n\t// Apply a small z-offset to prevent self-shadowing\t\n\tfloat pzd = pt.z - 1.0/uVolShape[0];\n\n\t// Tabulate sampling points\n\tfloat pxp1 = px0 + dx;\n\tfloat pxm1 = px0 - dx;\n\tfloat pxp2 = pxp1 + dx;\n\tfloat pxm2 = pxm1 - dx;\n\tfloat pxp3 = pxp2 + dx;\n\tfloat pxm3 = pxm2 - dx;\n\tfloat pxp4 = pxp3 + dx;\n\tfloat pxm4 = pxm3 - dx;\n\n\tfloat pyp1 = py0 + dy;\n\tfloat pym1 = py0 - dy;\n\tfloat pyp2 = pyp1 + dy;\n\tfloat pym2 = pym1 - dy;\n\tfloat pyp3 = pyp2 + dy;\n\tfloat pym3 = pym2 - dy;\n\tfloat pyp4 = pyp3 + dy;\n\tfloat pym4 = pym3 - dy;\n\n\tfloat fL = float(lightIndex);\n\tpy0  = 0.5*(py0 + fL);\n\tpyp1 = 0.5*(pyp1 + fL);\n\tpym1 = 0.5*(pym1 + fL);\n\tpyp2 = 0.5*(pyp2 + fL);\n\tpym2 = 0.5*(pym2 + fL);\n\tpyp3 = 0.5*(pyp3 + fL);\n\tpym3 = 0.5*(pym3 + fL);\n\tpyp4 = 0.5*(pyp4 + fL);\n\tpym4 = 0.5*(pym4 + fL);\n\t \n\t// Unrolled loop for better performance:\n\tvec4 smTexVal = texture2D(uShadowSampler, vec2(px0, py0));\n\tfloat smDepth = dot(smTexVal.rg, ToFloat16);\n\tfloat wt = float(pzd > smDepth);\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pym4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pym4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pym4)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm3, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm2, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp2, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp3, pym3)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm3, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm2, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp2, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp3, pym2)).rg, ToFloat16 ));\t\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm4, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm3, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm2, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp2, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp3, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp4, pym1)).rg, ToFloat16 ));\n\t\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm4, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm3, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm2, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, py0)).rg, ToFloat16 ));\n\t//-------------------------------------------------------------------------------\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp2, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp3, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp4, py0)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm4, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm3, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm2, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp2, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp3, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp4, pyp1)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm3, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm2, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp2, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp3, pyp2)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm3, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm2, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp2, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp3, pyp3)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxm1, pyp4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(px0,  pyp4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture2D(uShadowSampler, vec2(pxp1, pyp4)).rg, ToFloat16 ));\n\n\treturn wt/61.0;\t\t\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets a random number given a 2-component seed.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat rand(vec2 xy)\n{\n    return fract(sin(dot(xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Encodes the components of a vec3 in an rgba color.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 encodeVec3(vec3 loc)\n{\n\tif ( any(lessThan(loc,Zeros)) || any(greaterThan(loc,Ones)) ) \n\t{\n\t\t// We indicate an invalid value by setting the rightmost bit\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t}\t\n\n\t// Use 10 bits for each coordinate\n\thighp int xi = int( min(1023.0, (loc.x*1023.0 + 0.5)) );\n\thighp int yi = int( min(1023.0, (loc.y*1023.0 + 0.5)) );\n\thighp int zi = int( min(1023.0, (loc.z*1023.0 + 0.5)) );\n\n\tint zLo = zi - (zi/128) * 128;\n\tint zHi = (zi - zLo)/128;\n\n\tint yLo = yi - (yi/32) * 32;\n\tint yHi = (yi - yLo)/32;\n\n\tint xLo = xi - (xi/8) * 8;\n\tint xHi = (xi - xLo)/8;\n\n\tfloat a = float(zLo*2)/255.0;\n\tfloat b = float(zHi + 8*yLo)/255.0;\n\tfloat g = float(yHi + 32*xLo)/255.0;\n\tfloat r = float(xHi)/255.0;\n\n\treturn vec4(r, g, b, a);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Samples a given texture at a given texture coordinate.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 sampleTexture(vec2 tc, int textureIndex)\n{\n\t// Performance seems to be better if we unroll the first few terms:\n\tif (textureIndex == 0) {\n\t\treturn texture2D(uSamplers[0], tc);\n\t}\n\t#if NUM_IMAGE_TEXTURES >= 2\n\telse if (textureIndex == 1) {\n\t\treturn texture2D(uSamplers[1], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 3\n\telse if (textureIndex == 2) {\n\t\treturn texture2D(uSamplers[2], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 4\n\telse if (textureIndex == 3) {\n\t\treturn texture2D(uSamplers[3], tc);\n\t} \n\t#endif\n\t#endif\n\t#endif\n\telse \n\t{\n\t\tfor (int i=4; i<NUM_IMAGE_TEXTURES; i++) \n\t\t{\n\t\t\tif (i == textureIndex) { return texture2D(uSamplers[i], tc);}\n\t\t}\n\t}\n} \n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point. \n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.5) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0 );\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.5) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel values\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif ( sliceBelowIsEven ) \n\t{\n\t\tpixValB = dot(sampB.rg, ByteMask);\n\t\tpixValA = dot(sampB.ba, ByteMask);\n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.5) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\t\t\n\t\tpixValB = dot(sampB.ba, ByteMask);\n\t\tpixValA = dot(sampA.rg, ByteMask); \n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.25) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.25) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.25) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.5) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.5) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif (sliceBelowIsEven) \n\t{\n\t\tpixValB = dot(sampB, ByteMaskRG); \n\t\tpixValA = dot(sampB, ByteMaskBA); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.5) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = dot(sampB, ByteMaskBA);\n\t\tpixValA = dot(sampA, ByteMaskRG);\n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.25) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\n\tfloat pixVal = dot(samp, byteMask);\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.25) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.25) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\tfloat pixVal = mix( pixValB, pixValA, z-sliceBelow );\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\t\t\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture2D(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,k){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.winLevel_vert_1="// winLevel_vert_1\n//----------------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float;\nprecision highp int;\n\nuniform float  uWinWidth;\nuniform float  uWinLevel;\nattribute vec4 aPosition;\nvarying float  vPixScale;\nvarying float  vPixOffset;\nvarying vec2   vTexCoord;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Convert from clip space to texture coordinates\n    vTexCoord = (aPosition.xy + 1.0)*0.5;\n\n    // Compute the scale and offset factor for the window/level transform\n    float level = uWinLevel*(257.0/65535.0);\n    float width = uWinWidth*(257.0/65535.0);\n\tvPixScale = 1.0/(width + 0.001);\n\tvPixOffset = level - width/2.0;\n\n    gl_Position = aPosition;    \n}\n";b.ShaderCode.winLevel_frag_1=
"// winLevel_frag_1\n//----------------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D uWLSampler;\nuniform sampler2D uLutSampler;\nuniform int       uPassThruMode;\nuniform int       uColorMapIndex;\nuniform vec4      uMarkerColor;\nvarying float     vPixScale;\nvarying float     vPixOffset;\nvarying vec2      vTexCoord;\n\n\nvoid main()\n{\n\t// Read the output from the renderer\n\tvec4 textureVal = texture2D(uWLSampler, vTexCoord);\n\n\tif (uPassThruMode > 0) \n\t{\n\t\t// Pass-thru mode means we don't modify the pixels\n\t\tgl_FragColor = textureVal;\n\t}\n\telse\n\t{\n\t\tif (textureVal.b != 0.0) \n\t\t{\n            // Just render the marker\n\t\t\tgl_FragColor = vec4( ((textureVal.b+2.0)/3.0) * uMarkerColor.rgb, uMarkerColor.a );\n\t    }\n\t\telse\n\t\t{\n\t\t    // Get the raw pixel value\n\t\t\tfloat rawPixVal = textureVal.r + 256.0*textureVal.g;\n\t\t\tif (rawPixVal == 0.0) \n\t\t\t{\n\t\t\t    // We're in the background\n\t\t\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); \n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t    // Apply the window/level transform \n\t\t\t\tfloat wlPixVal = clamp( vPixScale*(rawPixVal - vPixOffset), 0.0, 1.0 );\n\t\t\t\tif (uColorMapIndex == 0) {\t\n\t\t\t\t\tgl_FragColor = vec4(wlPixVal, wlPixVal, wlPixVal, 1.0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t    // Apply the lookup table\n\t\t\t\t\tgl_FragColor = texture2D(uLutSampler, vec2(LUT_TX_XSCALE*wlPixVal, LUT_TX_YOFFSET + float(uColorMapIndex)*LUT_TX_YSCALE));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,k){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.xray_vert_1="// xray_vert_1\n//-----------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nuniform mat4   uMvpTransform;\nuniform mat4   uMvpInvTransform;\nuniform float  uPersp;\nattribute vec4 aPosition;\nvarying vec3   vRayStartT;\nvarying vec3   vRayDirT;\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition;\n    float w = gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0); \n\n\t// Pass the ray's starting point and direction to the fragment shader (in texture coordinates).\n\t// Note that scaling of vRayDirT by w is necessary for perspective-correct interpolation.\n\tvRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = w * (uMvpInvTransform * vec4(gl_Position.xy*(uPersp/w), 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.xray_frag_1=
"// xray_frag_1\n//-----------\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\n// Uniforms and varyings\nuniform sampler2D  uSampler;                      // For volumes that fit in a single texture\nuniform sampler2D  uSamplers[NUM_IMAGE_TEXTURES]; // For volumes that span multiple textures\nuniform sampler2D  uMaskSampler;\nuniform sampler2D  uLutSampler;\nuniform bool   uUseLut;\nuniform bool   uMaskEnabled;\nuniform float  uOpacityRange[2];\nuniform float  uRayStepSize;\nuniform vec3   uVolShape;\nuniform float  uVolNumImages;\nuniform vec4   uMosaicDims;\nuniform int    uNumTextures;\nuniform float  uSlabInfo[24];\nvarying vec3   vRayStartT;\nvarying vec3   vRayDirT;\n\n// Constants\nconst float BBoxTol   = 0.002; \nconst vec3 BboxMin    = vec3(-BBoxTol);\nconst vec3 BboxMax    = vec3(1.0 + BBoxTol);\nconst vec3 Zeros      = vec3(0.0);\nconst vec3 Ones       = vec3(1.0);\nconst vec4 ByteMaskRG = vec4(1.0, 256.0, 0.0, 0.0);\nconst vec4 ByteMaskBA = vec4(0.0, 0.0, 1.0, 256.0);\nconst vec2 ByteMask   = vec2(1.0, 256.0);\nconst vec2 ToFloat16  = vec2(256.0, 1.0)/257.0; // For converting a pair of bytes to a float \n\n// Globals\nfloat PixScale, PixOffset;\nfloat NzM1, MxInv, MyInv;\nint NumMosaicsM1;\nvec2 MinvFirst, MinvLast;\nvec3 VolAspect;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii;\nmat4 SlabXfrm;\n#endif\n\n// Function prototypes\nvoid calcXrayValue(vec3);\nfloat getPixVal(vec3);\nvec4 sampleTexture(vec2, int);\nvec4 encodeVec3(vec3);\nbool isMasked(vec3 pos);\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n\t// Initialize globals\n\tPixScale  = 255.0 * uOpacityRange[1];\n\tPixOffset = uOpacityRange[0] * uOpacityRange[1];\n\n    // Perform ray casting\n\tvec3 rayDir = normalize(vRayDirT);\t\n\tcalcXrayValue(rayDir);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the attenuated x-ray value for a given ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid calcXrayValue(vec3 rayDir)\n{\n\t// Initialize some globals needed by the getPixVal() routines\n\tNumMosaicsM1 = uNumTextures - 1;\t\n\tNzM1 = uVolNumImages - 1.0;\n\tMxInv = 1.0/uMosaicDims[0];\n\tMyInv = 1.0/uMosaicDims[1];    \n\tMinvFirst = vec2(1.0/uMosaicDims[0], 1.0/uMosaicDims[1]);\n\tMinvLast  = vec2(1.0/uMosaicDims[2], 1.0/uMosaicDims[3]);\n\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\t\n\t// Initialize the ray\n\tvec3 pos = vRayStartT;\n\tvec3 rayStep = rayDir*uRayStepSize;\n\tbool enteredSlab = false;\n\t\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\t\n\n\t// Walk along the ray\n\tfloat totalAtten = 0.0;\n\tfor (int i = 0; i < 32768; i++)\n\t{\t\t\n\t\t// Check whether the ray has exited the volume\n\t\tif ( any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\t\t\n\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tpos += rayStep;\n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\n\t\t// Add the current pixel value to the total\n\t\tif (!uMaskEnabled || !isMasked(pos)) {\n\t\t\tfloat pixVal = getPixVal(pos);\n\t\t\tif (uUseLut) {\n\t\t\t\tfloat lutArg = clamp(PixScale*pixVal - PixOffset, 0.0, 1.0);\t\n\t\t\t\tpixVal = 257.0 * texture2D(uLutSampler, vec2(lutArg, LUT_TX_YOFFSET)).a; \n\t\t\t}\n\t\t\ttotalAtten = min(255.0, totalAtten + uRayStepSize*pixVal);\n\t\t}\t\n\n\t\tpos += rayStep;\n\t}\n\n\t// Encode the 16-bit pixel value in two 8-bit color channels\t\n\ttotalAtten *= 255.0;\n\ttotalAtten = max(totalAtten, 1.0); // Do't allow zero, as we use zero to indicate background\n\tfloat highByte = floor(totalAtten/256.0);\n\tfloat lowByte = totalAtten - 256.0*highByte;\n    gl_FragColor = vec4(lowByte/255.0, highByte/255.0, 0.0, 1.0);\n}\n\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tvec3 slabAxis0 = normalize(p1 - p0);\n\tvec3 slabAxis1 = normalize(p2 - p0);\n\tvec3 slabAxis2 = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*slabAxis0.x,  VolAspect.x*slabAxis1.x,  VolAspect.x*slabAxis2.x,  0.0,\n\t\tVolAspect.y*slabAxis0.y,  VolAspect.y*slabAxis1.y,  VolAspect.y*slabAxis2.y,  0.0,\n\t\tVolAspect.z*slabAxis0.z,  VolAspect.z*slabAxis1.z,  VolAspect.z*slabAxis2.z,  0.0,\n       -dot(slabCtr, slabAxis0), -dot(slabCtr, slabAxis1), -dot(slabCtr, slabAxis2),  1.0\n\t);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Encodes the components of a vec3 in an rgba color.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 encodeVec3(vec3 loc)\n{\n\tif ( any(lessThan(loc,Zeros)) || any(greaterThan(loc,Ones)) ) \n\t{\n\t\t// We indicate an invalid value by setting the rightmost bit\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t}\t\n\n\t// Use 10 bits for each coordinate\n\thighp int xi = int( min(1023.0, (loc.x*1023.0 + 0.5)) );\n\thighp int yi = int( min(1023.0, (loc.y*1023.0 + 0.5)) );\n\thighp int zi = int( min(1023.0, (loc.z*1023.0 + 0.5)) );\n\n\tint zLo = zi - (zi/128) * 128;\n\tint zHi = (zi - zLo)/128;\n\n\tint yLo = yi - (yi/32) * 32;\n\tint yHi = (yi - yLo)/32;\n\n\tint xLo = xi - (xi/8) * 8;\n\tint xHi = (xi - xLo)/8;\n\n\tfloat a = float(zLo*2)/255.0;\n\tfloat b = float(zHi + 8*yLo)/255.0;\n\tfloat g = float(yHi + 32*xLo)/255.0;\n\tfloat r = float(xHi)/255.0;\n\n\treturn vec4(r, g, b, a);\n}\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point. \n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.5) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.5) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel values\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif ( sliceBelowIsEven ) \n\t{\n\t\tpixValB = dot(sampB.rg, ByteMask);\n\t\tpixValA = dot(sampB.ba, ByteMask);\n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.5) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\t\t\n\t\tpixValB = dot(sampB.ba, ByteMask);\n\t\tpixValA = dot(sampA.rg, ByteMask); \n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(slice*0.25) * MxInv;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\t\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\t\n\t// Sample the texture\n\tvec2 tc = vec2( xOffset + pos.x*MxInv, (yOffset + pos.y)*MyInv );\t\n\tvec4 samp = texture2D(uSampler, tc);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_ST\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Calculate the texture coordinate factors\n\tfloat temp = floor(sliceBelow*0.25) * MxInv;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\t\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\n\t// Sample the texture\n\tvec2 tcB = vec2( xOffsetB + pos.x*MxInv, (yOffsetB + pos.y)*MyInv );\t\n\tvec4 sampB = texture2D(uSampler, tcB);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\n\t\ttemp = floor(sliceAbove*0.25) * MxInv;\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*MxInv, (yOffsetA + pos.y)*MyInv );\n\t\tvec4 sampA = texture2D(uSampler, tcA);\n\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n \n\n\n#ifdef PIXEL_LAYOUT_16BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.5) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Recombine the appropriate (r,g,b,a) components to get the 16-bit pixel value\n\tvec4 byteMask = mix( ByteMaskRG, ByteMaskBA, mod(slice,2.0) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_16BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 2.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.5) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tfloat pixValA, pixValB;\n\tbool sliceBelowIsEven = ( mod(sliceBelow, 2.0) < 0.5 );\n\tif (sliceBelowIsEven) \n\t{\n\t\tpixValB = dot(sampB, ByteMaskRG); \n\t\tpixValA = dot(sampB, ByteMaskBA); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.5) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = dot(sampB, ByteMaskBA);\n\t\tpixValA = dot(sampA, ByteMaskRG);\n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_NN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat slice = floor(z);\n\t\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndex = int( floor(slice/NumSlicesInFirstMosaic) );\n\tfloat sliceWithinMosaic = mod(slice, NumSlicesInFirstMosaic);\n\n\t// Compute the texture coordinates\n\tvec2 mInv = (mosaicIndex == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceWithinMosaic*0.25) * mInv.x;\n\tfloat yOffset = floor(temp);\n\tfloat xOffset = temp - yOffset;\n\tif (xOffset > 0.9999) { xOffset = 0.0;  yOffset += 1.0; } // Fix for occasional round-off problems\n\tvec2 tc = vec2( xOffset + pos.x*mInv.x,  (yOffset + pos.y)*mInv.y );\t\n\n\t// Sample the texture\n\tvec4 samp = sampleTexture(tc, mosaicIndex);\n\n\t// Pick out the appropriate (r,g,b,a) component\n\tint c = int( mod(slice, 4.0) );\n\tvec4 byteMask = vec4( float(c==0), float(c==1), float(c==2), float(c==3) );\n\treturn dot(samp, byteMask);\n}\n#endif\n\n\n\n\n#ifdef PIXEL_LAYOUT_8BIT_LIN_MT\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getPixVal(vec3 pos)\n{\n\t// Return zero if pos is outside the volume\n\tif ( any(greaterThan(pos,Ones)) || any(lessThan(pos,Zeros)) ) { return 0.0; }\n\n\t// Determine the nearby slice\n\tfloat z = pos.z * NzM1;\t\n\tfloat sliceBelow = floor(z);\n\n\t// Determine the tile and mosaic indices\t\n    float NumSlicesInFirstMosaic = 4.0*uMosaicDims[0]*uMosaicDims[1];\n\tint mosaicIndexBelow = int( floor(sliceBelow/NumSlicesInFirstMosaic) );\n\tfloat sliceBelowWithinMosaic = mod(sliceBelow, NumSlicesInFirstMosaic);\n\t\n\t// Compute the texture coordinates\n\tvec2 mBInv = (mosaicIndexBelow == NumMosaicsM1) ? MinvLast : MinvFirst;\n\tfloat temp = floor(sliceBelowWithinMosaic*0.25) * mBInv.x;\n\tfloat yOffsetB = floor(temp);\n\tfloat xOffsetB = temp - yOffsetB;\n\tif (xOffsetB > 0.9999) { xOffsetB = 0.0;  yOffsetB += 1.0; } // Fix for occasional round-off problems\n\tvec2 tcB = vec2( xOffsetB + pos.x*mBInv.x,  (yOffsetB + pos.y)*mBInv.y );\t\n\n\t// Sample the texture\n\tvec4 sampB = sampleTexture(tcB, mosaicIndexBelow);\n\n\t// Pick out the appropriate (r,g,b,a) components\n\tfloat pixValA, pixValB;\n\tint colorChannel = int( mod(sliceBelow, 4.0) );\n\tif (colorChannel < 3) \n\t{\n\t\tvec3 byteMask = vec3( float(colorChannel==0), float(colorChannel==1), float(colorChannel==2) );\n\t\tpixValB = dot(sampB.rgb, byteMask); \n\t\tpixValA = dot(sampB.gba, byteMask); \n\t} \n\telse // The bracketing slices are in different tiles, so we have more work to do\n\t{\t\n\t\tfloat sliceAbove = min(sliceBelow + 1.0, NzM1);\t\t\n\t\tint mosaicIndexAbove = int( floor(sliceAbove/NumSlicesInFirstMosaic) );\t\n\t    float sliceAboveWithinMosaic = mod(sliceAbove, NumSlicesInFirstMosaic);\n\t\tvec2 mAInv = (mosaicIndexAbove == NumMosaicsM1) ? MinvLast : MinvFirst;\n\n\t\tfloat temp = ( floor(sliceAboveWithinMosaic*0.25) * mAInv.x );\n\t\tfloat yOffsetA = floor(temp);\t\t\n\t\tfloat xOffsetA = temp - yOffsetA;\n\t\tif (xOffsetA > 0.9999) { xOffsetA = 0.0;  yOffsetA += 1.0; } // Fix for occasional round-off problems\n\t\tvec2 tcA = vec2( xOffsetA + pos.x*mAInv.x,   (yOffsetA + pos.y)*mAInv.y );\n\n\t\tvec4 sampA = sampleTexture(tcA, mosaicIndexAbove);\n\t\tpixValB = sampB.a;\n\t\tpixValA = sampA.r;\n\t} \t\t\n\t\n\treturn mix( pixValB, pixValA, z-sliceBelow );\n}\n#endif\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Samples a given texture at a given texture coordinate.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 sampleTexture(vec2 tc, int textureIndex)\n{\n\t// Performance seems to be better if we unroll the first few terms:\n\tif (textureIndex == 0) {\n\t\treturn texture2D(uSamplers[0], tc);\n\t}\n\t#if NUM_IMAGE_TEXTURES >= 2\n\telse if (textureIndex == 1) {\n\t\treturn texture2D(uSamplers[1], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 3\n\telse if (textureIndex == 2) {\n\t\treturn texture2D(uSamplers[2], tc);\n\t} \n\t#if NUM_IMAGE_TEXTURES >= 4\n\telse if (textureIndex == 3) {\n\t\treturn texture2D(uSamplers[3], tc);\n\t} \n\t#endif\n\t#endif\n\t#endif\n\telse \n\t{\n\t\tfor (int i=4; i<NUM_IMAGE_TEXTURES; i++) \n\t\t{\n\t\t\tif (i == textureIndex) { return texture2D(uSamplers[i], tc);}\n\t\t}\n\t}\n} \n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture2D(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,k){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.gfx_vert_2="#version 300 es\n// gfx_vert_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; \nprecision highp int;\n\nin vec4 aPosition;\nin vec3 aNormal;\nin vec4 aColor;\nin vec4 aMaterial;\n\nuniform mat4 uMvpTransform;\nuniform mat4 uRotMatrix;\nuniform float uPersp;\n\nout vec4 vPosition;\nout vec3 vNormal;\nout vec4 vColor;\nout vec4 vMaterial;\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition;\n    gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0); \n\n    // Transform the normal as well\n    vNormal = mat3(uRotMatrix) * aNormal; \n\n    // Set varying values\n    vPosition = gl_Position;\n    vMaterial = aMaterial;\n    vColor = aColor;\n}\n";b.ShaderCode.gfx_frag_2=
"#version 300 es\n// gfx_frag_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; \nprecision highp int;\n\n// Uniforms and varyings\nuniform bool  uRenderDepthMap;\nin vec4       vPosition;\nin vec3       vNormal;\nin vec4       vColor;\nin vec4       vMaterial;\nout vec4      outColor;\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    if (uRenderDepthMap) \n    {\n        // Encode the depth in the b and a channels of the output color\n        float depth = 65535.0*clamp((vPosition.z+1.0)/2.0, 0.0, 1.0);\n        float dHigh = floor(depth/256.0);\n        float dLo = (depth - dHigh*256.0);\n        outColor = vec4(0.0, 0.0, dHigh/255.0, dLo/255.0);\n    }\n    else\n    {\n        // Apply lighting to the fragment color\n        float mAmbient      = vMaterial.r * 2.0;\n        float mDiffuse      = vMaterial.g * 2.0;\n        float mSpecStrength = vMaterial.b * 2.0;\n        float mSpecPower    = vMaterial.a * 255.0;\n\n        vec3 lightDir = vec3(0.0, 0.0, 1.0);\n        float cdot = clamp(-dot(normalize(vNormal), lightDir), 0.0, 1.0);\n        float diffuse = mDiffuse*(cdot - 0.6);\n        float specular = (mSpecStrength == 0.0) ? 0.0 : mSpecStrength * pow(cdot,mSpecPower);\n        \n        float light = max(0.0, mAmbient + diffuse + specular );   \n        outColor = vec4(vColor.rgb*light, vColor.a);\n    }\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,k){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.mip_vert_2="#version 300 es\n// mip_vert_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nuniform mat4  uMvpTransform;\nuniform mat4  uMvpInvTransform;\nuniform float uPersp;\nin vec4       aPosition;\nout vec3      vRayStartT;\nout vec3      vRayDirT;\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition;\n    float w = gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0); \n\n\t// Pass the ray's starting point and direction to the fragment shader (in texture coordinates).\n\t// Note that scaling of vRayDirT by w is necessary for perspective-correct interpolation.\n\tvRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = w * (uMvpInvTransform * vec4(gl_Position.xy*(uPersp/w), 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.mip_frag_2=
"#version 300 es\n// mip_frag_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\nprecision highp sampler3D;\n\n// Uniforms and varyings\nuniform sampler3D  uVolumeSampler;\nuniform sampler2D  uMaskSampler;\nuniform bool       uMaskEnabled;\nuniform int    uBitsPerPixel;\nuniform float  uRayStepSize;\nuniform vec3   uVolShape;\nuniform float  uSlabInfo[24];\nuniform bool   uPickMode;\nuniform vec2   uPickPoint;\nuniform bool   uShowMarker;\nuniform vec3   uMarkerLoc;\nuniform float  uMarkerSize;\nin  vec3 vRayStartT;\nin  vec3 vRayDirT;\nout vec4 outColor;\n\n// Constants\nconst float BBoxTol = 0.002; \nconst vec3 BboxMin  = vec3(-BBoxTol);\nconst vec3 BboxMax  = vec3(1.0 + BBoxTol);\nconst vec3 Zeros    = vec3(0.0);\nconst vec3 Ones     = vec3(1.0);\n\n// Globals\nvec2 PixConvert;\nvec3 VolAspect;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii;\nmat4 SlabXfrm;\n#endif\n\n// Function prototypes\nbool calcMipValue(vec3);\nbool calcPickLocation(vec3);\nvec4 encodeVec3(vec3);\nbool isMasked(vec3);\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n\t// Initialize globals\n\tPixConvert = vec2(1.0, 256.0*float(uBitsPerPixel > 8));\n\t\t\n    // Perform ray casting\n\tvec3 rayDir = normalize(vRayDirT);\t\n\tbool stat = calcPickLocation(rayDir) || calcMipValue(rayDir);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the maximum intensity along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcMipValue(vec3 rayDir)\n{\n\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\n\t// Initialize the ray\n\tvec3 pos = vRayStartT;\n\tvec3 rayStep = rayDir*uRayStepSize;\n\tfloat rayToMarkerDist = 10.0;\n\tbool enteredSlab = false;\n\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\t\n\n\t// Walk along the ray\n\tfloat maxPixVal = 0.0;\n\tint NumSteps = int(sqrt(3.0)/uRayStepSize + 0.5);\n\tfor (int i = 0; i < NumSteps; i++)\n\t{\t\t\n\t\t// Check whether the ray has exited the volume\n\t\tif ( any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\t\t\n\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tpos += rayStep;\n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\t\t\n\t\t// Get the current pixel value and compare it with the maximum\n\t\tif (!uMaskEnabled || !isMasked(pos)) { \n\t\t\tvec4 samp = texture(uVolumeSampler, pos);\n\t\t\tfloat pixVal = dot(samp.rg, PixConvert);\t\t\t\n\t\t\tmaxPixVal = max( maxPixVal, pixVal );\n\t\t}\t\n\t\t\t\n\t\t// Check whether to display a marker\n\t\trayToMarkerDist = min(rayToMarkerDist, length((pos-uMarkerLoc)*VolAspect));\t\n\n\t\tpos += rayStep;\n\t}\n\n\t// Encode the 16-bit pixel value in two 8-bit color channels\t\n\tmaxPixVal *= 255.0;\n\tmaxPixVal = max(maxPixVal, 1.0); // Don't allow zero, as we use zero to indicate background\n\tfloat highByte = floor(maxPixVal/256.0);\n\tfloat lowByte = maxPixVal - 256.0*highByte;\n\tfloat b = float(uShowMarker) * max(0.0, 1.0-rayToMarkerDist/uMarkerSize);\n\toutColor = vec4(lowByte/255.0, highByte/255.0, b, 1.0);\n\treturn true;\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the location of the maximum intensity point along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcPickLocation(vec3 rayDir)\n{\n    if (!uPickMode) { return false; }\n\n\tfloat tol = 1.0; // NB: Units here are pixels, not fractional texture coordinates\n\tif ( (abs(gl_FragCoord.x - uPickPoint.x) > tol) ||  (abs(gl_FragCoord.y - uPickPoint.y) > tol) ) \n\t{\n\t\t// Skip the computation if this is not the target fragment\n\t\toutColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t}\n\telse\n\t{\t\n\t\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\n\t\t// Initialize the ray\n\t\tvec3 pos = vRayStartT;\n\t\tvec3 rayStep = rayDir*uRayStepSize;\n\t\tbool enteredSlab = false;\n\n\t\t// Initialize slab variables\n\t\t#ifdef CLIP_TO_SLAB\n\t\tfloat slabOffset;\n\t\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\t\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t\t#endif\t\n\n\t\t// Initialize max info\n\t\tfloat maxPixVal = 0.0;\n\t\tvec3 maxLoc = vec3(-1.0);\n\n\t\t// Walk along the ray\n\t\tint NumSteps = int(sqrt(3.0)/uRayStepSize + 0.5);\n\t\tfor (int i = 0; i < NumSteps; i++)\n\t\t{\t\t\n\t\t\t// Check whether the ray has exited the volume\n\t\t\tif ( any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\t\t\n\n\t\t\t// Honor any slab constraints\n\t\t\t#ifdef CLIP_TO_SLAB\n\t\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\t\tif ( enteredSlab ) { break; }\n\t\t\t\tpos += rayStep;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tenteredSlab = true;\n\t\t\t#endif\n\t\t\t\n\t\t\t// Get the current pixel value and compare it with the maximum\n\t\t\tif (!uMaskEnabled || !isMasked(pos)) { \n\t\t\t\tvec4 samp = texture(uVolumeSampler, pos);\n\t\t\t\tfloat pixVal = dot(samp.rg, PixConvert);\t\t\t\n\t\t\t\tif (pixVal > maxPixVal) {\n\t\t\t\t\tmaxPixVal = pixVal;\n\t\t\t\t\tmaxLoc = pos;\t\n\t\t\t\t}\n\t\t\t}\t\n\t\t\tpos += rayStep;\n\t\t}\n\n\t\t// Encode the max location in the output color\t\n\t\toutColor = encodeVec3(maxLoc);\n\t}\n\treturn true;\n}\n\t\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tvec3 slabAxis0 = normalize(p1 - p0);\n\tvec3 slabAxis1 = normalize(p2 - p0);\n\tvec3 slabAxis2 = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*slabAxis0.x,  VolAspect.x*slabAxis1.x,  VolAspect.x*slabAxis2.x,  0.0,\n\t\tVolAspect.y*slabAxis0.y,  VolAspect.y*slabAxis1.y,  VolAspect.y*slabAxis2.y,  0.0,\n\t\tVolAspect.z*slabAxis0.z,  VolAspect.z*slabAxis1.z,  VolAspect.z*slabAxis2.z,  0.0,\n       -dot(slabCtr, slabAxis0), -dot(slabCtr, slabAxis1), -dot(slabCtr, slabAxis2),  1.0\n\t);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Encodes the components of a vec3 in an rgba color.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 encodeVec3(vec3 loc)\n{\n\tif ( any(lessThan(loc,Zeros)) || any(greaterThan(loc,Ones)) ) \n\t{\n\t\t// We indicate an invalid value by setting the rightmost bit\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t}\t\n\n\t// Use 10 bits for each coordinate\n\tint xi = min(1023, int(loc.x*1023.0 + 0.5));\n\tint yi = min(1023, int(loc.y*1023.0 + 0.5));\n\tint zi = min(1023, int(loc.z*1023.0 + 0.5));\n\n\tint zLo = zi - (zi/128) * 128;\n\tint zHi = (zi - zLo)/128;\n\n\tint yLo = yi - (yi/32) * 32;\n\tint yHi = (yi - yLo)/32;\n\n\tint xLo = xi - (xi/8) * 8;\n\tint xHi = (xi - xLo)/8;\n\n\tfloat a = float(zLo*2)/255.0;\n\tfloat b = float(zHi + 8*yLo)/255.0;\n\tfloat g = float(yHi + 32*xLo)/255.0;\n\tfloat r = float(xHi)/255.0;\n\n\treturn vec4(r, g, b, a);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,k){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.shadows_vert_2="#version 300 es\n// shadows_vert_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nuniform mat4 uShadowMvpTransform;\nuniform mat4 uShadowMvpInvTransform;\nin vec4      aPosition;\nout vec3     vRayStartT;\nout vec3     vRayDirT;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space\n    gl_Position = uShadowMvpTransform * aPosition; \n\n    // Pass the ray's starting point and direction, in texture coordinates, to the fragment shader\n\tvRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = (uShadowMvpInvTransform * vec4(0.0, 0.0, 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.shadows_frag_2=
"#version 300 es\n// shadows_frag_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\nprecision highp sampler3D;\n\n// Uniforms and varyings\nuniform sampler3D  uVolumeSampler;\nuniform sampler2D  uLutSampler;\nuniform sampler2D  uMaskSampler;\nuniform bool       uMaskEnabled;\nuniform vec3       uVolShape;\nuniform int        uBitsPerPixel;\nuniform float      uRayStepSize;\nuniform float      uOpacityRange[2];\nuniform float      uSlabInfo[24];\nuniform mat4       uShadowMvpTransform;\n\nin  vec3 vRayStartT;\nin  vec3 vRayDirT;\nout vec4 outColor;\n\n// Constants\nconst vec3 Ones             = vec3(1.0);\nconst vec3 Zeros            = vec3(0.0);\nconst float BBoxTol         = 0.002; \nconst vec3 BboxMin          = vec3(-BBoxTol);\nconst vec3 BboxMax          = vec3(1.0+BBoxTol);\nconst float TransparencySat = 0.02; // Saturation value\n\n// Globals\nvec3 VolAspect;\nvec2 PixConvert;\nfloat PixScale, PixOffset;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii, SlabAxes[3];\nmat4 SlabXfrm;\n#endif\n\n// Function prototypes\nvec4 renderShadowMap(vec3);\nfloat getNormalizedPixVal(vec3);\nvec4  encodeFloat(float);\nbool isMasked(vec3);\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n\t// Initialize globals\n\tPixConvert = vec2(1.0, 256.0*float(uBitsPerPixel > 8));\n\tPixScale   = 255.0 * uOpacityRange[1];\n\tPixOffset  = uOpacityRange[0] * uOpacityRange[1];\n\n\t// Compute the shadow map\n    outColor = renderShadowMap( normalize(vRayDirT) );\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the shadow map.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 renderShadowMap(vec3 rayDir)\n{\n\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\n\t// Initialize locals\n\tfloat stepSize   = uRayStepSize;\n\tvec3  rayStep    = stepSize * rayDir;\n\tfloat opacityExp = stepSize * 128.0;\n\tfloat bestDelta  = -1.0; \n\tfloat bestDepth  =  1.0;\n\tvec4 shadowMvp   = vec4(uShadowMvpTransform[0][2], uShadowMvpTransform[1][2], uShadowMvpTransform[2][2], uShadowMvpTransform[3][2]);\n\n\t// Initialize the ray\n\tvec3 pos        = vRayStartT;\n\tfloat tTot      = 1.0;\n\tfloat tBase     = 1.0;\n\tbool climbing   = false;\n\tbool enteredSlab = false;\n\t\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\n\n\t// Walk along the ray, looking for the largest jump in opacity\n\tint NumSteps = int(4.0/uRayStepSize); // We'll break out of the loop before hitting NumSteps\n\tfor (int i = 0; i < NumSteps; i++)\n\t{\t\t\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\t\t\t\n\t\t\tpos += rayStep; \n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\n\t\tif (uMaskEnabled && isMasked(pos)) { \n\t\t\tpos += rayStep; \n\t\t\tcontinue; \n\t\t}\n\n\t\t// Get the cuurent voxel's opacity \n\t\tfloat opac = texture( uLutSampler, vec2(getNormalizedPixVal(pos), LUT_TX_YOFFSET)).a;\n\t\tif (opac == 0.0)\n\t\t{\n\t\t\t// We have entered an empty-space region, so increase the stepsize\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\n\t\t}\n\t\telse if (stepSize > 1.5*uRayStepSize) \n\t\t{\n\t\t\t// Revert to normal-size steps, and back-up a bit\n\t\t\tstepSize = uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\n\t\t\tpos -= rayStep;\n\t\t\topac = texture( uLutSampler, vec2(getNormalizedPixVal(pos), LUT_TX_YOFFSET)).a;\n\t\t}\n\n\t\t// Update the accumulated transparency\n\t\tfloat t = pow(max(0.0, 1.0-opac), opacityExp);\n\t\ttBase = mix(tBase, tTot, float(!climbing));\n\t\ttTot *= t;\n\t\tclimbing = climbing || (t < 0.99);\n\n\t\t// Check whether we are ending a climb, or maybe even the whole ray\n\t\tvec3 nextPos = pos + rayStep;\n\t\tbool terminateRay = (tTot < TransparencySat) || any(lessThan(nextPos, BboxMin)) || any(greaterThan(nextPos, BboxMax));\n\t\tif ( climbing && ((t >= 0.99) || terminateRay) ) // We are ending a climb\n\t\t{\n\t\t\tclimbing = false;\n\t\t\tfloat delta = tBase - tTot; \n\t\t\tfloat improved = float(delta > bestDelta);\n\t\t\tbestDelta = mix(bestDelta, delta, improved);\n\t\t\tbestDepth = mix(bestDepth, dot(shadowMvp, vec4(pos-0.5, 1.0)), improved);\n\t\t\tterminateRay = terminateRay || (bestDelta >= tTot);  \t\t\t\t\n\t\t}\n\t\tif (terminateRay) { break; }\n\n\t\tpos = nextPos;\n\t}\n\t\n\t// Return the best depth estimate\n\tfloat d = (bestDepth + 1.0)/2.0; // Ranges between 0.0 and 1.0\n\treturn encodeFloat(d);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point, normalized to the\n//   range [0,1].\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\t\n\t// Sample the volume\n\tvec4 samp = texture(uVolumeSampler, pos);\n\n\t// Combine color channels to decode the pixel value\n\tbool inBounds = all(lessThanEqual(pos,Ones)) && all(greaterThanEqual(pos,Zeros));\n\tfloat pixVal = dot(samp.rg, PixConvert) * float(inBounds);\t\n\n\t// Normalize\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\n}\n\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tSlabAxes[0] = normalize(p1 - p0);\n\tSlabAxes[1] = normalize(p2 - p0);\n\tSlabAxes[2] = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*SlabAxes[0].x,  VolAspect.x*SlabAxes[1].x,  VolAspect.x*SlabAxes[2].x,  0.0,\n\t\tVolAspect.y*SlabAxes[0].y,  VolAspect.y*SlabAxes[1].y,  VolAspect.y*SlabAxes[2].y,  0.0,\n\t\tVolAspect.z*SlabAxes[0].z,  VolAspect.z*SlabAxes[1].z,  VolAspect.z*SlabAxes[2].z,  0.0,\n       -dot(slabCtr, SlabAxes[0]), -dot(slabCtr, SlabAxes[1]), -dot(slabCtr, SlabAxes[2]),  1.0\n\t);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Encodes a float value in the first two components of a vec4.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 encodeFloat(float val)\n{\n\tfloat cVal = 65535.0 * clamp(val, 0.0, 1.0);\n\tfloat dHi = floor(cVal/256.0);\n\tfloat dLo = cVal - dHi*256.0;\n\treturn vec4(dHi/255.0, dLo/255.0, 0.0, 1.0);\n}\n\t\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,k){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.slab_vert_2="#version 300 es\n// slab_vert_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float;\nprecision highp int;\n\nin vec4       aPosition;\nin vec4       aColor;\nout vec4      vColor;\nuniform mat4  uMvpTransform;\nuniform float uPersp;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    gl_Position = uMvpTransform * aPosition;\n    gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0);\n    vColor = aColor;\n}\n";b.ShaderCode.slab_frag_2=
"#version 300 es\n// slab_frag_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; \nprecision highp int;\nin vec4 vColor;\nout vec4 outColor;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    outColor = vColor;\n}\n"})(window.BigLime=window.BigLime||{});
(function(b,k){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.vr_vert_2="#version 300 es\n// vr_vert_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nin vec4       aPosition;\nuniform mat4  uMvpTransform;\nuniform mat4  uMvpInvTransform;\nuniform float uPersp;\nout vec3      vRayStartT;\nout vec3      vRayDirT;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition;\n    float w = gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0); \n\n\t// Pass the ray's starting point and direction to the fragment shader (in texture coordinates).\n\t// Note that scaling of vRayDirT by w is necessary for perspective-correct interpolation.\n\tvRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = w * (uMvpInvTransform * vec4(gl_Position.xy*(uPersp/w), 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.vr_frag_2=
"#version 300 es\n// vr_frag_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\nprecision highp sampler3D;\n\n// Uniforms and varyings\nuniform sampler3D  uVolumeSampler;\nuniform sampler2D  uLutSampler;\nuniform sampler2D  uMaskSampler;\nuniform bool       uMaskEnabled;\nuniform vec3   uVrBackColor;\nuniform vec3   uVolShape;\nuniform int    uBitsPerPixel;\nuniform float  uRayStepSize;\nuniform vec2   uOutBufferSize;\nuniform float  uOpacityRange[2];\nuniform int    uAntiAlias;\nuniform float  uSlabInfo[24];\nuniform bool   uSealBorders;\nuniform bool   uPickMode;\nuniform vec2   uPickPoint;\nuniform bool   uShowMarker;\nuniform vec3   uMarkerLoc;\nuniform float  uMarkerSize;\nuniform vec4   uMarkerColor;\nuniform mat4   uModelTransform;\nuniform mat4   uViewTransform;\nuniform float  uAmbientLight;\nstruct Light {\n\tfloat diffuse;\n\tfloat specStrength;\n\tfloat specExp;\n\tfloat shadowDarkness;\n\tfloat shadowSoftness;\n\tvec3  dir;\n\tmat4  shadowMvp;\n};\nuniform Light uLights[2];\n\n#ifdef RENDER_GRAPHICS\nuniform sampler2D uGfxSampler;\nuniform float uGfxBlendWeight;\n#endif\n#ifdef RENDER_SHADOWS\nuniform sampler2D uShadowSampler;\n#endif\n\nin  vec3 vRayStartT;\nin  vec3 vRayDirT;\nout vec4 outColor;\n\n \n// Constants\nconst vec3 UnitVectors[3]   = vec3[3]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0) );\nconst vec3 Ones             = vec3(1.0);\nconst vec3 Zeros            = vec3(0.0);\nconst float BBoxTol         = 0.002; \nconst vec3 BboxMin          = vec3(-BBoxTol);\nconst vec3 BboxMax          = vec3(1.0 + BBoxTol);\nconst float TransparencySat = 0.02; // Saturation value\nconst vec2 ToFloat16        = vec2(256.0, 1.0)/257.0; // For converting a pair of bytes to a float \n\n\n// Globals\nvec3 VolAspect, BorderNormal, GradOffset;\nfloat BorderNormalWeight, BorderReflectanceWt;\nvec2 PixConvert;\nfloat PixScale, PixOffset;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii, SlabAxes[3];\nmat4 SlabXfrm;\n#endif\n\n\n// Function prototypes\nbool  calcVrValue(vec3);\nbool  calcPickLocation(vec3);\nfloat getNormalizedPixVal(vec3);\nvoid  getBorderInfo(vec3, vec3, vec3, float, vec3);\nfloat rand(vec2);\nvec4  encodeVec3(vec3);\nbool isMasked(vec3);\n\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n#ifdef RENDER_SHADOWS\nfloat calcShadowWeight(vec3, int);\n#endif\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n\t// Initialize globals\n\tPixConvert = vec2(1.0, 256.0*float(uBitsPerPixel > 8));\n\tPixScale   = 255.0 * uOpacityRange[1];\n\tPixOffset  = uOpacityRange[0] * uOpacityRange[1];\n\t\t\n\t// Perform ray casting\n\tvec3 rayDir = normalize(vRayDirT);\n    bool stat = calcPickLocation(rayDir) || calcVrValue(rayDir);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the integrated color and opacity along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcVrValue(vec3 rayDir)\n{\n\t// Initializations\n\tVolAspect           = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\tvec3 gdx            = vec3(1.0/uVolShape[0], 0.0, 0.0);      // Offset for computing grad.x\n\tvec3 gdy            = vec3(0.0, 1.0/uVolShape[1], 0.0);      // Offset for computing grad.y\n\tvec3 gdz            = vec3(0.0, 0.0, 1.0/uVolShape[2]);      // Offset for computing grad.z\n\tvec3 gradDelta      = 1.5 * vec3(gdx.x, gdy.y, gdz.z);       // Offsets for computing gradients near borders\n\tfloat stepSize      = uRayStepSize;                          // The step-size for raycasting\n\tvec3 rayStep        = uRayStepSize * rayDir;                 // The ray increment\n\tfloat opacityExp    = uRayStepSize * 128.0;                  // For scaling the opacity to the ray step size\n\tfloat borderThresh  = uRayStepSize * 5.0;                    // Distance threshold for shading border surfaces \n\tfloat random        = rand(gl_FragCoord.xy);                 // For antialiasing\n\tint randIndex       = int(10.0*random + 1.0);\n\tfloat randRayOffset = float(uAntiAlias) * uRayStepSize * (random - 0.5); \n\n\t// Default border values\n\tBorderNormal = vec3(1.0, 0.0, 0.0);\n\tBorderNormalWeight = 0.0;\n\tBorderReflectanceWt = 1.0;\n\tGradOffset = vec3(0.0);\n\n\t// Initialize the ray\n\tfloat tTot            = 1.0;                                 // Accumulated transparency\n\tvec3 cTot             = vec3(0.0);                           // Accumulated color\n\tvec3 pos              = vRayStartT;                          // Current ray position\n\tvec3 pos_s            = vec3(0.0);                           // Current ray position in slab coordinates\n\tfloat currPixVal      = getNormalizedPixVal(pos);\n\tfloat prevPixVal      = 0.0;\n\tfloat nextPixVal      = 0.0;\n\tvec3 prevGrad         = vec3(0.0);\t\n\tfloat perpMarkerDist  = length( cross( (pos-uMarkerLoc)*VolAspect, normalize(rayDir*VolAspect) ) );\n\tbool omitMarkerTest   = !uShowMarker || (perpMarkerDist > uMarkerSize);\n\tbool enteredSlab      = false;\n\n\t\n\t#ifdef RENDER_GRAPHICS\n\tvec2 fragCoord = 0.5*gl_FragCoord.xy/uOutBufferSize;\n\tvec4 gfxColor0 = texture(uGfxSampler, vec2(fragCoord.x,       fragCoord.y      ));\n\tvec4 gfxDepth0 = texture(uGfxSampler, vec2(fragCoord.x + 0.5, fragCoord.y      ));\n\tvec4 gfxColor1 = texture(uGfxSampler, vec2(fragCoord.x,       fragCoord.y + 0.5));\n\tvec4 gfxDepth1 = texture(uGfxSampler, vec2(fragCoord.x + 0.5, fragCoord.y + 0.5));\n\tfloat depth0 = 2.0* dot(gfxDepth0.ba, ToFloat16) - 1.0;\n\tfloat depth1 = 2.0* dot(gfxDepth1.ba, ToFloat16) - 1.0;\n\tbool omitG0Test = (depth0 > 0.999);\n\tbool omitG1Test = (depth1 > 0.999);\n\tmat4 mvTransform = uViewTransform * uModelTransform;\n\tvec4 mvTransformZ = vec4(mvTransform[0][2], mvTransform[1][2], mvTransform[2][2], mvTransform[3][2]);\n\t#endif\n\n\tfloat prevShadowWeight0 = -1.0;\n\tfloat prevShadowWeight1 = -1.0;\n\tfloat sh0 = uLights[0].shadowDarkness;\n\tfloat sh1 = uLights[1].shadowDarkness;\n\tfloat drel0 = (uLights[0].diffuse == uLights[1].diffuse) ? 0.5 : uLights[0].diffuse/(uLights[0].diffuse + uLights[1].diffuse + 0.0001);\n\tfloat drel1 = 1.0 - drel0;\n\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\n\n\t// Walk along the ray\n\tint NumSteps = int(4.0/uRayStepSize); // We'll break out of the loop before hitting NumSteps\n\tfor (int i = 0; i < NumSteps; i++)\n\t{\t\t\n\t\t// We're done if the ray has exited the volume, or if the opacity threshold is exceeded\n\t\tif ( (tTot < TransparencySat) || any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\n\n\t\t// Does the current ray position intersect the marker?\n\t\tif (!omitMarkerTest)\n\t\t{\t\n\t\t\tvec3 pmVec = (pos - uMarkerLoc)*VolAspect;\t\n\t\t\tif ( length(pmVec) <= uMarkerSize ) {\n\t\t\t\tfloat pmPerpDist = length( cross(pmVec, normalize(rayDir*VolAspect)) );\n\t\t\t\tfloat shade = mix(1.0 - pmPerpDist/uMarkerSize, 1.0, 0.4);\n\t\t\t\tcTot += shade * uMarkerColor.rgb * uMarkerColor.a * tTot;\n\t\t\t\ttTot *= 1.0 - uMarkerColor.a;\n\t\t\t\tomitMarkerTest = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t\t\t\t\n\t\t// Apply random ray offset for antialiasing\n\t\tpos += (float(i == randIndex) * randRayOffset) * rayDir;\n\n\t\t#ifdef RENDER_GRAPHICS\t\t\n\t\tif ( !omitG0Test || !omitG1Test )\n\t\t{\t\n\t\t\tfloat gPosZ = dot(mvTransformZ, vec4(pos-0.5, 1.0));\n\t\t\tif ((!omitG1Test) && (gPosZ > depth1)) {\n\t\t\t\tcTot += gfxColor1.rgb * gfxColor1.a * tTot;\n\t\t\t\tcTot = mix(cTot, gfxColor1.rgb, uGfxBlendWeight);\n\t\t\t\ttTot *= 1.0 - gfxColor1.a;\n\t\t\t\tomitG1Test = true;\n\t\t\t\tcontinue;\t\t\t\n\t\t\t}\n\t\t\tif ((!omitG0Test) && (gPosZ > depth0)) {\n\t\t\t\tcTot += gfxColor0.rgb * gfxColor0.a * tTot;\n\t\t\t\tcTot = mix(cTot, gfxColor0.rgb, uGfxBlendWeight);\n\t\t\t\ttTot *= 1.0 - gfxColor0.a;\n\t\t\t\tomitG0Test = true;\n\t\t\t\tcontinue;\t\t\t\n\t\t\t}\n\t\t}\n\t\t#endif\t\t\n\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tpos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tprevPixVal = 0.0;  currPixVal = 0.0;\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\t\t\t\n\t\t\tpos += rayStep;  \n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\n\t\t// Get the pixel value. Use 3-point averaging along the ray\n\t\tnextPixVal = getNormalizedPixVal(pos + rayStep);\n\t\tfloat pixVal = 0.25*( prevPixVal + 2.0*currPixVal + nextPixVal );\n\t\tprevPixVal = currPixVal;  currPixVal = nextPixVal;\n\n\t\t// Check the opacity value\n\t\tvec4 lutVal = (uMaskEnabled && isMasked(pos)) ? vec4(0.0) : texture(uLutSampler, vec2(pixVal, LUT_TX_YOFFSET)); \n\t\tif (lutVal.a == 0.0)\n\t\t{\n\t\t\t// We have entered an empty-space region, so increase the stepsize\n\t\t\tstepSize = 2.0*uRayStepSize;\n\t\t\trayStep = stepSize*rayDir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (stepSize > 1.5*uRayStepSize) {\n\t\t\t\t// Revert to normal-size steps, and back-up\n\t\t\t\tstepSize    = uRayStepSize;\n\t\t\t\trayStep     = stepSize*rayDir;\n\t\t\t\tpos        -= rayStep;\n\t\t\t\tcurrPixVal  = getNormalizedPixVal(pos);\n\t\t\t\tprevPixVal  = getNormalizedPixVal(pos - rayStep);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check whether we are near a border\n\t\t\tif (uSealBorders) {\n\t\t\t\tgetBorderInfo(pos, rayDir, pos_s, borderThresh, gradDelta);\n\t\t\t}\n\n\t\t\t// Compute the intensity gradient\n\t\t\tvec3 gpos = pos + GradOffset;\n\t\t\tvec3 grad = vec3( \n\t\t\t\tgetNormalizedPixVal(gpos + gdx) - getNormalizedPixVal(gpos - gdx),\n\t\t\t\tgetNormalizedPixVal(gpos + gdy) - getNormalizedPixVal(gpos - gdy),\n\t\t\t\tgetNormalizedPixVal(gpos + gdz) - getNormalizedPixVal(gpos - gdz) );\t\n\n\t\t\t// Modify the gradient near borders\n\t\t\tgrad = mix(grad, BorderNormal, BorderNormalWeight);\n\t\t\tgrad = mix(grad, prevGrad, 0.5);\n\t\t\tprevGrad = grad;\n\t\t\tfloat gradMag = length(grad);\n\n\t\t\t// Compute the lighting factors\n\t\t\tvec3 N = grad/gradMag;\n\t\t\tvec3 L0 = uLights[0].dir;\n\t\t\tvec3 L1 = uLights[1].dir;\n\t\t\tvec3 R0 = reflect(-1.0*L0, N); // Assumes that L0, L1 are normalized\n\t\t\tvec3 R1 = reflect(-1.0*L1, N);\n\n\t\t\tfloat diffuse0 = 2.0 * uLights[0].diffuse * max(0.0, dot(N,L0));\n\t\t\tfloat diffuse1 = 2.0 * uLights[1].diffuse * max(0.0, dot(N,L1));\n\n\t\t\tfloat sdot0 = max(0.0, dot(R0, rayDir));\n\t\t\tfloat sdot1 = max(0.0, dot(R1, rayDir));\n\t\t\tfloat specular0 = 2.0 * uLights[0].specStrength * pow(sdot0, uLights[0].specExp);\n\t\t\tfloat specular1 = 2.0 * uLights[1].specStrength * pow(sdot1, uLights[1].specExp);\n\n\t\t\tfloat dsFactor = float(gradMag > 0.001)*BorderReflectanceWt;\n\t\t\tfloat light0 = uAmbientLight*drel0 + (diffuse0 + specular0)*dsFactor; \n\t\t\tfloat light1 = uAmbientLight*drel1 + (diffuse1 + specular1)*dsFactor; \n\n\t\t\t// Maybe draw shadows\n\t\t\t#ifdef RENDER_SHADOWS\n\t\t\tif (sh0 > 0.0) { \n\t\t\t\tfloat shadowWeight0 = ((prevShadowWeight0 < 0.0) || (tTot > 0.10)) ? calcShadowWeight(pos,0) : prevShadowWeight0;\n\t\t\t\tlight0 *= max(0.0, 1.0-sh0*shadowWeight0);\n\t\t\t\tprevShadowWeight0 = shadowWeight0;\n\t\t\t}\n\t\t\tif (sh1 > 0.0) {\n\t\t\t\tfloat shadowWeight1 = ((prevShadowWeight1 < 0.0) || (tTot > 0.10)) ? calcShadowWeight(pos,1) : prevShadowWeight1;\n\t\t\t\tlight1 *= max(0.0, 1.0-sh1*shadowWeight1); \n\t\t\t\tprevShadowWeight1 = shadowWeight1;\n\t\t\t}\n\t\t\t#endif // RENDER_SHADOWS\n\n\t\t\t// Update the total color\n\t\t\tfloat light = light0 + light1;\n\n\t\t\tfloat t = pow(max(0.0, 1.0-lutVal.a), opacityExp);\n\t\t\tvec3 c = lutVal.rgb * (1.0 - t) * light;\n\t\t\tcTot += c*tTot;\n\t\t\ttTot *= t;\n\t\t}\n\t\t\t\n\t\tpos += rayStep;\n\t}\n\t\n\tcTot += uVrBackColor*tTot;\n\toutColor = vec4(cTot, 1.0);\n\treturn true;\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the location of the most salient point along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool calcPickLocation(vec3 rayDir)\n{\n    if (!uPickMode) { return false; }\n\n\tfloat tol = 1.0; // NB: Units here are pixels, not fractional texture coordinates\n\tif ( (abs(gl_FragCoord.x - uPickPoint.x) > tol) ||  (abs(gl_FragCoord.y - uPickPoint.y) > tol) ) \n\t{\n\t\t// Skip the computation if this is not the target fragment\n\t\toutColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t}\n\telse\n\t{\n\t\t// Initializations\n\t\tVolAspect            = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\t\tvec3 rayStep         = uRayStepSize * rayDir;\n\t\tfloat opacityExp     = uRayStepSize * 128.0;\n\t\tvec3 maxLoc          = vec3(-1.0);\n\t\tvec3 runStart        = vec3(-1.0);\n\t\tfloat bestDelta      = -1.0; \n\n\t\t// Initialize the ray\n\t\tvec3 pos = vRayStartT;\n\t\tfloat tTot = 1.0;\n\t\tfloat tBase = -1.0;\n\t\t\n\t\t// Initialize slab variables\n\t\t#ifdef CLIP_TO_SLAB\n\t\tfloat slabOffset;\n\t\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\t\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t\t#endif\n\n\t\t// Walk along the ray\n\t\tint NumSteps = int(4.0/uRayStepSize); // We'll break out of the loop before hitting NumSteps\n\t\tfor (int i = 0; i < NumSteps; i++)\n\t\t{\t\t\n\t\t\t// Honor any slab constraints\n\t\t\t#ifdef CLIP_TO_SLAB\n\t\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\t\tpos += rayStep;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t#endif\n\n\t\t\t// Update the accumulated transparency\n\t\t\tfloat opac = (uMaskEnabled && isMasked(pos)) ? 0.0 : texture(uLutSampler, vec2(getNormalizedPixVal(pos), LUT_TX_YOFFSET)).a;\n\t\t\tfloat t = pow( max(0.0, 1.0-opac), opacityExp);\n\t\t\ttTot *= t;\n\n\t\t\t// Check whether the transparency is strictly decreasing\n\t\t\tif ( (t < 0.99) && (runStart.x < 0.0) )  \n\t\t\t{ \n\t\t\t\trunStart = pos; // The voxel has some opacity, so we are starting a new run\n\t\t\t\ttBase = tTot;\n\t\t\t}\n\n\t\t\tvec3 nextPos = pos + rayStep;\n\t\t\tbool terminateRay = (tTot < TransparencySat) || any(lessThan(nextPos, BboxMin)) || any(greaterThan(nextPos, BboxMax));\n\t\t\tif ( (runStart.x >= 0.0) && ((t >= 0.99) || terminateRay) ) // We are ending a run\n\t\t\t{\n\t\t\t\tfloat delta = tBase - tTot; \n\t\t\t\tfloat improved = float(delta > bestDelta);\n\t\t\t\tbestDelta = mix(bestDelta, delta, improved);\n\t\t\t\tmaxLoc = mix(maxLoc, runStart, improved);\n\t\t\t\trunStart = vec3(-1.0); \t\n\t\t\t\tterminateRay = terminateRay || (bestDelta >= tTot);  \t\t\t\n\t\t\t}\n\t\t\tif (terminateRay) { break; }\t\t\n\n\t\t\tpos = nextPos;\n\t\t}\n\t\t\n\t\t// Encode the max location in the output color\t\n\t\toutColor = encodeVec3(maxLoc);\n\t}\n\treturn true;\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the pixel value at a given volume point, normalized to the\n//   range [0,1].\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat getNormalizedPixVal(vec3 pos)\n{\n\t// Sample the volume\n\tvec4 samp = texture(uVolumeSampler, pos);\n\n\t// Combine color channels to decode the pixel value\n\tbool inBounds = all(lessThanEqual(pos,Ones)) && all(greaterThanEqual(pos,Zeros));\n\tfloat pixVal = dot(samp.rg, PixConvert) * float(inBounds);\t\n\n\t// Normalize\n\treturn clamp(pixVal*PixScale - PixOffset, 0.0, 1.0);\t\n}\n\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tSlabAxes[0] = normalize(p1 - p0);\n\tSlabAxes[1] = normalize(p2 - p0);\n\tSlabAxes[2] = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*SlabAxes[0].x,  VolAspect.x*SlabAxes[1].x,  VolAspect.x*SlabAxes[2].x,  0.0,\n\t\tVolAspect.y*SlabAxes[0].y,  VolAspect.y*SlabAxes[1].y,  VolAspect.y*SlabAxes[2].y,  0.0,\n\t\tVolAspect.z*SlabAxes[0].z,  VolAspect.z*SlabAxes[1].z,  VolAspect.z*SlabAxes[2].z,  0.0,\n       -dot(slabCtr, SlabAxes[0]), -dot(slabCtr, SlabAxes[1]), -dot(slabCtr, SlabAxes[2]),  1.0\n\t);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets the distance to the nearest border, and the normal vector of\n//   that border.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid getBorderInfo(vec3 pos, vec3 rayDir, vec3 pos_s, float borderThresh, vec3 gradDelta)\n{\n\t// Check the volume borders\n\tfloat minDist = borderThresh + 1.0;\n\tbool isSlabBorder = false;\n\t\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tfloat p = abs(pos[i]);\n\t\tif (p < minDist) { minDist = p;  BorderNormal = UnitVectors[i]; }\t\n\n\t\tp = abs(1.0 - pos[i]);\n\t\tif (p < minDist) { minDist = p;  BorderNormal = -1.0*UnitVectors[i]; }\t\n\n        #ifdef CLIP_TO_SLAB\t\n\t\tp = abs( SlabRadii[i] + pos_s[i] );\n\t\tif ( p < minDist ) { minDist = p;  BorderNormal = SlabAxes[i];  isSlabBorder = true; }\n\n\t\tp = abs( SlabRadii[i] - pos_s[i] );\n\t\tif ( p < minDist ) { minDist = p;  BorderNormal = -1.0*SlabAxes[i]; isSlabBorder = true; }\t\n        #endif\t\t\t\t\t\t\t\n\t}\t\n\n\tbool doBorderMod    = (minDist < borderThresh);\n\tfloat cosFactor     = max( 0.0, dot(normalize(BorderNormal),rayDir) );\n\tBorderNormalWeight  = doBorderMod ? (1.0 - minDist/borderThresh)*pow(cosFactor,0.25) : 0.0;\n\tBorderReflectanceWt = doBorderMod ? 1.0 - 0.75*pow(cosFactor,4.0) : 1.0;\n\tGradOffset          = (doBorderMod && !isSlabBorder ) ? BorderNormal*gradDelta : Zeros;\n}\n\n\n#ifdef RENDER_SHADOWS\n///////////////////////////////////////////////////////////////////////////////\n//\n// Implements percentage-closer filtering for soft shadow edges.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat calcShadowWeight(vec3 pos, int lightIndex)\n{\n\t// Initialize constants\n\tfloat step = uLights[lightIndex].shadowSoftness * 0.0054;\n\tfloat dx = step / max(1.0, uOutBufferSize.x/uOutBufferSize.y);\n\tfloat dy = step / max(1.0, uOutBufferSize.y/uOutBufferSize.x);\n\n\t// Get the shadow-map coordinates of the input point\n\tvec4 pt = 0.5*(uLights[lightIndex].shadowMvp * vec4(pos-0.5, 1.0) + 1.0);\n\n\t// Apply a random offset to reduce banding artifacts\n\tfloat px0 = pt.x + dx * 0.8*(rand(pos.xz) - 0.5); \n\tfloat py0 = pt.y + dy * 0.8*(rand(pos.yz) - 0.5);\n\t\t\n\t// Apply a small z-offset to prevent self-shadowing\t\n\tfloat pzd = pt.z - 1.0/uVolShape[0]; \n\n\t// Tabulate sampling points\n\tfloat pxp1 = px0  + dx;\n\tfloat pxm1 = px0  - dx;\n\tfloat pxp2 = pxp1 + dx;\n\tfloat pxm2 = pxm1 - dx;\n\tfloat pxp3 = pxp2 + dx;\n\tfloat pxm3 = pxm2 - dx;\n\tfloat pxp4 = pxp3 + dx;\n\tfloat pxm4 = pxm3 - dx;\n\n\tfloat pyp1 = py0  + dy;\n\tfloat pym1 = py0  - dy;\n\tfloat pyp2 = pyp1 + dy;\n\tfloat pym2 = pym1 - dy;\n\tfloat pyp3 = pyp2 + dy;\n\tfloat pym3 = pym2 - dy;\n\tfloat pyp4 = pyp3 + dy;\n\tfloat pym4 = pym3 - dy;\n\n\tfloat fL = float(lightIndex);\n\tpy0  = 0.5*(py0 + fL);\n\tpyp1 = 0.5*(pyp1 + fL);\n\tpym1 = 0.5*(pym1 + fL);\n\tpyp2 = 0.5*(pyp2 + fL);\n\tpym2 = 0.5*(pym2 + fL);\n\tpyp3 = 0.5*(pyp3 + fL);\n\tpym3 = 0.5*(pym3 + fL);\n\tpyp4 = 0.5*(pyp4 + fL);\n\tpym4 = 0.5*(pym4 + fL);\n\t \n\t// Unrolled loop for better performance:\n\tvec4 smTexVal = texture(uShadowSampler, vec2(px0, py0));\n\tfloat smDepth = dot(smTexVal.rg, ToFloat16);\n\tfloat wt = float(pzd > smDepth);\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pym4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pym4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pym4)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm3, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm2, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp2, pym3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp3, pym3)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm3, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm2, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp2, pym2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp3, pym2)).rg, ToFloat16 ));\t\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm4, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm3, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm2, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp2, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp3, pym1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp4, pym1)).rg, ToFloat16 ));\n\t\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm4, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm3, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm2, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, py0)).rg, ToFloat16 ));\n\t//-------------------------------------------------------------------------------\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp2, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp3, py0)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp4, py0)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm4, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm3, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm2, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp2, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp3, pyp1)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp4, pyp1)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm3, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm2, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp2, pyp2)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp3, pyp2)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm3, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm2, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp2, pyp3)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp3, pyp3)).rg, ToFloat16 ));\n\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxm1, pyp4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(px0,  pyp4)).rg, ToFloat16 ));\n\twt += float(pzd > dot( texture(uShadowSampler, vec2(pxp1, pyp4)).rg, ToFloat16 ));\n\n\treturn wt/61.0;\t\t\n}\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Gets a random number given a 2-component seed.\n//\n///////////////////////////////////////////////////////////////////////////////\nfloat rand(vec2 xy)\n{\n    return fract(sin(dot(xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Encodes the components of a vec3 in an rgba color.\n//\n///////////////////////////////////////////////////////////////////////////////\nvec4 encodeVec3(vec3 loc)\n{\n\tif ( any(lessThan(loc,Zeros)) || any(greaterThan(loc,Ones)) ) \n\t{\n\t\t// We indicate an invalid value by setting the rightmost bit\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t}\t\n\n\t// Use 10 bits for each coordinate\n\tint xi = min(1023, int(loc.x*1023.0 + 0.5));\n\tint yi = min(1023, int(loc.y*1023.0 + 0.5));\n\tint zi = min(1023, int(loc.z*1023.0 + 0.5));\n\n\tint zLo = zi - (zi/128) * 128;\n\tint zHi = (zi - zLo)/128;\n\n\tint yLo = yi - (yi/32) * 32;\n\tint yHi = (yi - yLo)/32;\n\n\tint xLo = xi - (xi/8) * 8;\n\tint xHi = (xi - xLo)/8;\n\n\tfloat a = float(zLo*2)/255.0;\n\tfloat b = float(zHi + 8*yLo)/255.0;\n\tfloat g = float(yHi + 32*xLo)/255.0;\n\tfloat r = float(xHi)/255.0;\n\n\treturn vec4(r, g, b, a);\n}\n\t\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,k){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.winLevel_vert_2="#version 300 es\n// winLevel_vert_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float;\nprecision highp int;\n\nuniform float uWinWidth;\nuniform float uWinLevel;\nin vec4       aPosition;\nout float     vPixScale;\nout float     vPixOffset;\nout vec2      vTexCoord;\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Convert from clip space to texture coordinates\n    vTexCoord = (aPosition.xy + 1.0)*0.5;\n\n    // Compute the scale and offset factor for the window/level transform\n    float level = uWinLevel*(257.0/65535.0);\n    float width = uWinWidth*(257.0/65535.0);\n\tvPixScale = 1.0/(width + 0.001);\n\tvPixOffset = level - width/2.0;\n\n    gl_Position = aPosition;    \n}\n";b.ShaderCode.winLevel_frag_2=
"#version 300 es\n// winLevel_frag_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D uWLSampler;\nuniform sampler2D uLutSampler;\nuniform int       uPassThruMode;\nuniform int       uColorMapIndex;\nuniform vec4      uMarkerColor;\nin float          vPixScale;\nin float          vPixOffset;\nin vec2           vTexCoord;\nout vec4          outColor;\n\nvoid main()\n{\n\t// Read the output from the renderer\n\tvec4 textureVal = texture(uWLSampler, vTexCoord);\n\n\tif (uPassThruMode > 0) \n\t{\n\t\t// Pass-thru mode means we don't modify the pixels\n\t\toutColor = textureVal;\n\t}\n\telse\n\t{\n\t\tif (textureVal.b != 0.0) \n\t\t{\n            // Just render the marker\n\t\t\toutColor = vec4( ((textureVal.b+2.0)/3.0) * uMarkerColor.rgb, uMarkerColor.a );\n\t    }\n\t\telse\n\t\t{\n\t\t    // Get the raw pixel value\n\t\t\tfloat rawPixVal = textureVal.r + 256.0*textureVal.g;\n\t\t\tif (rawPixVal == 0.0) \n\t\t\t{\n\t\t\t    // We're in the background\n\t\t\t\toutColor = vec4(0.0, 0.0, 0.0, 1.0); \n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t    // Apply the window/level transform \n\t\t\t\tfloat wlPixVal = clamp( vPixScale*(rawPixVal - vPixOffset), 0.0, 1.0 );\n\t\t\t\tif (uColorMapIndex == 0) {\t\n\t\t\t\t\toutColor = vec4(wlPixVal, wlPixVal, wlPixVal, 1.0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t    // Apply the lookup table\n\t\t\t\t\toutColor = texture(uLutSampler, vec2(LUT_TX_XSCALE*wlPixVal, LUT_TX_YOFFSET + float(uColorMapIndex)*LUT_TX_YSCALE));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\n\t\t// Recombine the R and G color channels into a 16-bit pixel value\n\t\tfloat rawPixVal = textureVal.r + 256.0*textureVal.g;\n\n\t\tif (textureVal.b == 0.0) {\n\t\t    // Apply the window/level transform\n\t\t\tif (uColorMapIndex == 0) {\n\t\t\t\tfloat wlPixVal = (rawPixVal == 0.0) ? 0.0 : clamp( vPixScale*(rawPixVal - vPixOffset), 0.0, 1.0 );\n\t\t\t\toutColor = vec4(wlPixVal, wlPixVal, wlPixVal, 1.0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfloat wlPixVal = (rawPixVal == 0.0) ? 0.0 : clamp( vPixScale*(rawPixVal - vPixOffset), 0.0, 1.0 );\n\t\t\t\toutColor = texture(uLutSampler, vec2(LUT_TX_XSCALE*wlPixVal, LUT_TX_YOFFSET + float(uColorMapIndex)*LUT_TX_YSCALE));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Render the marker\n\t\t\toutColor = vec4( ((textureVal.b+2.0)/3.0) * uMarkerColor.rgb, uMarkerColor.a );\n\t\t}\n\t}\n}\n"})(window.BigLime=
window.BigLime||{});
(function(b,k){b.ShaderCode=b.ShaderCode||{};b.ShaderCode.xray_vert_2="#version 300 es\n// xray_vert_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\n\nuniform mat4  uMvpTransform;\nuniform mat4  uMvpInvTransform;\nuniform float uPersp;\nin vec4       aPosition;\nout vec3      vRayStartT;\nout vec3      vRayDirT;\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    // Transform the input vertex from world-space to clip-space. (Setting the w-component implements perspective.)\n    gl_Position = uMvpTransform * aPosition;\n    float w = gl_Position.w = 1.0 + uPersp*(gl_Position.z + 1.0); \n\n\t// Pass the ray's starting point and direction to the fragment shader (in texture coordinates).\n\t// Note that scaling of vRayDirT by w is necessary for perspective-correct interpolation.\n\tvRayStartT = aPosition.xyz + 0.5;\n\tvRayDirT = w * (uMvpInvTransform * vec4(gl_Position.xy*(uPersp/w), 1.0, 0.0)).xyz;\n}\n";b.ShaderCode.xray_frag_2=
"#version 300 es\n// xray_frag_2\n\n//<<SYMBOL_DEFS>>//\n\nprecision highp float; // We need highp to accurately specify locations in large textures\nprecision highp int;\nprecision highp sampler3D;\n\n// Uniforms and varyings\nuniform sampler3D  uVolumeSampler;\nuniform sampler2D  uMaskSampler;\nuniform sampler2D  uLutSampler;\nuniform bool   uUseLut;\nuniform bool   uMaskEnabled;\nuniform float  uOpacityRange[2];\nuniform int    uBitsPerPixel;\nuniform float  uRayStepSize;\nuniform vec3   uVolShape;\nuniform float  uSlabInfo[24];\nin  vec3 vRayStartT;\nin  vec3 vRayDirT;\nout vec4 outColor;\n\n// Constants\nconst float BBoxTol = 0.002; \nconst vec3 BboxMin  = vec3(-BBoxTol);\nconst vec3 BboxMax  = vec3(1.0 + BBoxTol);\nconst vec3 Zeros    = vec3(0.0);\nconst vec3 Ones     = vec3(1.0);\n\n// Globals\nvec2 PixConvert;\nfloat PixScale, PixOffset;\nvec3 VolAspect;\n#ifdef CLIP_TO_SLAB\nvec3 SlabRadii;\nmat4 SlabXfrm;\n#endif\n\n// Function prototypes\nvoid calcXrayValue(vec3);\nbool isMasked(vec3);\n#ifdef CLIP_TO_SLAB\nvoid  initializeSlabInfo(vec3, vec3, out float);\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Program entry point.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n\t// Initialize globals\n\tPixConvert = vec2(1.0, 256.0*float(uBitsPerPixel > 8));\n\tPixScale   = 255.0 * uOpacityRange[1];\n\tPixOffset  = uOpacityRange[0] * uOpacityRange[1];\n\t\t\n    // Perform ray casting\n\tvec3 rayDir = normalize(vRayDirT);\t\n    calcXrayValue(rayDir);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Computes the attenuated x-ray value along a ray.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid calcXrayValue(vec3 rayDir)\n{\n\tVolAspect = uVolShape/max(max(uVolShape.x, uVolShape.y), uVolShape.z);\n\n\t// Initialize the ray\n\tvec3 pos = vRayStartT;\n\tvec3 rayStep = rayDir*uRayStepSize;\n\tbool enteredSlab = false;\n\n\t// Initialize slab variables\n\t#ifdef CLIP_TO_SLAB\n\tfloat slabOffset;\n\tinitializeSlabInfo(rayDir, pos, slabOffset);\n\tif (slabOffset - 0.05 > 0.0) { pos += (slabOffset - 0.05)*rayDir; }\n\t#endif\t\n\n\t// Walk along the ray\n\tfloat totalAtten = 0.0;\n\tint NumSteps = int(sqrt(3.0)/uRayStepSize + 0.5);\n\tfor (int i = 0; i < NumSteps; i++)\n\t{\t\t\n\t\t// Check whether the ray has exited the volume\n\t\tif ( any(lessThan(pos,BboxMin)) || any(greaterThan(pos,BboxMax)) ) { break; }\t\t\n\n\t\t// Honor any slab constraints\n\t\t#ifdef CLIP_TO_SLAB\n\t\tvec3 pos_s = (SlabXfrm * vec4(pos, 1.0)).xyz;\n\t\tif ( any(greaterThan(abs(pos_s), SlabRadii)) ) {\n\t\t\tif ( enteredSlab ) { break; }\n\t\t\tpos += rayStep;\n\t\t\tcontinue;\n\t\t}\n\t\tenteredSlab = true;\n\t\t#endif\n\t\t\n\t\t// Add the current pixel value to the total\n\t\tif (!uMaskEnabled || !isMasked(pos)) {\n\t\t\tvec4 samp = texture(uVolumeSampler, pos);\n\t\t\tfloat pixVal = dot(samp.rg, PixConvert);\t\n\t\t\tif (uUseLut) {\n\t\t\t\tfloat lutArg = clamp(PixScale*pixVal - PixOffset, 0.0, 1.0);\t\n\t\t\t\tpixVal = 257.0 * texture(uLutSampler, vec2(lutArg, LUT_TX_YOFFSET)).a; \n\t\t\t}\n\t\t\ttotalAtten = min(255.0, totalAtten + uRayStepSize*pixVal );\t\n\t\t}\n\n\t\tpos += rayStep;\n\t}\n\n\t// Encode the 16-bit pixel value in two 8-bit color channels\t\n\ttotalAtten *= 255.0;\n\ttotalAtten = max(totalAtten, 1.0); // Do't allow zero, as we use zero to indicate background\n\tfloat highByte = floor(totalAtten/256.0);\n\tfloat lowByte = totalAtten - 256.0*highByte;\n\toutColor = vec4(lowByte/255.0, highByte/255.0, 0.0, 1.0);\n}\n\n\n#ifdef CLIP_TO_SLAB\n///////////////////////////////////////////////////////////////////////////////\n//\n// Initializes slab-related variables.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid initializeSlabInfo(vec3 rayDir, vec3 rayStart, out float slabOffset)\n{\n\t// Get the corner points in volume coordinates\n\tvec3 p0 = vec3(uSlabInfo[0],  uSlabInfo[1],  uSlabInfo[2] );\n\tvec3 p1 = vec3(uSlabInfo[3],  uSlabInfo[4],  uSlabInfo[5] );\n\tvec3 p2 = vec3(uSlabInfo[6],  uSlabInfo[7],  uSlabInfo[8] );\n\tvec3 p3 = vec3(uSlabInfo[9],  uSlabInfo[10], uSlabInfo[11]);\n\tvec3 p4 = vec3(uSlabInfo[12], uSlabInfo[13], uSlabInfo[14]);\n\tvec3 p5 = vec3(uSlabInfo[15], uSlabInfo[16], uSlabInfo[17]);\n\tvec3 p6 = vec3(uSlabInfo[18], uSlabInfo[19], uSlabInfo[20]);\n\tvec3 p7 = vec3(uSlabInfo[21], uSlabInfo[22], uSlabInfo[23]);\n\n\tslabOffset = min( \n\t\tmin( min(dot(rayDir, p0), dot(rayDir, p1)), min(dot(rayDir, p2), dot(rayDir, p3)) ),\n\t\tmin( min(dot(rayDir, p4), dot(rayDir, p5)), min(dot(rayDir, p6), dot(rayDir, p7)) ) \n\t);\n\tslabOffset -= dot(rayStart, rayDir);\n\n\t// Get the slab axes and center\n\tp0 *= VolAspect;\n\tp1 *= VolAspect;\n\tp2 *= VolAspect;\n\tp4 *= VolAspect;\n\tp7 *= VolAspect;\n\tvec3 slabAxis0 = normalize(p1 - p0);\n\tvec3 slabAxis1 = normalize(p2 - p0);\n\tvec3 slabAxis2 = normalize(p4 - p0);\n\tvec3 slabCtr = (p0 + p7) / 2.0;\n\n\tSlabRadii = vec3(length(p1-p0)/2.0, length(p2-p0)/2.0, length(p4-p0)/2.0);\n\n\t// Construct the transformation matrix from texture coordinates to slab coordinates\n\tSlabXfrm = mat4(\n\t\tVolAspect.x*slabAxis0.x,  VolAspect.x*slabAxis1.x,  VolAspect.x*slabAxis2.x,  0.0,\n\t\tVolAspect.y*slabAxis0.y,  VolAspect.y*slabAxis1.y,  VolAspect.y*slabAxis2.y,  0.0,\n\t\tVolAspect.z*slabAxis0.z,  VolAspect.z*slabAxis1.z,  VolAspect.z*slabAxis2.z,  0.0,\n       -dot(slabCtr, slabAxis0), -dot(slabCtr, slabAxis1), -dot(slabCtr, slabAxis2),  1.0\n\t);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Determines whether a given volume point is masked.\n//\n///////////////////////////////////////////////////////////////////////////////\nbool isMasked(vec3 pos)\n{\n\tvec2 ToFloat16le = vec2(1.0, 256.0)/257.0;\n\tvec4 maskSamp = texture(uMaskSampler, pos.xy);\n\treturn (pos.z < dot(maskSamp.rg, ToFloat16le)) || (1.0 - pos.z < dot(maskSamp.ba, ToFloat16le));\n}\n"})(window.BigLime=
window.BigLime||{});
